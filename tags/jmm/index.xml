<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JMM on 刘科个人博客</title>
    <link>https://pallcard.github.io/tags/jmm/</link>
    <description>Recent content in JMM on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sun, 02 Jun 2019 10:28:33 +0800</lastBuildDate>
    
	<atom:link href="https://pallcard.github.io/tags/jmm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JMM</title>
      <link>https://pallcard.github.io/2019/jmm/</link>
      <pubDate>Sun, 02 Jun 2019 10:28:33 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm/</guid>
      <description>JMM &amp;nbsp; &amp;nbsp; &amp;nbsp;Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。
JMM模型下的线程间通信 线程和主内存之间的抽象关系图： 线程间通信必须要经过主内存。
如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：
1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2）线程B到主内存中去读取线程A之前已更新过的共享变量。 注： 当线程操作某个对象时，执行顺序如下： (1) 从主存复制变量到当前工作内存 (read and load) (2) 执行代码，改变共享变量值 (use and assign) (3) 用工作内存数据刷新主存相关内容 (store and write)
JMM解决的问题 &amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：
原子性 ：一个操作不能被打断，要么全部执行完毕，要么不执行。 基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。
可见性 ：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;无论是 普通变量 还是 volatile变量 都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新 ，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。 除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 synchronized 关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 Lock接口 的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;final关键字 的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去，那么其他线程就可以看到final变量的值。 有序性 ：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。 &amp;nbsp; &amp;nbsp; &amp;nbsp;Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现。</description>
    </item>
    
  </channel>
</rss>
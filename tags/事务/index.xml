<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>事务 on 刘科个人博客</title>
    <link>https://pallcard.github.io/tags/%E4%BA%8B%E5%8A%A1/</link>
    <description>Recent content in 事务 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Thu, 08 Aug 2019 21:58:38 +0800</lastBuildDate>
    
	<atom:link href="https://pallcard.github.io/tags/%E4%BA%8B%E5%8A%A1/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据库事务</title>
      <link>https://pallcard.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 08 Aug 2019 21:58:38 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</guid>
      <description>事务特性 ACID：原子性、一致性、隔离性、持久性
 原子性：一个事务要么全部成功，要么全部失败 一致性：事务提交前后，数据库保持一致性状态 隔离性：一个事务所做的修改，其他事务不可见 持久性：事务一旦提交，所做修改永久保存到数据库中  关系：
原子性 + 隔离性 ---&amp;gt; 一致性 ---&amp;gt; 结果正确 持久性 ----&amp;gt; 应对数据库崩溃  并发一致性 当多个事务并发执行时会导致事务不能保证一致性，导致结果出错。
丢失修改、读脏数据、不可重复读、幻读
 丢失修改：对于同一数据，T1 修改数据后，T2 又修改数据，T1修改读数据被覆盖 读脏数据：T1修改数据后，T2读该数据，T1又回滚数据，T2读脏数据 不可重复读：T1读数据后，T2对该数据进行修改，T1再读该数据，读得的数据值不一致 幻读：T1读数据（例如count统计表中行数），T2插入一行数据，导致数据不一致  三级封锁协议  一级封锁：当更新数据时，立即加X锁，直到事务结束。 ==&amp;gt; 解决了丢失修改 二级封锁：在1上，当读数据时，立即加S锁，读完立即释放锁。 ==&amp;gt; 解决了读脏数据 三级封锁：在2上，当读数据时，立即加S锁，直到事务结束。 ==&amp;gt; 解决了不可重复读  两段锁协议 加锁和解锁分成两个阶段。一个阶段加锁，一个阶段解锁。保证可串行性化调度。
隔离级别  未提交读：事务的修改未提交前，其他事务可见 读：不加锁； 更新 ： 行级共享锁 提交读： 事务的修改在未提交前，其他事务不可见 读：行级共享锁； 更新： 行级排他锁 可重复读： 一个事务中的多次读结果一致 读：行级共享锁； 更新：行级排他锁 可串行化：事务串行执行 读：表级共享锁； 更新：表级排他锁  解决的问题
   隔离级别 脏读 不可重复读 幻读     未提交读 - - -   提交读  - -   可重复读   -   可串行化       mysql事务隔离级别的实现 MVCC（多版本并发控制）  版本号  1.</description>
    </item>
    
  </channel>
</rss>
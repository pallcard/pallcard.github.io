<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sat, 15 Jun 2019 19:43:24 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>FastDFS</title>
      <link>https://pallcard.github.io/2019/fastdfs/</link>
      <pubDate>Sat, 15 Jun 2019 19:43:24 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/fastdfs/</guid>
      <description>

&lt;h4 id=&#34;1-fastdfs-理论&#34;&gt;1. FastDFS 理论&lt;/h4&gt;

&lt;p&gt;FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。
FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tracker server&lt;/strong&gt;
跟踪服务器，主要做调度工作，起负载均衡的作用。负责管理所有的storage server和group，每个storage在启动后会连接tracker，告诉tracker自己所属的group，并保持周期性心跳，tracker根据storage的心跳信息，建立映射表，tracke管理的元数据很少（tracker上的元数据都是由storage汇报产生），并且直接存在内存中，本身不需要持久化任何数据。tracker之间是对等的，因此扩展tracker是很容易的，直接增加tracker服务，同时修改storage的配置，增加新增的tarcker服务的地址和端口，重启即可。所有的tracker都会接受storage的心跳信息，以生成元数据信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;storage server&lt;/strong&gt;
存储服务器（又称：存储节点或数据服务器），顾名思义是用来保存文件的和文件属性的。以group为单位，每个group内可以包含多台storage server，数据互为备份，存储容量空间以group中storage server容量最小的为准。以group为单位组织存储能够方便的进行应用隔离、负责均衡和副本数定制；确定是group的容量受单机容量的限制。group内机器故障，需要依赖group内其他机器重新同步数据来恢复数据（更换坏盘，重启fdfs_storaged即可）。storage存储依赖本地文件系统，storage课配置多个数据存储目录，磁盘不做raid，直接分别挂在到多个目录，将这些目录配置为storage的数据目录即可。&lt;/p&gt;

&lt;p&gt;storage接收写请求的时候，会根据配置好的规则，选择其中一个存储目录来存储文件；为了避免单个目录下的文件过多，storage第一次启动的时候，会在每个数据存储目录创建2级子目录，每级256，总共65536个目录，新写的文件会以hash的方式路由到其中一个子目录下，然后将文件数据直接作为一个本地文件存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client&lt;/strong&gt;
客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。
&lt;img src=&#34;https://pallcard.github.io/images/fastdfs001.png&#34; alt=&#34;文件上传&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;文件上传&#34;&gt;文件上传&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs002.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
&lt;strong&gt;生成file id&lt;/strong&gt;
选择存储目录之后，storage会生成一个file_id，采用base64编码，包含有：storage server ip，文件创建时间，文件大小，文件CRC32校验码和随机数。每个存储目录下有两个256*256个子目录，storage会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为名字存储。
文件路径如下：
group0/M00/00/00/rBAAAl0EkICAIiBOAAABowgL3Pk888.png
* 组名：group0
* 磁盘： M00
* 目录：00/00
* 文件名：rBAAAl0EkICAIiBOAAABowgL3Pk888.png&lt;/p&gt;

&lt;p&gt;文件索引信息包括：&lt;strong&gt;组名，虚拟磁盘路径，数据两级目录，文件名&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存。&lt;/li&gt;
&lt;li&gt;虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应。&lt;/li&gt;
&lt;li&gt;数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。&lt;/li&gt;
&lt;li&gt;文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;文件下载&#34;&gt;文件下载&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs003.png&#34; alt=&#34;文件下载&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-安装fastdfs环境&#34;&gt;2.安装FastDFS环境&lt;/h4&gt;

&lt;h5 id=&#34;下载安装-libfastcommon&#34;&gt;下载安装 libfastcommon&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;yum -y install libevent
# 下载libfastcommon
wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz
# 解压
tar -zxvf V1.0.7.tar.gz
# 编译、安装
cd libfastcommon-1.0.7
 ./make.sh
 ./make.sh install
 cd /usr/lib64
 ll libfast* 
 # 复制libfastcommon.so 到 usr/lib
 cp libfastcommon.so /usr/lib
 cd /usr/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;下载安装fastdfs&#34;&gt;下载安装FastDFS&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 下载FastDFS
wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz
# 解压FastDFS
tar -zxvf V5.05.tar.gz
# 编译、安装
cd fastdfs-5.05
 ./make.sh
 ./make.sh install
 
# 配置tracker
cd /usr/bin
ll fdfs*
cd /etc/fdfs/
# 进入 fastdfs-5.05/conf目录
cp * /etc/fdfs/
vim tracker.conf
# 修改 base_path=/fastdfs/tracker
cd /
mkdir /fastdfs/tracker -p
cd fastdfs/
mkdir storage
mkdir client
cd /usr/bin
fdfs_trackerd /etc/fdfs/tracker.conf
fdfs_trackerd /etc/fdfs/tracker.conf restart

# 配置storage
vim storage.conf
# 修改 base_path=/fastdfs/storage
#     store_path0=/fastdfs/storage
#     tracker_server=203.195.238.249:22122
cd /usr/bin
fdfs_storaged /etc/fdfs/storage.conf restart

# 配置client
vim client.conf
# 修改 base_path=/fastdfs/client
#     tracker_server=203.195.238.249:22122
# 测试 (先放一张图片到/root/test/headImg.jpg)
fdfs_test /etc/fdfs/client.conf upload /root/test/headImg.jpg
# 返回路径http://203.195.238.249/group1/M00/00/00/rBAAAl0EX5WAQtpGAACGZ5UrSuI275_big.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;目录结构&#34;&gt;目录结构&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;|--- /
	|---fastdfs
		|---client
		|---storage
			|---data
				|---存储的文件 256*256个目录
			|---logs
		|---tracker
			|---data
			|---logs
		|---tmp
	|---usr
		|---lib
			|---libfastcommon.so
		|---lib64
			|---libfastcommon.so
		|---bin
			|---fdfs* 命令工具
	|---etc
		|---fdfs
			|---client.conf
			|---tracker.conf
			|---storage.conf
			|---mod_fastdfs.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;安装nginx&#34;&gt;安装nginx&lt;/h5&gt;

&lt;p&gt;1.安装nginx
2.修改配置文件，加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	server  {
        listen       88;
        server_name  localhost;
       
        location /group1/M00 {
           alias /fastdfs/storage/data;
		}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.即可根据服务器的80端口访问到图片&lt;/p&gt;

&lt;h5 id=&#34;fastdfs-nginx-module&#34;&gt;fastdfs-nginx-module&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 下载
wget wget https://github.com/happyfish100/fastdfs-nginx-module/archive/5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 解压
unzip 5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 重命名
mv fastdfs-nginx-module-5e5f3566bbfa57418b5506aaefbe107a42c9fcb1  fastdfs-nginx-module-master
# 先停掉nginx服务
/usr/local/nginx/sbin/nginx -s stop
# 进入之前安装nginx的解压包的位置
cd nginx-1.14.2
# 添加fastdfs-nginx-module模块
./configure --add-module=../fastdfs-nginx-module-master/src
# 重新编译、安装
make &amp;amp;&amp;amp; make install
# 复制fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录
cp mod_fastdfs.conf /etc/fdfs
cd /etc/fdfs
mkdir /fastdfs/tmp
vim mod_fastdfs.conf
# 修改 store_path0=/fastdfs/storage
#     tracker_server=203.195.238.249:22122
#     base_path=/fastdfs/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改nginx的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	server  {
        listen       88;
        server_name  localhost;
       
        location /group1/M00 {
            ngx_fastdfs_module;
		}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;部署结构图&#34;&gt;部署结构图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs004.png&#34; alt=&#34;部署结构图&#34; /&gt;
参考：&lt;a href=&#34;https://www.cnblogs.com/chiangchou/p/fastdfs.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/chiangchou/p/fastdfs.html&lt;/a&gt;
           &lt;a href=&#34;https://www.cnblogs.com/chiangchou/p/fastdfs.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/chiangchou/p/fastdfs.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初试部署项目到腾讯云（环境的安装）</title>
      <link>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 15 Jun 2019 19:32:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h4 id=&#34;linux常用命令&#34;&gt;linux常用命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ls：查看该目录下文件&lt;/li&gt;
&lt;li&gt;pwd：查看文件目录&lt;/li&gt;
&lt;li&gt;rm -f 文件名：删除文件&lt;/li&gt;
&lt;li&gt;/usr/local/mysql/bin/mysql -u root -p 登录mysql&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;第一步-jdk的安装&#34;&gt;第一步：jdk的安装&lt;/h4&gt;

&lt;p&gt;下载jdk后，解压报错（原因是选择接受协议的问题），输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wget --no-check-certificate --no-cookies --header &amp;quot;Cookie: oraclelicense=accept-securebackup-cookie&amp;quot; https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压jdk压缩包，使用命令 tar -zxvf 文件名&lt;/p&gt;

&lt;p&gt;然后配置环境变量，主要编辑以下两个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;vi /etc/environment 
vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后使用java -version查看版本信息&lt;/p&gt;

&lt;h4 id=&#34;第二步-mysql的安装&#34;&gt;第二步：mysql的安装&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;下载mysql ，以5.7为例&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sudo wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压  tar -zxvf 文件名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;移动 文件到 /usr/local/&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;重命名 mv 文件名 mysql&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;新建data目录 mkdir data&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新建mysql用户、mysql用户组&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;mysql用户组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;groupadd mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;mysql用户&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;useradd mysql -g mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;将/usr/local/mysql的所有者及所属组改为mysql&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;chown -R mysql.mysql /usr/local/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;配置，初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后出错，libnuma原因，执行如下命令，后再初始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;yum install -y numactl
vim /etc/my.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;my.cnf中改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[mysqld]
datadir=/usr/local/mysql/data
basedir=/usr/local/mysql
socket=/tmp/mysql.sock
user=mysql
port=3306
character-set-server=utf8
# 取消密码验证
skip-grant-tables
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
# skip-grant-tables
[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;开启服务&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;将mysql加入服务
cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 开机自启
chkconfig mysql on
# 开启
service mysql start
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;设置密码&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 登录（由于/etc/my.cnf中设置了取消密码验证，所以此处密码任意）

/usr/local/mysql/bin/mysql -u root -p

# 操作mysql数据库

&amp;gt;&amp;gt;use mysql;

# 修改密码

&amp;gt;&amp;gt;update user set authentication_string=password(&#39;你的密码&#39;) where user=&#39;root&#39;;

&amp;gt;&amp;gt;flush privileges;

&amp;gt;&amp;gt;exit;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;将/etc/my.cnf中的skip-grant-tables删除，至此mysql安装完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注: mysql 远程连接问题&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;use mysql

select host,user from user;

update user set host=&#39;%&#39; where user =&amp;quot;root&amp;quot;;

# 刷新权限
flush privileges;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第三步-redis的安装&#34;&gt;第三步：redis的安装&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;下载 解压&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wget http://download.redis.io/releases/redis-4.0.10.tar.gz

tar -xzf redis-4.0.10.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cd redis-4.0.10
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：若执行make出错，可能是c++未装，使用命令 yum -y install gcc-c++&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置远程访问&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进入redis目录，vi redis.conf 修改配置文件&lt;/p&gt;

&lt;p&gt;注释绑定的本机地址
​​&lt;img src=&#34;https://pallcard.github.io/images/linux001.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
设置redis-service为后台服务
将&amp;rdquo;daemonize no&amp;rdquo;改为&amp;rdquo;daemonize yes&amp;rdquo;
​​​​​​​​&lt;img src=&#34;https://pallcard.github.io/images/linux002.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
设置redis-cli连接redis服务器的密码
&lt;img src=&#34;https://pallcard.github.io/images/linux003.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 启动redis（进入redis目录）
./src/redis-server redis.conf
# 查看进程
ps -ef | grep redis
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;第四步-nginx的安装&#34;&gt;第四步：nginx的安装&lt;/h5&gt;

&lt;p&gt;准备(安装pcre和zlib最新版本):&lt;/p&gt;

&lt;p&gt;1.pcre:&lt;a href=&#34;https://ftp.pcre.org/pub/pcre/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://ftp.pcre.org/pub/pcre/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.zlib:&lt;a href=&#34;http://www.zlib.net/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.zlib.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.nginx：&lt;a href=&#34;https://nginx.org/en/download.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wget 下载地址
tar -xvzf 文件名
cd 文件目录
./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：在阿里云添加安全组规则&lt;/p&gt;

&lt;p&gt;参考博客：&lt;/p&gt;

&lt;p&gt;主要参考：&lt;a href=&#34;https://www.jianshu.com/p/9cac6c9df0e0&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.jianshu.com/p/9cac6c9df0e0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mysql：&lt;a href=&#34;https://www.cnblogs.com/hl15/p/9541479.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/hl15/p/9541479.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;redis：&lt;a href=&#34;https://www.cnblogs.com/wangchunniu1314/p/6339416.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/wangchunniu1314/p/6339416.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;make出错：&lt;a href=&#34;https://blog.csdn.net/weixin_40493969/article/details/81150469&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/weixin_40493969/article/details/81150469&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot之配置文件</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 08 Jun 2019 20:21:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>

&lt;h5 id=&#34;1-配置文件基本使用&#34;&gt;1.配置文件基本使用&lt;/h5&gt;

&lt;p&gt;使用.yml配置文件，在resources目录下新建application.yml文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;server:
  port: 8081 #修改端口号
  servlet:
    context-path: /lk  #端口号后需额外添加字符
#以上等同于application.properties的以下写法
#server.port=8081
#server.servlet.context-path=/zed

swagger:
  title: SpringBoot学习
  description: SpringBoot学习
  version: 1.0.0
  name: lk
  url: https://pallcard.github.io
  email: 1250585541@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
* 其中空格有严格的要求&lt;/p&gt;

&lt;h5 id=&#34;2-切换配置文件&#34;&gt;2.切换配置文件&lt;/h5&gt;

&lt;p&gt;在resources目录下新建application-dev.yml文件，application-prod.yml文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//文件目录
resources|-
         application.yml
         application-dev.yml
         application-prod.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中application.yml来切换配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;spring:
  profiles:
    active: dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;激活文件选择&lt;/em&gt;&lt;/strong&gt;
* 使用上述application.yml来设置
* 使用java -jar ***.jar &amp;ndash;spring.profiles.active=dev;
* IDEA中可以如下设置
&lt;img src=&#34;images/springboot001.png&#34; alt=&#34;激活配置文件&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-配置文件使用&#34;&gt;3.配置文件使用&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;单值注入 （.yml中值若用双引号，转义字符会转义）
```java
//.yml中
person:
name: zhangsan \n lisi
name2: &amp;lsquo;zhangsan \n lisi&amp;rsquo;
name3: &amp;ldquo;zhangsan \n lisi&amp;rdquo;
age: 18
boss: false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;//使用
    @Value(&amp;ldquo;${person.name}&amp;rdquo;)
    private String name;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Value(&amp;quot;${person.name2}&amp;quot;)
private String name2;


@Value(&amp;quot;${person.name3}&amp;quot;)
private String name3;

@Value(&amp;quot;${person.age}&amp;quot;)
private String age;

@Value(&amp;quot;${person.boss}&amp;quot;)
private String boss;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 批量注入 
```java
//application.yml
student:
  name: lk
  age: 23
  boss: false
  birth: 1997/1/1
  maps: {k1: v1, k2: v2}
  lists:
  - 张三
  - 李四
  dog:
    name: 小黑
    age: 2
    
// pojo.Student
@ConfigurationProperties(prefix = &amp;quot;student&amp;quot;)
@Component
@Data
public class Student {
    private String name;
    private Integer age;
    private Boolean boss;
    private Date birth;
    private Map&amp;lt;String, Object&amp;gt; maps;
    private List&amp;lt;String&amp;gt; lists;
    private Dog dog;
}
// pojo.Dog 
@Data
public class Dog {
    private String name;
    private Integer age;
}

//值注入
 @Autowired
 private Student student;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
* 将配置文件中配置的每一个属性的值，映射到这个组件中
* @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
* prefix = &amp;ldquo;person&amp;rdquo;：配置文件中哪个下面的所有属性进行一一映射
* 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；
* @Data是一个插件，免去了getter/setter和toString这些繁琐的东西&lt;/p&gt;

&lt;h5 id=&#34;4-两种注入区别&#34;&gt;4.两种注入区别&lt;/h5&gt;

&lt;p&gt;|   |@ConfigurationProperties   |@Value
|&amp;ndash;|&amp;ndash;|&amp;ndash;
|功能|    批量注入配置文件中的属性|一个个指定
|松散绑定（松散语法） |支持|    不支持
|SpEL： #{}  |不支持    |支持
|JSR303数据校验 |支持 |不支持
|复杂类型封装|    支持| 不支持&lt;/p&gt;

&lt;p&gt;松散语法绑定：last_name = last-name = lastName 他们取的值都是相同的&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot之Swagger</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</link>
      <pubDate>Sat, 08 Jun 2019 17:49:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</guid>
      <description>

&lt;h5 id=&#34;swagger框架&#34;&gt;Swagger框架&lt;/h5&gt;

&lt;p&gt;描述和测试API接口,自动生成API接口文档。&lt;/p&gt;

&lt;h6 id=&#34;1-添加依赖&#34;&gt;1.添加依赖&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--lombok依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.18.8&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;2-swagger配置&#34;&gt;2.Swagger配置&lt;/h6&gt;

&lt;p&gt;在resources目录下新建application.yml文件，添加如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;swagger:
  title: SpringBoot学习
  description: SpringBoot学习
  version: 1.0.0
  name: lk
  url: https://pallcard.github.io
  email: 1250585541@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建SwaggerConfig文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableWebMvc
@EnableSwagger2
@ConfigurationProperties(prefix = &amp;quot;swagger&amp;quot;)
@Data //lombok
@ComponentScan(basePackages = {&amp;quot;cn.wishhust.demo.controller&amp;quot;})
public class SwaggerConfig {

    private String title;
    private String description;
    private String version;

    private String name;
    private String url;
    private String email;

    @Bean
    public Docket customDocket() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
    }

    private ApiInfo apiInfo() {
        Contact contact = new Contact(name, url, email);
        return new ApiInfoBuilder()
                .title(title)
                .description(description)
                .contact(contact)
                .version(version)
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MVC配置:过滤网页静态资源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
class WebMvcConfig implements WebMvcConfigurer {

    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&amp;quot;swagger-ui.html&amp;quot;)
                .addResourceLocations(&amp;quot;classpath:/META-INF/resources/&amp;quot;);

        registry.addResourceHandler(&amp;quot;/webjars/**&amp;quot;)
                .addResourceLocations(&amp;quot;classpath:/META-INF/resources/webjars/&amp;quot;);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;3-使用&#34;&gt;3.使用&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
@Api(value = &amp;quot;测试&amp;quot;)
public class HelloWorld {

    Logger log = LoggerFactory.getLogger(HelloWorld.class);
    
    @GetMapping(value={&amp;quot;/hello&amp;quot;})
    @ApiOperation(value = &amp;quot;hello&amp;quot;)
//    @ApiImplicitParam
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot传递参数</title>
      <link>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 08 Jun 2019 17:08:34 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</guid>
      <description>

&lt;h5 id=&#34;url传参&#34;&gt;url传参&lt;/h5&gt;

&lt;h6 id=&#34;1-get方式&#34;&gt;1.get方式&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; 	// 访问：http://localhost:8080/test/get/xxx
    @GetMapping(&amp;quot;/get/{name}&amp;quot;)
    public String get(@PathVariable(&amp;quot;name&amp;quot;) String name2){
        System.out.println(&amp;quot;name: &amp;quot;+ name2);
        return &amp;quot;Hi &amp;quot;+ name2;
    }

    // 访问：http://localhost:8080/test/get2?name=yyy
    @GetMapping(&amp;quot;/get2&amp;quot;)
    // 请求参数名字与方法中的形参一致，可以省略@RequestParam
    // public String get2(String name2) {
    public String get2(@RequestParam(&amp;quot;name&amp;quot;) String name2) {
        System.out.println(&amp;quot;name: &amp;quot;+ name2);
        return &amp;quot;Hi &amp;quot;+ name2;
    }

    @GetMapping(&amp;quot;/get3&amp;quot;)
    //给一个默认值或者required = false
    public String get3(@RequestParam(value = &amp;quot;name&amp;quot;, defaultValue = &amp;quot;admin&amp;quot;) String name) {
        System.out.println(&amp;quot;name: &amp;quot;+ name);
        return &amp;quot;Hi &amp;quot;+ name;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;2-post方式&#34;&gt;2.post方式&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PostMapping(&amp;quot;/post&amp;quot;)
    //@RequestParam同get
    public String post(@RequestParam(&amp;quot;username&amp;quot;) String name, Integer age){
        log.info(&amp;quot;name=&amp;quot; + name+&amp;quot;, age=&amp;quot; + age);
        return &amp;quot;name=&amp;quot; + name+&amp;quot;, age=&amp;quot; + age;
    }
    
    @PostMapping(&amp;quot;post2&amp;quot;)
    public String post2(HttpServletRequest request) {
        ServletInputStream is = null;
        StringBuilder sb = null;
        try {
            is = request.getInputStream();
            sb = new StringBuilder();
            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = is.read(buf)) != -1){
                sb.append(new String(buf,0,len));
            }
            System.out.println(sb.toString());
            return sb.toString();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return sb.toString();
    }

    @PostMapping(&amp;quot;/post3&amp;quot;)
    public String post3(@RequestBody User user) {
        log.info(user.toString());
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
* 把json作为参数传递,要用【RequestBody】&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot启动类</title>
      <link>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jun 2019 10:53:04 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</guid>
      <description>

&lt;h5 id=&#34;1-pom文件&#34;&gt;1.POM文件&lt;/h5&gt;

&lt;p&gt;整个项目的pom文件中（pom.xml）,可以看到该项目的parent，通过点击&lt;artifactId&gt;标签，可以进入parent中，这样可以看到项目的最终的parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-启动器&#34;&gt;2.启动器&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt;
spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；
SpringBoot启动器文档：&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-主程序类&#34;&gt;3.主程序类&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;@SpringBootApplication：用来标注这个类为SpringBoot的主配置类，该注解是一个组合注解。&lt;/li&gt;
&lt;li&gt;将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；&lt;/li&gt;
&lt;li&gt;Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；
&lt;code&gt;java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
excludeFilters = {@Filter(
type = FilterType.CUSTOM,
classes = {TypeExcludeFilter.class}
), @Filter(
type = FilterType.CUSTOM,
classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
&lt;/code&gt;
* @SpringBootConfiguration: SpringBoot的配置类，
* @EnableAutoConfiguration：开启自动配置功能

参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot入门</title>
      <link>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 08 Jun 2019 10:18:29 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</guid>
      <description>

&lt;h5 id=&#34;创建工程&#34;&gt;创建工程&lt;/h5&gt;

&lt;p&gt;使用IDEA，按照提示创建即可。&lt;/p&gt;

&lt;h5 id=&#34;修改banner&#34;&gt;修改Banner&lt;/h5&gt;

&lt;p&gt;在resources目录下创建banner.txt文件，改文件用于指定banner，文字生成banner的网址：&lt;a href=&#34;http://patorjk.com/software/taag。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://patorjk.com/software/taag。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;${AnsiColor.BLUE}
.____     ____  __.
|    |   |    |/ _|
|    |   |      &amp;lt;  
|    |___|    |  \ 
|_______ \____|__ \
        \/       \/
-----版本号-----${spring-boot.version}      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：
${AnsiColor.BLUE}   表示Banner文字的颜色
${spring-boot.version}  当前使用的SpringBoot版本&lt;/p&gt;

&lt;h5 id=&#34;创建controller类&#34;&gt;创建Controller类&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HelloWorld {
    @RequestMapping(value = &amp;quot;/hello&amp;quot;,method = RequestMethod.GET)
    @ResponseBody
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问：&lt;a href=&#34;http://localhost:8080/hello，即可以看到Hello&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/hello，即可以看到Hello&lt;/a&gt; Spring Boot
&lt;strong&gt;&lt;em&gt;另外一种注解方式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class HelloWorld {
    @GetMapping(&amp;quot;/hello&amp;quot;)
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明
* @RestController：处理http请求：等同于@Controller+@ResponseBody
* @GetMapping：@RequestMapping以get请求的简写&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;url的其他形式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
public class HelloWorld {
    @GetMapping(value={&amp;quot;/hello&amp;quot;,&amp;quot;/hi&amp;quot;})
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;
文档：&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法008</title>
      <link>https://pallcard.github.io/2019/algorithm008/</link>
      <pubDate>Wed, 05 Jun 2019 20:40:17 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm008/</guid>
      <description>&lt;p&gt;public class Question008 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int [][] array = new int [m][n];
    for (int i = 0; i &amp;lt; m; i++) {
        for (int j = 0; j &amp;lt; n; j++) {
            array[i][j] = -1;
        }
    }
    int x = 0, y = 0;
    int count = 1;
    // 右1 下2 左3 上4
    int last_t = 1;
    while (count &amp;lt;= m*n) {
        array[x][y] = count++;
        if(last_t == 1) {
            if (y+1&amp;lt;n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0){
                y++;
            } else {
                last_t = 2;
                if (x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) {
                    x++;
                }else {
                    break;
                }
            }
            //下
        } else if (last_t == 2) {
            if(x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) {
                x++;
            } else {
                last_t = 3;
                if (y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) {
                    y--;
                } else {
                    break;
                }
            }
            //左
        } else if (last_t == 3) {
            if(y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) {
                y--;
            } else {
                last_t = 4;
                if (x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) {
                    x--;
                } else {
                    break;
                }
            }
        }
        //上
        else {
            if(x-1 &amp;gt;= 0  &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) {
                x--;
            } else {
                last_t = 1;
                if (y+1 &amp;lt; n  &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0) {
                    y++;
                } else {
                    break;
                }
            }
        }
    }
    for (int i = 0; i &amp;lt; m; i++) {
        for (int j = 0; j &amp;lt; n; j++) {
            System.out.print(array[i][j]+&amp;quot;\t&amp;quot;);
        }
        System.out.println();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法007</title>
      <link>https://pallcard.github.io/2019/algorithm007/</link>
      <pubDate>Wed, 05 Jun 2019 15:40:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm007/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;一个栈负责入队，另一个栈负责出队。
 *  队列push操作，直接进第一个栈
 *  队列pop操作，判断第二个栈是否为空，若空将第一个栈所有元素进栈到第二个栈中，若不为空，则第二个栈直接出栈&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question007 {
    private static Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;&amp;gt;();
    private static Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;&amp;gt;();

    public void push(Integer item){
        stack1.push(item);
    }

    public Integer pop() throws Exception {
        if(stack2.isEmpty()) {
            while (!stack1.isEmpty()){
                stack2.push(stack1.peek());
            }
        }
        if(stack2.isEmpty()) {
            throw new Exception(&amp;quot;队列为空&amp;quot;);
        }
        return stack2.peek();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法006</title>
      <link>https://pallcard.github.io/2019/algorithm006/</link>
      <pubDate>Wed, 05 Jun 2019 14:50:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm006/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	二叉树
Output:
	中序遍历顺序的下一个结点
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;中序遍历顺序的下一个结点，中序遍历是左根右，
判断该结点是否有右孩子，
 1.若有，则下一个结点的最左子结点
 2.若无，则下一个结点为第一个左链指向该结点的祖先结点的结点&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question006 {

    class TreeLinkNode {
        int val;
        TreeLinkNode left = null;
        TreeLinkNode right = null;
        TreeLinkNode next = null;

        TreeLinkNode(int val) {
            this.val = val;
        }
    }

    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        TreeLinkNode resultNode = null;
        if(null != pNode.right) {
            resultNode = pNode.right;
            while (null != resultNode.left) {
                resultNode = resultNode.next;
            }
        } else {
            TreeLinkNode temp = pNode;
            resultNode = pNode.next;
            while (null != resultNode &amp;amp;&amp;amp; resultNode.left != temp) {
                temp = pNode.next;
                resultNode = temp.next;
            }
        }
        return resultNode;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法005</title>
      <link>https://pallcard.github.io/2019/algorithm005/</link>
      <pubDate>Wed, 05 Jun 2019 10:22:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm005/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	preorder：{3,9,20,15,7}
	inorder：{9,3,15,20,7}
Output:
	该二叉树
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;根据先序遍历确定根，再通过中序遍历将数组划分为两部分，分别是左子树、右子树。
故可以通过一个HashMap存储中序遍历的数组值与下标，key为值，value为下标。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TreeNode {
    private TreeNode leftChild;
    private TreeNode rightChild;
    private int value;

    public TreeNode(int value) {
        this.value = value;
    }

    public TreeNode getLeftChild() {
        return leftChild;
    }

    public void setLeftChild(TreeNode leftChild) {
        this.leftChild = leftChild;
    }

    public TreeNode getRightChild() {
        return rightChild;
    }

    public void setRightChild(TreeNode rightChild) {
        this.rightChild = rightChild;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }
}

public class Question005 {
	//中序遍历结果，用来对二叉树进行划分，左右子树
    //为了方便快速的找出根结点对应的下标，来确定左右子树结点个数
    private static HashMap&amp;lt;Integer, Integer&amp;gt; preorderMap = new HashMap&amp;lt;&amp;gt;();
    public static void main(String[] args) {
        int [] preorder = new int[] {3,9,20,15,7};
        int [] inorder = new int[] {9,3,15,20,7};

        for (int i = 0; i &amp;lt; preorder.length; i++) {
            preorderMap.put(inorder[i],i);
        }
        TreeNode root = reConstructBinaryTree(preorder,0, preorder.length);
    }
    /**
     * pre：前序遍历数组
     * preL：二叉树起始结点下标
     * length：长度
     */
    public static TreeNode reConstructBinaryTree(int [] pre, int preL, int length) {
        if (length == 1) {
            return new TreeNode(pre[preL]);
        }
        TreeNode root = new TreeNode(pre[preL]);
        Integer index = preorderMap.get(root.getValue());
        int leftLength = index - preL;
        root.setLeftChild(reConstructBinaryTree(pre,preL+1,leftLength));
        root.setRightChild(reConstructBinaryTree(pre,index+1,length-leftLength-1));
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法004</title>
      <link>https://pallcard.github.io/2019/algorithm004/</link>
      <pubDate>Tue, 04 Jun 2019 19:45:58 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm004/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;从尾到头反过来打印出每个结点的值。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	1 -&amp;gt; 2 -&amp;gt; 3
Output:
	3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;方法一：递归调用
方法二：使用栈&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Node {
    private Node next;
    private int val;

    public Node(Node next, int val) {
        this.next = next;
        this.val = val;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public int getVal() {
        return val;
    }

    public void setVal(int val) {
        this.val = val;
    }
}

public class Question004 {
    public static void main(String[] args) {
        Node node3 = new Node(null, 3);
        Node node2 = new Node(node3, 2);
        Node node1 = new Node(node2, 1);
        Node node = node1;
		//使用栈
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        while (node != null) {
            stack.push(node.getVal());
            node = node.getNext();
        }

        while (!stack.empty()) {
            System.out.println(stack.pop());
        }
        //递归调用
//        printListFromTailToHead(node1);
    }
    public static void printListFromTailToHead(Node list) {
        if (list.getNext() != null) {
            printListFromTailToHead(list.getNext());
        }
        System.out.println(list.getVal());
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法003</title>
      <link>https://pallcard.github.io/2019/algorithm003/</link>
      <pubDate>Tue, 04 Jun 2019 19:24:08 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm003/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;将一个字符串中的空格替换成 &amp;ldquo;%20&amp;rdquo;。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	&amp;quot;A B&amp;quot;
Output:
	&amp;quot;A%20B&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于要将字符串中所用空格替换为%20，故若字符串含有一个空格，则字符串的总长度会增长2，故可以先遍历一遍字符串，若将字符串的总长度变为相应的长度，需要两个指针，分别指向原字符串长度的最后一个票p1，和新字符串的最后一个p2，若原字符串为字符，则直接赋值给p2；若原字符串为空格，则赋值%20。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question003 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder(&amp;quot;A B&amp;quot;);
        int p1 = sb.length()-1;//指向原字符串最后一个
        for (int i = 0; i &amp;lt;= p1; i++) {
            if(sb.charAt(i) == &#39; &#39;) {
                sb.append(&amp;quot;  &amp;quot;);
            }
        }
        int p2 = sb.length()-1;//指向新字符串最后一个
        while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p1 &amp;lt; p2) {
            if(sb.charAt(p1) != &#39; &#39;) {
                sb.setCharAt(p2--,sb.charAt(p1--));
            } else if(sb.charAt(p1--) == &#39; &#39;) {
                sb.setCharAt(p2--, &#39;0&#39;);
                sb.setCharAt(p2--, &#39;2&#39;);
                sb.setCharAt(p2--, &#39;%&#39;);
            }
        }
        System.out.println(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法002</title>
      <link>https://pallcard.github.io/2019/algorithm002/</link>
      <pubDate>Tue, 04 Jun 2019 16:55:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm002/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
给定一个数，判断这个数是否在该二维数组中。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	数组：
	{
	       {1,   4,  7, 11, 15},
           {2,   5,  8, 12, 19},
           {3,   6,  9, 16, 22},
           {10, 13, 14, 17, 24},
           {18, 21, 23, 26, 30},
    };
    目标值：24
Output:
	2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于每一行从左到右递增排序，从上到下也是递增排序，故可以从右上角开始遍历，若大于目标值，列减1；若小于目标值，行加1；若等于则成功找到。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question002 {
    public static void main(String[] args) {
        int target = 24;
        int [][] array = new int [][]{
                    {1,   4,  7, 11, 15},
                    {2,   5,  8, 12, 19},
                    {3,   6,  9, 16, 22},
                    {10, 13, 14, 17, 24},
                    {18, 21, 23, 26, 30},
                };
        int row = 0, col = array.length-1;
        while(row &amp;lt; array[0].length &amp;amp;&amp;amp; col &amp;gt; 0) {
            if (array[row][col] &amp;lt; target) {
                row++;
            } else if(array[row][col] &amp;gt; target){
                col--;
            } else {
                System.out.println(&amp;quot;true&amp;quot;);
                break;
            }
        }
        if (row &amp;gt;= array[0].length || col &amp;lt;= 0){
            System.out.println(&amp;quot;false&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法001</title>
      <link>https://pallcard.github.io/2019/algorithm001/</link>
      <pubDate>Tue, 04 Jun 2019 16:37:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm001/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	{2, 3, 1, 0, 2, 5}
Output:
	2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于数组中的值大小 为0 到 n-1，可以通过交换就数组中的元素放到与其下标对应的位置，若有两个数要出现在同一个位置，则找到了这个数。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question001 {
    public static void main(String[] args) {
        int[] array = new int[] {2,3,1,0,2,5};
        for (int i = 0; i &amp;lt; array.length; i++) {
            while(i != array[i]) {
                if(array[i] == array[array[i]]) {
                    System.out.println(array[i]);
                    return;
                } else {
                    swap(array,i,array[i]);
                }
            }
        }
    }

    public static void swap(int[] array, int left, int right) {
        int temp = array[left];
        array[left] = array[right];
        array[right] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
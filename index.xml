<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sat, 08 Jun 2019 17:49:19 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SpringBoot之Swagger</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</link>
      <pubDate>Sat, 08 Jun 2019 17:49:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</guid>
      <description>

&lt;h5 id=&#34;swagger框架&#34;&gt;Swagger框架&lt;/h5&gt;

&lt;p&gt;描述和测试API接口,自动生成API接口文档。&lt;/p&gt;

&lt;h6 id=&#34;1-添加依赖&#34;&gt;1.添加依赖&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--lombok依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.18.8&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;2-swagger配置&#34;&gt;2.Swagger配置&lt;/h6&gt;

&lt;p&gt;在resources目录下新建application.yml文件，添加如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;swagger:
  title: SpringBoot学习
  description: SpringBoot学习
  version: 1.0.0
  name: lk
  url: https://pallcard.github.io
  email: 1250585541@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建SwaggerConfig文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableWebMvc
@EnableSwagger2
@ConfigurationProperties(prefix = &amp;quot;swagger&amp;quot;)
@Data //lombok
@ComponentScan(basePackages = {&amp;quot;cn.wishhust.demo.controller&amp;quot;})
public class SwaggerConfig {

    private String title;
    private String description;
    private String version;

    private String name;
    private String url;
    private String email;

    @Bean
    public Docket customDocket() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
    }

    private ApiInfo apiInfo() {
        Contact contact = new Contact(name, url, email);
        return new ApiInfoBuilder()
                .title(title)
                .description(description)
                .contact(contact)
                .version(version)
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MVC配置:过滤网页静态资源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
class WebMvcConfig implements WebMvcConfigurer {

    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&amp;quot;swagger-ui.html&amp;quot;)
                .addResourceLocations(&amp;quot;classpath:/META-INF/resources/&amp;quot;);

        registry.addResourceHandler(&amp;quot;/webjars/**&amp;quot;)
                .addResourceLocations(&amp;quot;classpath:/META-INF/resources/webjars/&amp;quot;);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;3-使用&#34;&gt;3.使用&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
@Api(value = &amp;quot;测试&amp;quot;)
public class HelloWorld {

    Logger log = LoggerFactory.getLogger(HelloWorld.class);
    
    @GetMapping(value={&amp;quot;/hello&amp;quot;})
    @ApiOperation(value = &amp;quot;hello&amp;quot;)
//    @ApiImplicitParam
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot传递参数</title>
      <link>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 08 Jun 2019 17:08:34 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</guid>
      <description>

&lt;h5 id=&#34;url传参&#34;&gt;url传参&lt;/h5&gt;

&lt;h6 id=&#34;1-get方式&#34;&gt;1.get方式&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; 	// 访问：http://localhost:8080/test/get/xxx
    @GetMapping(&amp;quot;/get/{name}&amp;quot;)
    public String get(@PathVariable(&amp;quot;name&amp;quot;) String name2){
        System.out.println(&amp;quot;name: &amp;quot;+ name2);
        return &amp;quot;Hi &amp;quot;+ name2;
    }

    // 访问：http://localhost:8080/test/get2?name=yyy
    @GetMapping(&amp;quot;/get2&amp;quot;)
    // 请求参数名字与方法中的形参一致，可以省略@RequestParam
    // public String get2(String name2) {
    public String get2(@RequestParam(&amp;quot;name&amp;quot;) String name2) {
        System.out.println(&amp;quot;name: &amp;quot;+ name2);
        return &amp;quot;Hi &amp;quot;+ name2;
    }

    @GetMapping(&amp;quot;/get3&amp;quot;)
    //给一个默认值或者required = false
    public String get3(@RequestParam(value = &amp;quot;name&amp;quot;, defaultValue = &amp;quot;admin&amp;quot;) String name) {
        System.out.println(&amp;quot;name: &amp;quot;+ name);
        return &amp;quot;Hi &amp;quot;+ name;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;2-post方式&#34;&gt;2.post方式&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PostMapping(&amp;quot;/post&amp;quot;)
    //@RequestParam同get
    public String post(@RequestParam(&amp;quot;username&amp;quot;) String name, Integer age){
        log.info(&amp;quot;name=&amp;quot; + name+&amp;quot;, age=&amp;quot; + age);
        return &amp;quot;name=&amp;quot; + name+&amp;quot;, age=&amp;quot; + age;
    }
    
    @PostMapping(&amp;quot;post2&amp;quot;)
    public String post2(HttpServletRequest request) {
        ServletInputStream is = null;
        StringBuilder sb = null;
        try {
            is = request.getInputStream();
            sb = new StringBuilder();
            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = is.read(buf)) != -1){
                sb.append(new String(buf,0,len));
            }
            System.out.println(sb.toString());
            return sb.toString();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return sb.toString();
    }

    @PostMapping(&amp;quot;/post3&amp;quot;)
    public String post3(@RequestBody User user) {
        log.info(user.toString());
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
* 把json作为参数传递,要用【RequestBody】&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot启动类</title>
      <link>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jun 2019 10:53:04 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</guid>
      <description>

&lt;h5 id=&#34;1-pom文件&#34;&gt;1.POM文件&lt;/h5&gt;

&lt;p&gt;整个项目的pom文件中（pom.xml）,可以看到该项目的parent，通过点击&lt;artifactId&gt;标签，可以进入parent中，这样可以看到项目的最终的parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-启动器&#34;&gt;2.启动器&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt;
spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；
SpringBoot启动器文档：&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-主程序类&#34;&gt;3.主程序类&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;@SpringBootApplication：用来标注这个类为SpringBoot的主配置类，该注解是一个组合注解。&lt;/li&gt;
&lt;li&gt;将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；&lt;/li&gt;
&lt;li&gt;Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；
&lt;code&gt;java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
excludeFilters = {@Filter(
type = FilterType.CUSTOM,
classes = {TypeExcludeFilter.class}
), @Filter(
type = FilterType.CUSTOM,
classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
&lt;/code&gt;
* @SpringBootConfiguration: SpringBoot的配置类，
* @EnableAutoConfiguration：开启自动配置功能

参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot入门</title>
      <link>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 08 Jun 2019 10:18:29 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</guid>
      <description>

&lt;h5 id=&#34;创建工程&#34;&gt;创建工程&lt;/h5&gt;

&lt;p&gt;使用IDEA，按照提示创建即可。&lt;/p&gt;

&lt;h5 id=&#34;修改banner&#34;&gt;修改Banner&lt;/h5&gt;

&lt;p&gt;在resources目录下创建banner.txt文件，改文件用于指定banner，文字生成banner的网址：&lt;a href=&#34;http://patorjk.com/software/taag。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://patorjk.com/software/taag。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;${AnsiColor.BLUE}
.____     ____  __.
|    |   |    |/ _|
|    |   |      &amp;lt;  
|    |___|    |  \ 
|_______ \____|__ \
        \/       \/
-----版本号-----${spring-boot.version}      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：
${AnsiColor.BLUE}   表示Banner文字的颜色
${spring-boot.version}  当前使用的SpringBoot版本&lt;/p&gt;

&lt;h5 id=&#34;创建controller类&#34;&gt;创建Controller类&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HelloWorld {
    @RequestMapping(value = &amp;quot;/hello&amp;quot;,method = RequestMethod.GET)
    @ResponseBody
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问：&lt;a href=&#34;http://localhost:8080/hello，即可以看到Hello&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/hello，即可以看到Hello&lt;/a&gt; Spring Boot
&lt;strong&gt;&lt;em&gt;另外一种注解方式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class HelloWorld {
    @GetMapping(&amp;quot;/hello&amp;quot;)
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明
* @RestController：处理http请求：等同于@Controller+@ResponseBody
* @GetMapping：@RequestMapping以get请求的简写&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;url的其他形式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
public class HelloWorld {
    @GetMapping(value={&amp;quot;/hello&amp;quot;,&amp;quot;/hi&amp;quot;})
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;
文档：&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法008</title>
      <link>https://pallcard.github.io/2019/algorithm008/</link>
      <pubDate>Wed, 05 Jun 2019 20:40:17 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm008/</guid>
      <description>&lt;p&gt;public class Question008 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int [][] array = new int [m][n];
    for (int i = 0; i &amp;lt; m; i++) {
        for (int j = 0; j &amp;lt; n; j++) {
            array[i][j] = -1;
        }
    }
    int x = 0, y = 0;
    int count = 1;
    // 右1 下2 左3 上4
    int last_t = 1;
    while (count &amp;lt;= m*n) {
        array[x][y] = count++;
        if(last_t == 1) {
            if (y+1&amp;lt;n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0){
                y++;
            } else {
                last_t = 2;
                if (x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) {
                    x++;
                }else {
                    break;
                }
            }
            //下
        } else if (last_t == 2) {
            if(x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) {
                x++;
            } else {
                last_t = 3;
                if (y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) {
                    y--;
                } else {
                    break;
                }
            }
            //左
        } else if (last_t == 3) {
            if(y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) {
                y--;
            } else {
                last_t = 4;
                if (x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) {
                    x--;
                } else {
                    break;
                }
            }
        }
        //上
        else {
            if(x-1 &amp;gt;= 0  &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) {
                x--;
            } else {
                last_t = 1;
                if (y+1 &amp;lt; n  &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0) {
                    y++;
                } else {
                    break;
                }
            }
        }
    }
    for (int i = 0; i &amp;lt; m; i++) {
        for (int j = 0; j &amp;lt; n; j++) {
            System.out.print(array[i][j]+&amp;quot;\t&amp;quot;);
        }
        System.out.println();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法007</title>
      <link>https://pallcard.github.io/2019/algorithm007/</link>
      <pubDate>Wed, 05 Jun 2019 15:40:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm007/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;一个栈负责入队，另一个栈负责出队。
 *  队列push操作，直接进第一个栈
 *  队列pop操作，判断第二个栈是否为空，若空将第一个栈所有元素进栈到第二个栈中，若不为空，则第二个栈直接出栈&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question007 {
    private static Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;&amp;gt;();
    private static Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;&amp;gt;();

    public void push(Integer item){
        stack1.push(item);
    }

    public Integer pop() throws Exception {
        if(stack2.isEmpty()) {
            while (!stack1.isEmpty()){
                stack2.push(stack1.peek());
            }
        }
        if(stack2.isEmpty()) {
            throw new Exception(&amp;quot;队列为空&amp;quot;);
        }
        return stack2.peek();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法006</title>
      <link>https://pallcard.github.io/2019/algorithm006/</link>
      <pubDate>Wed, 05 Jun 2019 14:50:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm006/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	二叉树
Output:
	中序遍历顺序的下一个结点
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;中序遍历顺序的下一个结点，中序遍历是左根右，
判断该结点是否有右孩子，
 1.若有，则下一个结点的最左子结点
 2.若无，则下一个结点为第一个左链指向该结点的祖先结点的结点&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question006 {

    class TreeLinkNode {
        int val;
        TreeLinkNode left = null;
        TreeLinkNode right = null;
        TreeLinkNode next = null;

        TreeLinkNode(int val) {
            this.val = val;
        }
    }

    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        TreeLinkNode resultNode = null;
        if(null != pNode.right) {
            resultNode = pNode.right;
            while (null != resultNode.left) {
                resultNode = resultNode.next;
            }
        } else {
            TreeLinkNode temp = pNode;
            resultNode = pNode.next;
            while (null != resultNode &amp;amp;&amp;amp; resultNode.left != temp) {
                temp = pNode.next;
                resultNode = temp.next;
            }
        }
        return resultNode;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法005</title>
      <link>https://pallcard.github.io/2019/algorithm005/</link>
      <pubDate>Wed, 05 Jun 2019 10:22:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm005/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	preorder：{3,9,20,15,7}
	inorder：{9,3,15,20,7}
Output:
	该二叉树
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;根据先序遍历确定根，再通过中序遍历将数组划分为两部分，分别是左子树、右子树。
故可以通过一个HashMap存储中序遍历的数组值与下标，key为值，value为下标。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TreeNode {
    private TreeNode leftChild;
    private TreeNode rightChild;
    private int value;

    public TreeNode(int value) {
        this.value = value;
    }

    public TreeNode getLeftChild() {
        return leftChild;
    }

    public void setLeftChild(TreeNode leftChild) {
        this.leftChild = leftChild;
    }

    public TreeNode getRightChild() {
        return rightChild;
    }

    public void setRightChild(TreeNode rightChild) {
        this.rightChild = rightChild;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }
}

public class Question005 {
	//中序遍历结果，用来对二叉树进行划分，左右子树
    //为了方便快速的找出根结点对应的下标，来确定左右子树结点个数
    private static HashMap&amp;lt;Integer, Integer&amp;gt; preorderMap = new HashMap&amp;lt;&amp;gt;();
    public static void main(String[] args) {
        int [] preorder = new int[] {3,9,20,15,7};
        int [] inorder = new int[] {9,3,15,20,7};

        for (int i = 0; i &amp;lt; preorder.length; i++) {
            preorderMap.put(inorder[i],i);
        }
        TreeNode root = reConstructBinaryTree(preorder,0, preorder.length);
    }
    /**
     * pre：前序遍历数组
     * preL：二叉树起始结点下标
     * length：长度
     */
    public static TreeNode reConstructBinaryTree(int [] pre, int preL, int length) {
        if (length == 1) {
            return new TreeNode(pre[preL]);
        }
        TreeNode root = new TreeNode(pre[preL]);
        Integer index = preorderMap.get(root.getValue());
        int leftLength = index - preL;
        root.setLeftChild(reConstructBinaryTree(pre,preL+1,leftLength));
        root.setRightChild(reConstructBinaryTree(pre,index+1,length-leftLength-1));
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法004</title>
      <link>https://pallcard.github.io/2019/algorithm004/</link>
      <pubDate>Tue, 04 Jun 2019 19:45:58 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm004/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;从尾到头反过来打印出每个结点的值。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	1 -&amp;gt; 2 -&amp;gt; 3
Output:
	3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;方法一：递归调用
方法二：使用栈&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Node {
    private Node next;
    private int val;

    public Node(Node next, int val) {
        this.next = next;
        this.val = val;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public int getVal() {
        return val;
    }

    public void setVal(int val) {
        this.val = val;
    }
}

public class Question004 {
    public static void main(String[] args) {
        Node node3 = new Node(null, 3);
        Node node2 = new Node(node3, 2);
        Node node1 = new Node(node2, 1);
        Node node = node1;
		//使用栈
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        while (node != null) {
            stack.push(node.getVal());
            node = node.getNext();
        }

        while (!stack.empty()) {
            System.out.println(stack.pop());
        }
        //递归调用
//        printListFromTailToHead(node1);
    }
    public static void printListFromTailToHead(Node list) {
        if (list.getNext() != null) {
            printListFromTailToHead(list.getNext());
        }
        System.out.println(list.getVal());
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法003</title>
      <link>https://pallcard.github.io/2019/algorithm003/</link>
      <pubDate>Tue, 04 Jun 2019 19:24:08 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm003/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;将一个字符串中的空格替换成 &amp;ldquo;%20&amp;rdquo;。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	&amp;quot;A B&amp;quot;
Output:
	&amp;quot;A%20B&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于要将字符串中所用空格替换为%20，故若字符串含有一个空格，则字符串的总长度会增长2，故可以先遍历一遍字符串，若将字符串的总长度变为相应的长度，需要两个指针，分别指向原字符串长度的最后一个票p1，和新字符串的最后一个p2，若原字符串为字符，则直接赋值给p2；若原字符串为空格，则赋值%20。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question003 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder(&amp;quot;A B&amp;quot;);
        int p1 = sb.length()-1;//指向原字符串最后一个
        for (int i = 0; i &amp;lt;= p1; i++) {
            if(sb.charAt(i) == &#39; &#39;) {
                sb.append(&amp;quot;  &amp;quot;);
            }
        }
        int p2 = sb.length()-1;//指向新字符串最后一个
        while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p1 &amp;lt; p2) {
            if(sb.charAt(p1) != &#39; &#39;) {
                sb.setCharAt(p2--,sb.charAt(p1--));
            } else if(sb.charAt(p1--) == &#39; &#39;) {
                sb.setCharAt(p2--, &#39;0&#39;);
                sb.setCharAt(p2--, &#39;2&#39;);
                sb.setCharAt(p2--, &#39;%&#39;);
            }
        }
        System.out.println(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法002</title>
      <link>https://pallcard.github.io/2019/algorithm002/</link>
      <pubDate>Tue, 04 Jun 2019 16:55:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm002/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。
给定一个数，判断这个数是否在该二维数组中。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	数组：
	{
	       {1,   4,  7, 11, 15},
           {2,   5,  8, 12, 19},
           {3,   6,  9, 16, 22},
           {10, 13, 14, 17, 24},
           {18, 21, 23, 26, 30},
    };
    目标值：24
Output:
	2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于每一行从左到右递增排序，从上到下也是递增排序，故可以从右上角开始遍历，若大于目标值，列减1；若小于目标值，行加1；若等于则成功找到。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question002 {
    public static void main(String[] args) {
        int target = 24;
        int [][] array = new int [][]{
                    {1,   4,  7, 11, 15},
                    {2,   5,  8, 12, 19},
                    {3,   6,  9, 16, 22},
                    {10, 13, 14, 17, 24},
                    {18, 21, 23, 26, 30},
                };
        int row = 0, col = array.length-1;
        while(row &amp;lt; array[0].length &amp;amp;&amp;amp; col &amp;gt; 0) {
            if (array[row][col] &amp;lt; target) {
                row++;
            } else if(array[row][col] &amp;gt; target){
                col--;
            } else {
                System.out.println(&amp;quot;true&amp;quot;);
                break;
            }
        }
        if (row &amp;gt;= array[0].length || col &amp;lt;= 0){
            System.out.println(&amp;quot;false&amp;quot;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法001</title>
      <link>https://pallcard.github.io/2019/algorithm001/</link>
      <pubDate>Tue, 04 Jun 2019 16:37:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm001/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	{2, 3, 1, 0, 2, 5}
Output:
	2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于数组中的值大小 为0 到 n-1，可以通过交换就数组中的元素放到与其下标对应的位置，若有两个数要出现在同一个位置，则找到了这个数。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question001 {
    public static void main(String[] args) {
        int[] array = new int[] {2,3,1,0,2,5};
        for (int i = 0; i &amp;lt; array.length; i++) {
            while(i != array[i]) {
                if(array[i] == array[array[i]]) {
                    System.out.println(array[i]);
                    return;
                } else {
                    swap(array,i,array[i]);
                }
            }
        }
    }

    public static void swap(int[] array, int left, int right) {
        int temp = array[left];
        array[left] = array[right];
        array[right] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JMM</title>
      <link>https://pallcard.github.io/2019/jmm/</link>
      <pubDate>Sun, 02 Jun 2019 10:28:33 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm/</guid>
      <description>

&lt;h4 id=&#34;jmm&#34;&gt;JMM&lt;/h4&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。&lt;/p&gt;

&lt;h4 id=&#34;jmm模型下的线程间通信&#34;&gt;JMM模型下的线程间通信&lt;/h4&gt;

&lt;p&gt;线程和主内存之间的抽象关系图：
&lt;img src=&#34;https://pallcard.github.io/images/jmm001.png&#34; alt=&#34;线程和主内存&#34; /&gt;
线程间通信必须要经过主内存。&lt;/p&gt;

&lt;p&gt;如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：&lt;/p&gt;

&lt;p&gt;1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。&lt;/p&gt;

&lt;p&gt;2）线程B到主内存中去读取线程A之前已更新过的共享变量。
&lt;img src=&#34;https://pallcard.github.io/images/jmm002.png&#34; alt=&#34;线程通讯&#34; /&gt;
&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt; 当线程操作某个对象时，执行顺序如下：
(1) 从主存复制变量到当前工作内存 (read and load)
(2) 执行代码，改变共享变量值 (use and assign)
(3) 用工作内存数据刷新主存相关内容 (store and write)&lt;/p&gt;

&lt;h4 id=&#34;jmm解决的问题&#34;&gt;JMM解决的问题&lt;/h4&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;原子性&lt;/em&gt;&lt;/strong&gt; ：一个操作不能被打断，要么全部执行完毕，要么不执行。
基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;可见性&lt;/em&gt;&lt;/strong&gt; ：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;无论是 &lt;strong&gt;&lt;em&gt;普通变量&lt;/em&gt;&lt;/strong&gt; 还是 &lt;strong&gt;&lt;em&gt;volatile变量&lt;/em&gt;&lt;/strong&gt; 都是如此，区别在于：&lt;strong&gt;&lt;em&gt;volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新&lt;/em&gt;&lt;/strong&gt; ，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。
除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 &lt;strong&gt;&lt;em&gt;synchronized&lt;/em&gt;&lt;/strong&gt; 关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 &lt;strong&gt;&lt;em&gt;Lock接口&lt;/em&gt;&lt;/strong&gt; 的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;strong&gt;&lt;em&gt;final关键字&lt;/em&gt;&lt;/strong&gt; 的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去，那么其他线程就可以看到final变量的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有序性&lt;/em&gt;&lt;/strong&gt; ：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（&lt;strong&gt;&lt;em&gt;单线程&lt;/em&gt;&lt;/strong&gt;）程序的执行结果不会改变。&lt;/p&gt;

&lt;p&gt;happens-before原则定义如下：
1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 01 Jun 2019 20:42:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</guid>
      <description>

&lt;h4 id=&#34;题目描述&#34;&gt;题目描述&lt;/h4&gt;

&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素出现两次。找出只出现一次的元素。&lt;/p&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例&lt;/h5&gt;

&lt;p&gt;输入: [2,2,3]
输出: 3&lt;/p&gt;

&lt;h5 id=&#34;思想&#34;&gt;思想&lt;/h5&gt;

&lt;p&gt;使用按位异或。异或：如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
	int a [] = new int []{2,2,3};
	int temp = 0;
	for (int i = 0; i &amp;lt; a.length; i++) {
		temp ^= a[i];
	}
	System.out.println(temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;加强&#34;&gt;加强&lt;/h4&gt;

&lt;p&gt;上述数组中有两个数出现一次，求这两个数。&lt;/p&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例&lt;/h5&gt;

&lt;p&gt;输入: [2, 2, 6, 4, 5, 5]
输出: 4, 6&lt;/p&gt;

&lt;h5 id=&#34;思想-1&#34;&gt;思想&lt;/h5&gt;

&lt;p&gt;先将所有数按位异或，得到temp，找到temp中二进制位为1的下标，通过这个下标将所用数分为两个数组，分别异或可以得到两个值。
&lt;strong&gt;&lt;em&gt;若有两个数都只出现了一次，若将所有数进行按位异或后，所得到的数中，若按照上述划分，必然可以将这两个数分到不同的数组中&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
	int a [] = new int []{2, 2, 6, 4, 5, 5};
	int temp = 0;
	int max = 0;
	for (int i = 0; i &amp;lt; a.length; i++) {
		temp ^= a[i];
		if (max &amp;lt; a[i]) {
			max = a[i];
		}
	}

	int maxLength = Integer.toBinaryString(max).length();
	String tempString = Integer.toBinaryString(temp);
	StringBuilder sb = new StringBuilder(maxLength);
	for (int i = 0; i &amp;lt; maxLength-tempString.length(); i++) {
		sb.append(&amp;quot;0&amp;quot;);
	}
	sb.append(tempString);
	int index = sb.length() - 1;
	for (; index &amp;gt;= 0; index--) {
		if(sb.charAt(index) == &#39;1&#39;) {
			break;
		}
	}
	int temp1 = 0;
	int temp2 = 0;
	for (int i = 0; i &amp;lt; a.length; i++) {
		String aiBinary = Integer.toBinaryString(a[i]);
		if(aiBinary.length()&amp;gt;index &amp;amp;&amp;amp; aiBinary.charAt(aiBinary.length()-index-1) == &#39;1&#39;) {
			temp1 ^= a[i];
		} else {
			temp2 ^= a[i];
		}
	}
	System.out.print(temp1 + &amp;quot;, &amp;quot; + temp2);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Mysql题</title>
      <link>https://pallcard.github.io/2019/mysql%E9%A2%98/</link>
      <pubDate>Sat, 01 Jun 2019 18:52:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E9%A2%98/</guid>
      <description>

&lt;h4 id=&#34;1-左连接-右连接-内连接&#34;&gt;1.左连接、右连接、内连接&lt;/h4&gt;

&lt;h5 id=&#34;左连接&#34;&gt;左连接&lt;/h5&gt;

&lt;p&gt;以左表为基础，根据on后面的条件进行连接，若右表中无对应数据，则右表数据为NULL。&lt;/p&gt;

&lt;h5 id=&#34;右连接&#34;&gt;右连接&lt;/h5&gt;

&lt;p&gt;以右表为基础，根据on后面的条件进行连接，若左表中无对应数据，则左表数据为NULL。&lt;/p&gt;

&lt;h5 id=&#34;内连接&#34;&gt;内连接&lt;/h5&gt;

&lt;p&gt;两个表做笛卡尔积后根据on后面的条件进行筛选。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
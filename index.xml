<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sat, 20 Jul 2019 22:31:59 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>意向锁</title>
      <link>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</link>
      <pubDate>Sat, 20 Jul 2019 22:31:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</guid>
      <description>

&lt;h3 id=&#34;封锁粒度&#34;&gt;封锁粒度&lt;/h3&gt;

&lt;p&gt;一般有两种封锁粒度：&lt;strong&gt;行级锁以及表级锁&lt;/strong&gt;。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。&lt;/p&gt;

&lt;h3 id=&#34;读写锁&#34;&gt;读写锁&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;排它锁（Exclusive），简写为 X 锁，又称写锁。&lt;/li&gt;
&lt;li&gt;共享锁（Shared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
&lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;意向锁&#34;&gt;意向锁&lt;/h3&gt;

&lt;p&gt;使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。&lt;strong&gt;意向锁是一种不与行级锁冲突表级锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系(特别说明，以下是&lt;strong&gt;表锁&lt;/strong&gt;直接的兼容关系)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;IX&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;IS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意向锁不会与行级的共享 / 排他锁互斥。IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;

&lt;p&gt;用户表user：
|id| name
|&amp;mdash;|&amp;mdash;
|1|zhangsan
|2|lisi
|3|wangwu&lt;/p&gt;

&lt;p&gt;事务A，更新id为2的用户名
1. 获取user表上的IX锁；
2. 获取id=2数据行的X锁。&lt;/p&gt;

&lt;p&gt;事务B，查询user表
1. 检查到user表上用IX锁；
2. 事务B加锁请求阻塞。&lt;/p&gt;

&lt;p&gt;事务C，更新id为1的用户名
1. 获取user表的IX锁；
2. 检测到user表有IX锁；
3. 意向锁不排斥，故事务C获得IX锁；
4. id=1不存在其他行级锁，获取行级X锁。&lt;/p&gt;

&lt;p&gt;说明：若无意向锁，则对于事务B，将要查询表中的行来确定是否存在其他行级锁。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 06 Jul 2019 23:15:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</guid>
      <description>

&lt;h3 id=&#34;一-定义&#34;&gt;一、定义&lt;/h3&gt;

&lt;p&gt;反射（reflection）是java的特征之一，它允许允许中的Java程序获取自身的信息，并且可以操作累或对象的内部属性。&lt;/p&gt;

&lt;h3 id=&#34;二-基本运用&#34;&gt;二、基本运用&lt;/h3&gt;

&lt;p&gt;反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。反射相关的类一般都在 java.lang.relfect 包里。&lt;/p&gt;

&lt;h4 id=&#34;1-获取class对象&#34;&gt;1. 获取Class对象&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo01 {
    public static void main(String[] args) throws Exception{
        String str = new String();
        // 1.通过对象的getClass方法获得
        Class strClass = str.getClass();
        System.out.println(strClass.getName());

        // 2.通过class属性获得
        // 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
        Class strClass2 = String.class;
        System.out.println(strClass2.getName());
        System.out.println(strClass2 == strClass);

        // 3.使用Class类的forName静态方法
        // 注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
        try{
            Class strClass3 = Class.forName(&amp;quot;java.lang.String&amp;quot;);
            System.out.println(strClass3 == strClass2);
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));

        System.out.println(strClass instanceof Object);

    }

}

// 结果：
java.lang.String
java.lang.String
true
true
true
true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;获取Class对象的三种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用某个对象的getClass方法；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接获取某个类型的class属性：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Class类的forName静态方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：在运行期间，一个类，只有一个Class对象产生。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-判断是否为某个类的实例&#34;&gt;2. 判断是否为某个类的实例&lt;/h4&gt;

&lt;p&gt;一般使用instanceof关键字判断是否为某个类的实例，也可以使用反射中Class对象的isInstance()方法（native方法）判断是否为某个类的实例，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));
System.out.println(strClass instanceof Object);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-创建实例&#34;&gt;3. 创建实例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建实例
// 1. newInstance()
String string = (String) strClass.newInstance();
System.out.println(string);

// 2. 先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。
// 这种方法可以指定构造器的实例。
Constructor constructor = strClass.getConstructor(String.class);
String string2 = (String) constructor.newInstance(&amp;quot;23333&amp;quot;);
System.out.println(string2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Class对象的newInstance()方法来创建Class对象对应类的实例。&lt;/li&gt;
&lt;li&gt;先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-获取方法&#34;&gt;4. 获取方法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo02 {

    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; clazz = MethodClass.class;

        // 创建类实例
        Object obj = clazz.newInstance();


        // 获取所有共有方法, 包括继承
        Method[] methods = clazz.getMethods();
        for (Method m : methods) {
            System.out.println(m);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取所有私有方法，不包括继承
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for (Method dm : declaredMethods) {
            System.out.println(dm);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法
        Method add = clazz.getMethod(&amp;quot;add&amp;quot;, int.class, int.class);
        // 调用方法 （要先创建实例对象）
        Object r = add.invoke(obj, 1, 1);
        System.out.println(r);
        System.out.println(add);

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法(私有)
        Method sub = clazz.getDeclaredMethod(&amp;quot;sub&amp;quot;, int.class, int.class);
        sub.setAccessible(true);
        Object result = sub.invoke(obj,12, 2);
        System.out.println(result);

    }


}

class MethodClass {
    public int add(int a, int b) {
        return a + b;
    }
    private int sub(int a, int b){
        return a - b;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getDeclaredMethod()方法可以获取特定的私有方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethod()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>算法016</title>
      <link>https://pallcard.github.io/2019/algorithm016/</link>
      <pubDate>Sat, 06 Jul 2019 17:35:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm016/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;正则表达式匹配问题&lt;/p&gt;

&lt;p&gt;请实现一个函数用来匹配包括 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;&lt;em&gt;&amp;rsquo; 的正则表达式。模式中的字符 &amp;lsquo;.&amp;rsquo; 表示任意一个字符，而 &amp;lsquo;&lt;/em&gt;&amp;rsquo; 表示它前面的字符可以出现任意次（包含 0 次）。&lt;/p&gt;

&lt;p&gt;. 一个任意字符&lt;/p&gt;

&lt;p&gt;* 表示*前字符出现（0-？）字符&lt;/p&gt;

&lt;p&gt;aaa
ab*ac*a  a.a&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;采用两个下标，分别记录目标串与模式串。
循环模式串，若为.，则下标加1；
若为模式串与目标串字符相同，则下标加1，否则看模式串下一个字符算法为*；&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo016 {
    public static void main(String[] args) {
        String string = &amp;quot;aaa&amp;quot;;
        String pattern = &amp;quot;ab*a&amp;quot;;

        int index = 0;
        int i = 0;
        boolean result = true;

        for (i = 0; i &amp;lt; pattern.length(); i++) {
            if (index &amp;gt;= string.length()) {
                result = false;
                break;
            }
            if (pattern.charAt(i) == &#39;.&#39;) {
                index++;
                continue;
            }
            if(pattern.charAt(i) == string.charAt(index)) {
                index++;
            } else if(pattern.charAt(i+1) != &#39;*&#39;) {
                result = false;
                break;
            } else if (pattern.charAt(i+1) == &#39;*&#39;) {
                i++;
            }
        }
        if(index != string.length() || i != pattern.length()) {
            result = false;
        }
        System.out.println(result);
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法015</title>
      <link>https://pallcard.github.io/2019/algorithm015/</link>
      <pubDate>Sat, 06 Jul 2019 17:32:45 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm015/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;二进制中1的个数&lt;/p&gt;

&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;n&amp;amp;(n-1)会去除掉n的位级表示中的最低的一位&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo015 {

    public static int numberOf1(int n) {
        int count = 0;

        if (n == 0) {
            return 0;
        }

        while (n != 0) {
            count++;
            n &amp;amp;= (n-1);
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(numberOf1(10));
        System.out.println(Integer.bitCount(10));
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法014</title>
      <link>https://pallcard.github.io/2019/algorithm014/</link>
      <pubDate>Sat, 06 Jul 2019 17:24:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm014/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;剪绳子&lt;/p&gt;

&lt;p&gt;把一根绳子剪成多段（&amp;gt;1），并使得所得到每段绳子的长度之积最大。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	n(绳长)
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;方法一：
&lt;strong&gt;贪婪算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使得所得到的绳子中&lt;strong&gt;3&lt;/strong&gt;的数量最多，1的数量最少（没有）&lt;/p&gt;

&lt;p&gt;方法二：
&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义 f(n) : 最大乘积，f(n) = max{f(i)*f(n-i)}&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo014 {

    // 贪婪算法
    public static int maxLength(int n) {
        if (n &amp;lt; 2) {
            return 0;
        } else if (n == 2) {
            return 1;
        } else if (n == 3) {
            return 2;
        } else {
            if (n%3==1){
                return (int) Math.pow(3, n/3-1)*4;
            } else if(n%3==0) {
                return (int) Math.pow(3, n/3);
            } else {
                return (int) Math.pow(3, n/3)*2;
            }
        }
    }

    // 动态规划
    // 定义 f(n) : 最大乘积
    // f(n) = max{f(i)*f(n-i)}
    public static int dp(int n) {
        if (n &amp;lt; 2) {
            return 0;
        } else if (n == 2) {
            return 1;
        } else if (n == 3) {
            return 2;
        } else {
            int [] dp = new int [n+1];
            // 分割绳子长度1，2，3，具体动态规划从4开始计算
            // dp[i]数组,绳子长度为i时，乘积最大值
            dp[1] = 1;
            dp[2] = 2;
            dp[3] = 3;
            int max = 0;
            // 存放中间值
            int temp = 0;
            for (int i = 4; i &amp;lt;= n; i++) {
                max = 0;
                // i/2 对于绳子i的切分，j*(i-j) 与 (i-j)*j结果一样
                for (int j = 1; j &amp;lt;= i / 2; j++) {
                    temp = dp[j] * dp[i-j];
                    if (temp &amp;gt; max) {
                        max = temp;
                    }
                }
                dp[i] = max;
            }
            return dp[n];
        }
    }

    public static void main(String[] args) {
        System.out.println(maxLength(11));
        System.out.println(dp(11));
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 06 Jul 2019 09:10:02 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>

&lt;h3 id=&#34;一-简介&#34;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;正则表达式用于文本内容的查找和替换。在线工具&lt;a href=&#34;https://regexr.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://regexr.com/&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;回退&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;换页符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;换行符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;回车符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;制表符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直制表符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\d&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数字字符，等价于 [0-9]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\w&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\s&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;任何一个空白字符，等价于 [\f\n\r\t\v]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\l&lt;/td&gt;
&lt;td&gt;把下个字符转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\u&lt;/td&gt;
&lt;td&gt;把下个字符转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\L&lt;/td&gt;
&lt;td&gt;把\L 和\E 之间的字符全部转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\U&lt;/td&gt;
&lt;td&gt;把\U 和\E 之间的字符全部转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\E&lt;/td&gt;
&lt;td&gt;结束\L 或者\U&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明:
\D,\W,\S是对上述3个的取非；&lt;/p&gt;

&lt;h3 id=&#34;二-匹配单个字符&#34;&gt;二、匹配单个字符&lt;/h3&gt;

&lt;p&gt;.可以用来&lt;strong&gt;匹配任意单个字符&lt;/strong&gt;，但是在绝大多数实现里面，不能匹配换行符；&lt;/p&gt;

&lt;p&gt;. 是&lt;strong&gt;元字符&lt;/strong&gt;，表示它有特殊的含义，而不是字符本身的含义。若要匹配.使用\.&lt;/p&gt;

&lt;h3 id=&#34;三-匹配一组字符&#34;&gt;三、匹配一组字符&lt;/h3&gt;

&lt;p&gt;[]定义&lt;strong&gt;一个字符集合&lt;/strong&gt;；
0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。&lt;/p&gt;

&lt;p&gt;- 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；&lt;/p&gt;

&lt;p&gt;^ 在 [ ] 中是取非操作。&lt;/p&gt;

&lt;h3 id=&#34;四-重复匹配&#34;&gt;四、重复匹配&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;+ 匹配 1 个或者多个字符&lt;/li&gt;
&lt;li&gt;* 匹配 0 个或者多个&lt;/li&gt;
&lt;li&gt;? 匹配 0 个或者 1 个&lt;/li&gt;
&lt;li&gt;{n} 匹配 n 个字符&lt;/li&gt;
&lt;li&gt;{m, n} 匹配 m~n 个字符&lt;/li&gt;
&lt;li&gt;{m,} 至少匹配 m 个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
(1)    a.+c
(2)    a.+?c
target:
    abcabcabccc
第一个正则会匹配到abcabcabccc，有1个匹配
第二个正则会匹配到abc abc abc，有3个匹配
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;五-位置匹配&#34;&gt;五、位置匹配&lt;/h3&gt;

&lt;h4 id=&#34;单词边界&#34;&gt;单词边界&lt;/h4&gt;

&lt;p&gt;\b 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；\B 匹配一个不是单词边界的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    \Babc\b
target:
    aabc
    aabc1
第一个目标串可以匹配到abc
第一个目标串不能匹配
说明abc前面要有字母、数字或下划线，abc后面不能有字母、数字或下划线
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;字符串边界&#34;&gt;字符串边界&lt;/h4&gt;

&lt;p&gt;^ 匹配整个字符串的开头，$ 匹配结尾。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分行匹配模式（multiline）下，换行被当做字符串的边界。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    ^\s*\/\/.*$
target:
    // 注释
    
说明匹配代码中以 // 开始的注释行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;六-子表达式&#34;&gt;六、子表达式&lt;/h3&gt;

&lt;p&gt;使用 ( ) 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。可以嵌套。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    (ab){2,}
target:
    ababab
说明:匹配2个以上ab组成的字符串

regexr:
    (19|20)/d{2}
target:
    1900
说明：匹配19或20后面两个数的字字符串

例子：匹配IP地址
IP地址每部分都是0-255，
将其划分为一下5个部分
0-9
10-99
100-199
200-249
250-255
故0-255的正则是 ((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))

regexr:
    (((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))
target:
    1.1.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;七-回溯引用&#34;&gt;七、回溯引用&lt;/h3&gt;

&lt;p&gt;回溯引用使用 &lt;strong&gt;\n&lt;/strong&gt; (n为数字) 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    &amp;lt;(h[1-6])&amp;gt;\w*?&amp;lt;\/\1&amp;gt;
target:
    &amp;lt;h1&amp;gt;x&amp;lt;/h1&amp;gt;
说明：匹配html中标题元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;八-前后查找&#34;&gt;八、前后查找&lt;/h3&gt;

&lt;p&gt;向前查找用 ?= 来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    \w+(?=@)
target:
    abc@qq.com
说明：查找出邮件地址 @ 字符前面的部分。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;九-在java中使用&#34;&gt;九、在Java中使用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        String str = &amp;quot;&amp;lt;h1&amp;gt;test&amp;lt;/h1&amp;gt;&amp;quot;;
        boolean result = str.matches(&amp;quot;&amp;lt;(h[1-6])&amp;gt;\\w*?&amp;lt;\\/\\1&amp;gt;&amp;quot;);
        System.out.println(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法013</title>
      <link>https://pallcard.github.io/2019/algorithm013/</link>
      <pubDate>Fri, 05 Jul 2019 08:22:30 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm013/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;机器人的运动范围&lt;/p&gt;

&lt;p&gt;地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。&lt;/p&gt;

&lt;p&gt;例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	m(行数) n(列数) k(阀值)
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;先将数组中的值计算按位出来存入数组，使用深度优先遍历，将经过的格子中的值置k+1，使用count记录所有走过的格子。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo013 {

    // 左 上 右 下
    public static int [][] direct = new int [][]
            {{0,-1},{-1,0},{0,1},{1,0}};

    public static int count = 0;
    public static int m = 11;
    public static int n = 11;
    public static int k = 10;


    public static void main(String[] args) {
        int [][] array = new int[m][n];
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                int i_temp = i;
                int j_temp = j;
                // 处理数位
                int i_sum = i_temp%10;
                int j_sum = j_temp%10;

                i_temp /= 10;
                j_temp /= 10;
                while (i_temp &amp;gt; 0){
                    i_sum += i_temp%10;
                    i_temp /= 10;
                }
                while (j_temp &amp;gt; 0) {
                    j_sum += j_temp%10;
                    j_temp /= 10;
                }
                array[i][j] = i_sum+j_sum;
            }
        }
        count++;
        array[0][0] = k + 1;
        DPsearch(array,0,0);
        System.out.println(count);
    }

    public static void DPsearch(int [][] array, int x, int y) {
        for (int i = 0; i &amp;lt; 4; i++) {
            if (x + direct[i][0] &amp;gt;= 0
                    &amp;amp;&amp;amp; x + direct[i][0] &amp;lt; m
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;gt;= 0
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;lt; n) {
                x += direct[i][0];
                y += direct[i][1];

                if(array[x][y] &amp;lt;= k) {
                    // 走过的格子失效
                    array[x][y] = k + 1;
                    count++;
                    DPsearch(array,x,y);
                }

                // x,y 坐标还原
                x -= direct[i][0];
                y -= direct[i][1];
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法012</title>
      <link>https://pallcard.github.io/2019/algorithm012/</link>
      <pubDate>Thu, 04 Jul 2019 22:28:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm012/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;矩阵中的路径
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;先将所给一维数组转化为二维数组，找到目标字符串首个字符所在位置。然后进行深度递归匹配目标字符串。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo012 {

    public static void main(String[] args) {
        char[] matrix = new char[]{&#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;s&#39;, &#39;f&#39;, &#39;c&#39;, &#39;s&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;e&#39;};
        int rows = 3;
        int cols = 4;
        char [] target = new char[]{&#39;b&#39;,&#39;f&#39;,&#39;c&#39;,&#39;e&#39;};

        char[][] array = new char[3][4];
        int index = 0;
        int x = 0, y = 0;
        for (int i = 0; i &amp;lt; rows; i++) {
            for (int j = 0; j &amp;lt; cols; j++) {
                array[i][j] = matrix[index++];

            }
        }

        boolean result = false;
        for (int i = 0; i &amp;lt; rows; i++) {
            for (int j = 0; j &amp;lt; cols; j++) {
                if (array[i][j] == target[0]) {
                    result = search(array,i,j,target,1);
                    if (result) {
                        System.out.println(result);
                        return;
                    }
                }
            }
        }

        System.out.println(result);

    }
    // 左 上 右 下
    public static int [][] direct = new int [][]
            {{0,-1},{-1,0},{0,1},{1,0}};

    public static boolean search(char[][] array, int x, int y, char [] target, int index) {
        for (int i = 0; i &amp;lt; 4; i++) {
            if (x + direct[i][0] &amp;gt;= 0
                    &amp;amp;&amp;amp; x + direct[i][0] &amp;lt; 3
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;gt;= 0
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;lt; 4) {
                x += direct[i][0];
                y += direct[i][1];
                if (array[x][y] == target[index] &amp;amp;&amp;amp; target.length == index+1) {
                    return true;
                } else if (array[x][y] == target[index]) {
                    return search(array,x,y,target,++index);
                }
                // x,y 坐标还原
                x -= direct[i][0];
                y -= direct[i][1];
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法011</title>
      <link>https://pallcard.github.io/2019/algorithm011/</link>
      <pubDate>Thu, 04 Jul 2019 21:12:50 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm011/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;旋转数组(非递减)的最小数&lt;/p&gt;

&lt;p&gt;把一个数组最开始的若干位搬到数组的末尾，称为旋转数组。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;采用二分的方式来处理，&lt;/p&gt;

&lt;p&gt;正常情况&lt;/p&gt;

&lt;p&gt;4 5 6 7 1 2，分成两部分4 5 6，7 1 2；可知4 5 6为非递减数列，7 1 2为旋转数组，故结果在循环数组中，可以去掉另外一半数组；&lt;/p&gt;

&lt;p&gt;两种特殊情况：&lt;/p&gt;

&lt;p&gt;（1）1 1 1 1 0 1，num[left] == num[mid] == num[right],此时无法分区，故只能遍历&lt;/p&gt;

&lt;p&gt;（2）4 5 6 1 2 3，分区后两个部分均为非递减数组，则返回num[left]和num[mid+1]中较小的数即可。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo011 {
    public static void main(String[] args) {
        int [] arr = new int[] {1,1,1,0,1};
        System.out.println(searchMin(arr,arr.length));
    }

    public static int searchMin(int [] array, int length) {
        int left = 0, right = length - 1;
        int mid = (left + right) / 2;
        while(left &amp;lt; right) {
            // 分区间后刚好左右都为非递减数组
            if(array[left] &amp;lt; array[mid] &amp;amp;&amp;amp; array[mid+1] &amp;lt; array[right]) {
                if (array[left] &amp;gt; array[mid+1]) {
                    left = mid+1;
                }
                break;
            }
            // 无法分区间情况
            if (array[left] == array[mid] &amp;amp;&amp;amp; array[mid] == array[right]) {
                int minIndex = left;
                for (int i = left; i &amp;lt;= right; i++) {
                    if (array[minIndex] &amp;gt; array[i]) {
                        minIndex = i;
                    }
                }
                left = minIndex;
                break;
            }
            // 正常分区间
            if (array[left] &amp;lt; array[mid]) {
                // 左侧为非递减数组，右侧为旋转数组==&amp;gt;取右侧
                left = mid+1;
            } else {
                // 取左侧
                right = mid - 1;
            }
        }
        return array[left];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法010</title>
      <link>https://pallcard.github.io/2019/algorithm010/</link>
      <pubDate>Thu, 04 Jul 2019 21:08:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm010/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;变态跳青蛙&lt;/p&gt;

&lt;p&gt;青蛙可以跳1，2，3，，，n阶。问跳到n有多少种不同方法。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;f(n) = f(n-1) + f(n-2) + ,,, + f(0)

f(n-1) = f(n-2) + f(n-3) + ,,, + f(0)

==&amp;gt;  f(n) = 2 * f(n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo010 {

    public static void main(String[] args) {
        System.out.println(jumpFloor(3));
        System.out.println(jumpFloor2(3));
    }

//    f(0) = 1
//    f(1) = 1
//    f(2) = 2
//    f(3) = 4
    public static int jumpFloor(int target) {
        int [] dp = new int[target];
        Arrays.fill(dp,1);  // 数组所有元素置1（相当于所有元素+f(0)）
        for (int i = 1; i &amp;lt; target; i++) {
            for (int j = 0; j &amp;lt; i; j++) {
                dp[i] += dp[j];
            }
        }
        return dp[target-1];
    }

    public static int jumpFloor2(int target) {
        return (int) Math.pow(2, target-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法009</title>
      <link>https://pallcard.github.io/2019/algorithm009/</link>
      <pubDate>Thu, 04 Jul 2019 21:01:25 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm009/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;斐波那契数列，
*  应用1：矩形覆盖,n个2*1小矩形覆盖2*n的大矩形，有多少种方法
*  应用2：跳台阶,可以跳1列或者2列，跳n阶有多少种方法&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;f(n) = n;  n = 0,1

f(n) = f(n-1) + f(n-2); n &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法一：递归实现&lt;/p&gt;

&lt;p&gt;方法二：使用一个数组存放所用的数据&lt;/p&gt;

&lt;p&gt;方法三：发现第n项只与相邻的前两项有关，故只用存储前两项数据即可。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo009 {

    public static void main(String[] args) {
        System.out.println(fibonacci(10));
        System.out.println(fibonacci2(10));
        System.out.println(fibonacci3(10));
    }


    public static int fibonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else
            return  fibonacci(n-1) + fibonacci(n-2);
    }

//    0 1 2 3 4 5 6 7  8  9  10
//    0 1 1 2 3 5 8 13 21 34 55
    public static int fibonacci2(int n) {
        if (n &amp;lt;= 1) {
            return n;
        }
        int [] fib = new int[n+1];
        fib[0] = 0;
        fib[1] = 1;
        for (int i = 2; i &amp;lt;= n; i++) {
            fib[i] = fib[i-1] + fib[i-2];
        }
        return fib[n];
    }

    public static int fibonacci3(int n) {
        if (n &amp;lt;= 1) {
            return n;
        }
        int temp1 = 0, temp2 = 1;
        int result = 0;
        for (int i = 2; i &amp;lt;= n; i++) {
            result = temp1 + temp2;
            temp1 = temp2;
            temp2 = result;
        }
        return result;
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JMM例子</title>
      <link>https://pallcard.github.io/2019/jmm%E4%BE%8B%E5%AD%90/</link>
      <pubDate>Mon, 01 Jul 2019 22:26:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm%E4%BE%8B%E5%AD%90/</guid>
      <description>&lt;p&gt;例子1，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo001 {
    private static boolean initFlag = false;
//    private static volatile boolean initFlag = false;

    public static void main(String[] args) throws InterruptedException {
        // 线程1
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;等待数据准备&amp;quot;);
                while (!initFlag) {}
                System.out.println(&amp;quot;数据准备完毕，执行程序逻辑&amp;quot;);
            }
        }).start();

        Thread.sleep(2000);
        // 线程2
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;数据准备中。。。&amp;quot;);
                initFlag = true;
                System.out.println(&amp;quot;数据准备完成&amp;quot;);
            }
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/jmm003.png&#34; alt=&#34;initFlag无volatile关键字修饰时&#34; /&gt;&lt;/p&gt;

&lt;p&gt;initFlag无volatile关键字修饰时，线程1将initFlag从主内存读入到工作内存，线程1一直循环，线程2将initFlag从主内存读入到工作内存，并通过线程执行引擎对initFlag进行修改，然后写回到主内存中，但是线程1中的initFlag仍然是工作内存中的值，线程1无法感知到其他内存对该共享变量的修改，故会一直循环下去。&lt;strong&gt;缓存一致性问题&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;缓存一致性问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;总线加锁（性能太低）&lt;/strong&gt;
cpu从主内存读取数据到高速缓存，会在总线对该数据加锁，这样其他cpu无法读或写该数据，直到cpu使用完数据并释放锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;MESI缓存一致性协议&lt;/strong&gt;
多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存中的数据时，该数据马上同步到主内存中，其他cpu通过&lt;strong&gt;总线嗅探机制&lt;/strong&gt;感知到变化从而将自己缓存里数据失效。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Volatile缓存可见性&lt;/strong&gt;实现原理底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存并回写到主内存，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/jmm004.png&#34; alt=&#34;initFlag有volatile关键字修饰时&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例子2，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo002 {

    //volatile 不能解决原子性问题
    public static volatile int num = 0;

    public static void increase() {
        num++; // 非原子操作
    }

    public static void main(String[] args) throws InterruptedException {
        final Thread[] threads = new Thread[10];
        for (int i = 0; i &amp;lt; threads.length; i++) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j &amp;lt; 1000; j++) {
                        increase();
                    }
                }
            });
            threads[i].start();
        }
        for(Thread t : threads) {
            t.join();
        }
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/jmm005.png&#34; alt=&#34;原子性&#34; /&gt;&lt;/p&gt;

&lt;p&gt;（说明代码中存在的问题，以两个线程为例）初始时，主内存中num=0，然后线程1和2将其读到各自的工作内存中，然后在各自的执行引擎中进行num++,此时工作内存num=1，若线程1先将num写回到主内存中，线程2的cpu通过主线嗅探机制使得其工作内存中的值失效，然后从主内存中读到num=1，但是线程2已经执行了一次num++，期望的结果应该是num=2，但是实际上结果为1。&lt;strong&gt;volatile不能保证数据的原子性。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mybaits</title>
      <link>https://pallcard.github.io/2019/mybaits/</link>
      <pubDate>Thu, 20 Jun 2019 19:00:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mybaits/</guid>
      <description>

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;整个实验使用Maven 来管理项目，编译器IDEA，github仓库 &lt;a href=&#34;https://github.com/pallcard/mybatis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/pallcard/mybatis&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;jdbc连接数据库&#34;&gt;JDBC连接数据库&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;1.引入依赖（pom.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependencies&amp;gt;
	&amp;lt;dependency&amp;gt;
	    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;5.1.32&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明：（pom.xml）&lt;/strong&gt;
Maven 项目默认编译项目为JDK 1.5，通过引入以下依赖来指定Maven 编译版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;build&amp;gt;
	  &amp;lt;plugins&amp;gt;
	        &amp;lt;plugin&amp;gt;
	            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
	            &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
	            &amp;lt;configuration&amp;gt;
	                &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
	                &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
	            &amp;lt;/configuration&amp;gt;
	        &amp;lt;/plugin&amp;gt;
	  &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.JDBC测试类JDBCTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JDBCTest {
    public static void main(String[] args) throws Exception {
        Connection connection = null;
        PreparedStatement prepareStatement = null;
        ResultSet rs = null;

        try {
            // 加载驱动(每次加载驱动，驱动名硬编码)
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            // 获取连接(每次获取连接，连接信息硬编码)
            String url = &amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo&amp;quot;;
            String user = &amp;quot;root&amp;quot;;
            String password = &amp;quot;&amp;quot;;
            connection = DriverManager.getConnection(url, user, password);
            // 获取statement，preparedStatement （sql和java代码耦合）
            String sql = &amp;quot;select * from tb_user where id=?&amp;quot;;
            prepareStatement = connection.prepareStatement(sql);
            // 设置参数（参数类型手动判断、设置）
            prepareStatement.setLong(1, 1l);
            // 执行查询
            rs = prepareStatement.executeQuery();
            // 处理结果集（结果集中数据类型、下标、列名要手动判断）
            while (rs.next()) {
                System.out.println(rs.getString(&amp;quot;user_name&amp;quot;));
                System.out.println(rs.getString(&amp;quot;name&amp;quot;));
                System.out.println(rs.getInt(&amp;quot;age&amp;quot;));
                System.out.println(rs.getDate(&amp;quot;birthday&amp;quot;));
            }
        } finally {
            //（每次都要打开或关闭连接，浪费资源）
            // 关闭连接，释放资源
            if (rs != null) {
                rs.close();
            }
            if (prepareStatement != null) {
                prepareStatement.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mybaits整体架构&#34;&gt;Mybaits整体架构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190620231844983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyZmljaWFsS25vd2xlZGdl,size_16,color_FFFFFF,t_70&#34; alt=&#34;Mybaits整体架构&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;mybaits快速入门&#34;&gt;Mybaits快速入门&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.引入依赖（pom.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--mybatis--&amp;gt;
&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;3.2.8&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&amp;lt;!--引入日志依赖包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.User.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private int id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private Integer sex;
    private Date birthday;
    private String created;
    private String updated;
	// get、set、toString省
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;添加log4j.properties&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;log4j.rootLogger=DEBUG,A1
log4j.logger.org.apache=DEBUG
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.全局配置文件（mybatis-config.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;!-- 根标签 --&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo?useUnicode=true&amp;amp;amp;characterEncoding=utf-8&amp;amp;amp;allowMultiQueries=true&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;quot;/&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!-- 环境，可以配置多个，default：指定采用哪个环境 --&amp;gt;
    &amp;lt;environments default=&amp;quot;test&amp;quot;&amp;gt;
        &amp;lt;!-- id：唯一标识 --&amp;gt;
        &amp;lt;environment id=&amp;quot;test&amp;quot;&amp;gt;
            &amp;lt;!-- 事务管理器，JDBC类型的事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot; /&amp;gt;
            &amp;lt;!-- 数据源，池类型的数据源 --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo?useUnicode=true&amp;amp;amp;characterEncoding=utf-8&amp;amp;amp;allowMultiQueries=true&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;!-- 事务管理器，JDBC类型的事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot; /&amp;gt;
            &amp;lt;!-- 数据源，池类型的数据源 --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot; /&amp;gt; &amp;lt;!-- 配置了properties，所以可以直接引用 --&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.配置Map.xml（UserMapper.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mappers:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;UserMapper&amp;quot;&amp;gt;
    &amp;lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一
       resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表
     --&amp;gt;
    &amp;lt;select id=&amp;quot;selectUser&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.first.User&amp;quot;&amp;gt;
      select * from tb_user where id = #{id};
   &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.MybatisTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MybatisTest {
    public static void main(String[] args) throws Exception {
        // 指定全局配置文件
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 构建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        // 获取sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId
            // 第二个参数：指定传入sql的参数：这里是用户id
            User user = sqlSession.selectOne(&amp;quot;UserMapper.selectUser&amp;quot;, 1);
            System.out.println(user);
        } finally {
            sqlSession.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.Mybatis步骤&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1)配置mybatis-config.xml 全局的配置文件 (1、数据源，2、外部的mapper)&lt;/p&gt;

&lt;p&gt;2)创建SqlSessionFactory&lt;/p&gt;

&lt;p&gt;3)通过SqlSessionFactory创建SqlSession对象&lt;/p&gt;

&lt;p&gt;4)通过SqlSession操作数据库 CRUD&lt;/p&gt;

&lt;p&gt;5)调用session.commit()提交事务&lt;/p&gt;

&lt;p&gt;6)调用session.close()关闭会话&lt;/p&gt;

&lt;h4 id=&#34;mybatis实现crud&#34;&gt;Mybatis实现CRUD&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.UserDao接口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
    /**
     * 根据id查询用户信息
     *
     * @param id
     * @return
     */
    public User queryUserById(int id);

    /**
     * 查询所有用户信息
     *
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserAll();

    /**
     * 新增用户
     *
     * @param user
     */
    public void insertUser(User user);

    /**
     * 更新用户信息
     *
     * @param user
     */
    public void updateUser(User user);

    /**
     * 根据id删除用户信息
     *
     * @param id
     */
    public void deleteUser(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.UserDaoImpl&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {
    public SqlSession sqlSession;

    public UserDaoImpl(SqlSession sqlSession) {
        this.sqlSession = sqlSession;
    }

    @Override
    public User queryUserById(int id) {
        return this.sqlSession.selectOne(&amp;quot;UserDao.queryUserById&amp;quot;, id);
    }

    @Override
    public List&amp;lt;User&amp;gt; queryUserAll() {
        return this.sqlSession.selectList(&amp;quot;UserDao.queryUserAll&amp;quot;);
    }

    @Override
    public void insertUser(User user) {
        this.sqlSession.insert(&amp;quot;UserDao.insertUser&amp;quot;, user);
    }

    @Override
    public void updateUser(User user) {
        this.sqlSession.update(&amp;quot;UserDao.updateUser&amp;quot;, user);
    }

    @Override
    public void deleteUser(int id) {
        this.sqlSession.delete(&amp;quot;UserDao.deleteUser&amp;quot;, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.UserDaoMapper.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;UserDao&amp;quot;&amp;gt;
    &amp;lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一
       resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表
     --&amp;gt;
    &amp;lt;!--&amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;--&amp;gt;
    &amp;lt;!--select * from tb_user where id = #{id}--&amp;gt;
    &amp;lt;!--&amp;lt;/select&amp;gt;--&amp;gt;

    &amp;lt;!--使用别名--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
      select
       tuser.id as id,
       tuser.user_name as userName,
       tuser.password as password,
       tuser.name as name,
       tuser.age as age,
       tuser.birthday as birthday,
       tuser.sex as sex,
       tuser.created as created,
       tuser.updated as updated
       from
       tb_user tuser
       where tuser.id = #{id};
   &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;queryUserAll&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user;
    &amp;lt;/select&amp;gt;

    &amp;lt;!--插入数据--&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        INSERT INTO tb_user (
        user_name,
        password,
        name,
        age,
        sex,
        birthday,
        created,
        updated
        )
        VALUES
        (
        #{userName},
        #{password},
        #{name},
        #{age},
        #{sex},
        #{birthday},
        now(),
        now()
        );
    &amp;lt;/insert&amp;gt;

    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;

    &amp;lt;delete id=&amp;quot;deleteUser&amp;quot;&amp;gt;
        delete from tb_user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.mybatis-config.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserDaoMapper.xml&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.测试&lt;/strong&gt;
引入依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--junit--&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserDaoTest .java(&lt;strong&gt;测试类的生成可以在UserDao上Alt+enter，选择创建测试类&lt;/strong&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoTest {

    public UserDao userDao;
    public SqlSession sqlSession;

    @Before
    public void setUp() throws Exception {
        // mybatis-config.xml
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream is = Resources.getResourceAsStream(resource);
        // 构建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        // 获取sqlSession
        sqlSession = sqlSessionFactory.openSession();
        this.userDao = new UserDaoImpl(sqlSession);
    }

    @Test
    public void queryUserById() {
        System.out.println(this.userDao.queryUserById(1));
    }

    @Test
    public void queryUserAll() {
        List&amp;lt;User&amp;gt; userList = this.userDao.queryUserAll();
        for (User user : userList) {
            System.out.println(user);
        }
    }

    @Test
    public void insertUser() {
        User user = new User();
        user.setAge(16);
        user.setBirthday(new Date(&amp;quot;1990/09/02&amp;quot;));
        user.setName(&amp;quot;大鹏&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(1);
        user.setUserName(&amp;quot;evan&amp;quot;);
        this.userDao.insertUser(user);
        this.sqlSession.commit();

    }

    @Test
    public void updateUser() {
        User user = new User();
        user.setBirthday(new Date());
        user.setName(&amp;quot;www&amp;quot;);
        user.setPassword(&amp;quot;654321&amp;quot;);
        user.setSex(1);
        user.setUserName(&amp;quot;www&amp;quot;);
        user.setId(1);
        this.userDao.updateUser(user);
        this.sqlSession.commit();

    }

    @Test
    public void deleteUser() {
        this.userDao.deleteUser(4);
        this.sqlSession.commit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态代理mapper实现类&#34;&gt;动态代理Mapper实现类&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.UserMapper&lt;/strong&gt;（对应原UserDao）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {
    /**
     * 登录（直接使用注解指定传入参数名称）
     * @param userName
     * @param password
     * @return
     */
    public User login(@Param(&amp;quot;userName&amp;quot;) String userName, @Param(&amp;quot;password&amp;quot;) String password);

    /**
     * 根据表名查询用户信息（直接使用注解指定传入参数名称）
     * @param tableName
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserByTableName(@Param(&amp;quot;tableName&amp;quot;) String tableName);

    /**
     * 根据Id查询用户信息
     * @param id
     * @return
     */
    public User queryUserById(int id);

    /**
     * 查询所有用户信息
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserAll();

    /**
     * 新增用户信息
     * @param user
     */
    public void insertUser(User user);

    /**
     * 根据id更新用户信息
     * @param user
     */
    public void updateUser(User user);

    /**
     * 根据id删除用户信息
     * @param id
     */
    public void deleteUserById(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.UserMapper.xml&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;mapper:根标签，namespace：命名空间，为了使用接口动态代理，这里必须是接口的全路径名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 ，为了使用接口动态代理，这里必须是接口的全路径名--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.mappers.UserMapper&amp;quot;&amp;gt;
    &amp;lt;!--
       1.#{},预编译的方式preparedstatement，使用占位符替换，防止sql注入，一个参数的时候，任意参数名可以接收
       2.${},普通的Statement，字符串直接拼接，不可以防止sql注入，一个参数的时候，必须使用${value}接收参数
     --&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from ${tableName}
    &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;login&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where user_name = #{userName} and password = #{password}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- statement，内容：sql语句。
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       resultType：sql语句查询结果集的封装类型，使用动态代理之后和方法的返回类型一致；resultMap：二选一
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where id = #{id}
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserAll&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user
    &amp;lt;/select&amp;gt;
    &amp;lt;!-- 新增的Statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
       useGeneratedKeys:开启主键回写
       keyColumn：指定数据库的主键
       keyProperty：主键对应的pojo属性名
     --&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; keyColumn=&amp;quot;id&amp;quot; keyProperty=&amp;quot;id&amp;quot;
            parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        INSERT INTO tb_user (
            id,
            user_name,
            password,
            name,
            age,
            sex,
            birthday,
            created,
            updated
        )
        VALUES
        (
            null,
            #{userName},
            #{password},
            #{name},
            #{age},
            #{sex},
            #{birthday},
            NOW(),
            NOW()
        );
    &amp;lt;/insert&amp;gt;
    &amp;lt;!--
       更新的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;
    &amp;lt;!--
       删除的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;delete id=&amp;quot;deleteUserById&amp;quot; parameterType=&amp;quot;java.lang.Integer&amp;quot;&amp;gt;
        delete from tb_user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.mybatis-config.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserDaoMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper2.xml&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;a.映射文件的命名空间（namespace）必须是mapper接口的全路径&lt;/p&gt;

&lt;p&gt;b.映射文件的statement的id必须和mapper接口的方法名保持一致&lt;/p&gt;

&lt;p&gt;c.Statement的resultType必须和mapper接口方法的返回类型一致&lt;/p&gt;

&lt;p&gt;d.statement的parameterType必须和mapper接口方法的参数类型一致（不一定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserMapperTest {

    public UserMapper userMapper;

    @Before
    public void setUp() throws Exception {
        // 指定配置文件
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 构建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        // 获取sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession(true);

        // 1. 映射文件的命名空间（namespace）必须是mapper接口的全路径
        // 2. 映射文件的statement的id必须和mapper接口的方法名保持一致
        // 3. Statement的resultType必须和mapper接口方法的返回类型一致
        // 4. statement的parameterType必须和mapper接口方法的参数类型一致（不一定）
        this.userMapper = sqlSession.getMapper(UserMapper.class);

    }

    @Test
    public void login() {
        System.out.println(this.userMapper.login(&amp;quot;lk&amp;quot;, &amp;quot;123456&amp;quot;));
    }

    @Test
    public void queryUserByTableName() {
        List&amp;lt;User&amp;gt; userList = this.userMapper.queryUserByTableName(&amp;quot;tb_user&amp;quot;);
        for (User user : userList) {
            System.out.println(user);
        }
    }

    @Test
    public void queryUserById() {
        System.out.println(this.userMapper.queryUserById(1));
    }

    @Test
    public void queryUserAll() {
        List&amp;lt;User&amp;gt; userList = this.userMapper.queryUserAll();
        for (User user : userList) {
            System.out.println(user);
        }
    }
    @Test
    public void insertUser() {
        User user = new User();
        user.setAge(20);
        user.setBirthday(new Date());
        user.setName(&amp;quot;大神&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(2);
        user.setUserName(&amp;quot;bigGod222&amp;quot;);
        this.userMapper.insertUser(user);
        System.out.println(user.getId());
    }

    @Test
    public void updateUser() {
        User user = new User();
        user.setBirthday(new Date());
        user.setName(&amp;quot;静静&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(0);
        user.setUserName(&amp;quot;Jinjin&amp;quot;);
        user.setId(1);
        this.userMapper.updateUser(user);
    }

    @Test
    public void deleteUserById() {
        this.userMapper.deleteUserById(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mapper-xml文件详解&#34;&gt;Mapper XML文件详解&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.CRUD标签&lt;/strong&gt;
* select&lt;/p&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识。必须。要求id和mapper接口中的方法的名字一致。
resultType：将结果集映射为java的对象类型。必须（和 resultMap 二选一）
parameterType：传入参数类型。可以省略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
useGeneratedKeys:开启主键回写
keyColumn：指定数据库的主键
keyProperty：主键对应的pojo属性名
标签内部：具体的sql语句。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识(必须属性)；
parameterType：传入的参数类型，可以省略。
标签内部：具体的sql语句。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识(必须属性)；
parameterType：传入的参数类型，可以省略。
标签内部：具体的sql语句。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.#{}和${}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;#{} 和 ${} 在预编译中的处理是不一样的。#{} 在预处理时，会把参数部分用一个占位符 ? 代替;而 ${} 则只是简单的字符串替换.&lt;strong&gt;优先使用 #{}, ${} 会导致 sql 注入的问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：数据库有两个一模一样的表。历史表，当前表
查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据。
希望使用1个方法来完成操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;
    select * from #{tableName}
&amp;lt;/select&amp;gt;
&amp;lt;-- 相当于select * from “tb_user”;  会报错 --&amp;gt;

&amp;lt;-- 正确做法 --&amp;gt;
&amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;
    select * from ${tableName}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：
使用${} 去取出参数值信息，需要使用${value}
#{} 只是表示占位，与参数的名字无关，如果只有一个参数，会自动对应。多参数时，通常在方法的参数列表上加上一个注释@Param(“xxxx”) 显式指定参数的名字&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.sql片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;--定义--&amp;gt;
&amp;lt;sql id=””&amp;gt;&amp;lt;/sql&amp;gt;
&amp;lt;--使用--&amp;gt;
&amp;lt;include refId=”” /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态sql&#34;&gt;动态sql&lt;/h4&gt;

&lt;p&gt;动态sql有
1. if
2. choose，when，otherwise
3. where，set
4. foreach&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.if&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：查询用户，如果输入了姓名，则按姓名查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByName(@Param(&amp;quot;userName&amp;quot;) String userName);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
    &amp;lt;!--if的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByName&amp;quot;
            resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
      select * from tb_user
      &amp;lt;if test=&amp;quot;userName != null and userName.trim() != &#39;&#39;&amp;quot;&amp;gt;
          where user_name like &#39;%${userName}%&#39;
      &amp;lt;/if&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.choose，when，otherwise&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：查询用户，如果输入了姓名则按照姓名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找姓名为“ls”的用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByNameOrAge(@Param(&amp;quot;userName&amp;quot;) String userName,
                                    @Param(&amp;quot;age&amp;quot;) Integer age);
                                        
&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--choose when otherwise的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByNameOrAge&amp;quot;
            resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user WHERE
        &amp;lt;!--
        1.一旦有条件成立的when，后续的when则不会执行
        2.当所有的when都不执行时,才会执行otherwise
        --&amp;gt;
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&amp;quot;userName!=null and userName.trim()!=&#39;&#39;&amp;quot;&amp;gt;
                user_name like &#39;%${userName}%&#39;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;age!=null&amp;quot;&amp;gt;
                age = #{age}
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise&amp;gt;
                user_name = &#39;ls&#39;
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.where 和set&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景一&lt;/strong&gt;：查询所有用户，如果输入了姓名按照姓名进行模糊查询，如果输入年龄，按照年龄进行查询，如果两者都输入，两个条件都要成立。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByNameAndAge(@Param(&amp;quot;userName&amp;quot;) String userName,
                                     @Param(&amp;quot;age&amp;quot;) Integer age);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--where 和set的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByNameAndAge&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user
        &amp;lt;!--如果多出一个and，会自动去除，如果缺少and或者多出多个and则会报错--&amp;gt;
        &amp;lt;where&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null and userName.trim()!=&#39;&#39;&amp;quot;&amp;gt;
                and name like &#39;%${userName}%&#39;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;
                and age = #{age}
            &amp;lt;/if&amp;gt;
        &amp;lt;/where&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;场景二&lt;/strong&gt;：修改用户信息，如果参数user中的某个属性为null，则不修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
void updateUser(User user);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.foreach&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：按照多个id查询用户信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByIds(@Param(&amp;quot;ids&amp;quot;) int[] ids);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--foreach的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByIds&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where id in
        &amp;lt;foreach collection=&amp;quot;ids&amp;quot; item=&amp;quot;id&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
            #{id}
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;高级查询&#34;&gt;高级查询&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;一对一查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：查询订单，并查询出下单人的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Order {
    private Integer id;
    private Long userId;
    private String orderNumber;
    private Date createdTime;
    private Date updatedTime;
    private User user;
    // get,set,toString
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OrderMapper.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface OrderMapper {
	Order queryOrderWithUserByOrderNumber(@Param(&amp;quot;number&amp;quot;) String number);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OrderMapper.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!-- mappers:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.OrderMapper&amp;quot;&amp;gt;
    &amp;lt;resultMap id=&amp;quot;OrderUserResultMap&amp;quot;
               type=&amp;quot;cn.wishhust.mybatis.pojo.Order&amp;quot;
               autoMapping=&amp;quot;true&amp;quot;&amp;gt;
        &amp;lt;!--
            指定主键
            column：数据库的列名
            property：java实体类中的属性名
        --&amp;gt;
        &amp;lt;id column=&amp;quot;id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
        &amp;lt;!--association:完成子对象的映射--&amp;gt;
        &amp;lt;!--property:子对象在父对象中的属性名--&amp;gt;
        &amp;lt;!--javaType:子对象的java类型--&amp;gt;
        &amp;lt;!--autoMapping:完成子对象的自动映射，若开启驼峰，则按驼峰匹配--&amp;gt;
        &amp;lt;association property=&amp;quot;user&amp;quot;
                     javaType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;
                     autoMapping=&amp;quot;true&amp;quot;&amp;gt;
            &amp;lt;id column=&amp;quot;user_id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
        &amp;lt;/association&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;select id=&amp;quot;queryOrderWithUserByOrderNumber&amp;quot;
            resultMap=&amp;quot;OrderUserResultMap&amp;quot;&amp;gt;
      select * from tb_order o left join tb_user u
        on o.user_id=u.id
        where o.order_number = #{number}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缓存&#34;&gt;缓存&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mybatis的一级缓存的&lt;strong&gt;作用域是session&lt;/strong&gt;，当openSession()后，如果执行相同的SQL（相同语句和参数），Mybatis不进行执行SQL，而是从缓存中命中返回。原理：Mybatis执行查询时首先去缓存区命中，如果命中直接返回，没有命中则执行SQL，从数据库中查询。&lt;/p&gt;

&lt;p&gt;在mybatis中，一级缓存默认是开启的，并且一直无法关闭&lt;/p&gt;

&lt;p&gt;一级缓存满足条件：
1、同一个session中
2、相同的SQL和参数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mybatis 的二级缓存的&lt;strong&gt;作用域是一个mapper的namespace&lt;/strong&gt; ，同一个namespace中查询sql可以从缓存中命中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.UserMapper&amp;quot;&amp;gt;
    &amp;lt;cache/&amp;gt;
    ...
&amp;lt;/mapper&amp;gt;

&amp;lt;settings&amp;gt;
    &amp;lt;!--开启驼峰匹配--&amp;gt;
    &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;!--开启二级缓存,全局总开关，这里关闭，mapper中开启了也没用--&amp;gt;
    &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sql语句中出现-的解决方案&#34;&gt;sql语句中出现’&amp;lt;’的解决方案&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;转义字符&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;lt；&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;gt；&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;amp；&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;和&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;apos；&lt;/td&gt;
&lt;td&gt;&amp;lsquo;&lt;/td&gt;
&lt;td&gt;省略号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;quot；&lt;/td&gt;
&lt;td&gt;&amp;ldquo;&lt;/td&gt;
&lt;td&gt;引号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;![CDATA[ 符号 ]]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：使用&amp;lt;![CDATA[ ]]&amp;gt;标记的sql语句中的&amp;lt;where&amp;gt; &amp;lt;if&amp;gt;等标签不会被解析。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;报错1：&lt;/p&gt;

&lt;p&gt;org.apache.ibatis.binding.BindingException: Type interface cn.wishhust.mybatis.mappers.OrderMapper is not known to the MapperRegistry.&lt;/p&gt;

&lt;p&gt;原因：
xml文件的namespace的值对应的mapper接口写错了，没使用全名。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx问题</title>
      <link>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 19 Jun 2019 19:12:01 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;常用命令&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/usr/local/webserver/nginx/sbin/nginx -s reload            # 重新载入配置文件
/usr/local/webserver/nginx/sbin/nginx -s reopen            # 重启 Nginx
/usr/local/webserver/nginx/sbin/nginx -s stop              # 停止 Nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;错误信息1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后期添加配置文件后，重新运行报错，（云服务器为centos，最初按照时直接用的默认安装）&lt;/p&gt;

&lt;p&gt;错误信息：./configure: error: SSL modules require the OpenSSL library.&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 安装 
yum -y install openssl openssl-devel

yum -y install openssl openssl-devel

./configure --prefix=/usr/local/nginx --with-http_ssl_module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;错误信息2&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 防火墙问题（也可能是安全组设置的问题）

# 关闭防火墙命令：
systemctl stop firewalld.service

# 开启防火墙：
systemctl start firewalld.service

# 关闭开机自启动：
systemctl disable firewalld.service

# 开启开机启动：
systemctl enable firewalld.service

# 开放80

firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）

# 开放1000-2000

firewall-cmd --zone=public --add-port=1000-2000/tcp --permanent 

# 查看指定端口被哪个进程占用的情况

netstat -tunlp|grep 端口号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;错误信息3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;linux下启动nginx报错libpcre.so.0&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;p&gt;命令查找nginx动态关联的lib包&lt;/p&gt;

&lt;p&gt;ldd $(which /usr/local/nginx/sbin/nginx)&lt;/p&gt;

&lt;p&gt;使用关联命令，重新关联&lt;/p&gt;

&lt;p&gt;ln -s /usr/local/lib/libpcre.so.0 /lib64&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;错误信息4&lt;/strong&gt;
nginx: [error] invalid PID number ; in /usr/local/nginx/logs/nginx.pid&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步：执行命令  killall -9 nginx   杀掉nginx 进程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二步：执行命令  /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf  &lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三步：重新加载配置文件，执行命令  ./nginx -s reload &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;错误信息5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置ssl报错&lt;/p&gt;

&lt;p&gt;nginx: [emerg] unknown directive &amp;ldquo;ssl&amp;rdquo; in /usr/local/nginx/conf/nginx.conf:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 到解压的nginx目录下
./configure --with-http_ssl_module
# nginx之前添加了fastdfs-nginx-module
# ./configure --with-http_ssl_module --add-module=../fastdfs-nginx-module-master/src
make # 不能执行make install 会覆盖
# 把原来nginx备份
cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak
# 把新的nginx覆盖旧的
cp objs/nginx /usr/local/nginx/sbin/nginx
# 出现错误时cp: cannot create regular file ‘/usr/local/nginx/sbin/nginx’: Text file busy ，使用以下命令解决
# cp -rfp objs/nginx /usr/local/nginx/sbin/nginx
# 测试nginx是否正确
/usr/local/nginx/sbin/nginx -t
# 重启nginx
/usr/local/nginx/sbin/nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>FastDFS</title>
      <link>https://pallcard.github.io/2019/fastdfs/</link>
      <pubDate>Sat, 15 Jun 2019 19:43:24 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/fastdfs/</guid>
      <description>

&lt;h4 id=&#34;1-fastdfs-理论&#34;&gt;1. FastDFS 理论&lt;/h4&gt;

&lt;p&gt;FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。
FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tracker server&lt;/strong&gt;
跟踪服务器，主要做调度工作，起负载均衡的作用。负责管理所有的storage server和group，每个storage在启动后会连接tracker，告诉tracker自己所属的group，并保持周期性心跳，tracker根据storage的心跳信息，建立映射表，tracke管理的元数据很少（tracker上的元数据都是由storage汇报产生），并且直接存在内存中，本身不需要持久化任何数据。tracker之间是对等的，因此扩展tracker是很容易的，直接增加tracker服务，同时修改storage的配置，增加新增的tarcker服务的地址和端口，重启即可。所有的tracker都会接受storage的心跳信息，以生成元数据信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;storage server&lt;/strong&gt;
存储服务器（又称：存储节点或数据服务器），顾名思义是用来保存文件的和文件属性的。以group为单位，每个group内可以包含多台storage server，数据互为备份，存储容量空间以group中storage server容量最小的为准。以group为单位组织存储能够方便的进行应用隔离、负责均衡和副本数定制；确定是group的容量受单机容量的限制。group内机器故障，需要依赖group内其他机器重新同步数据来恢复数据（更换坏盘，重启fdfs_storaged即可）。storage存储依赖本地文件系统，storage课配置多个数据存储目录，磁盘不做raid，直接分别挂在到多个目录，将这些目录配置为storage的数据目录即可。&lt;/p&gt;

&lt;p&gt;storage接收写请求的时候，会根据配置好的规则，选择其中一个存储目录来存储文件；为了避免单个目录下的文件过多，storage第一次启动的时候，会在每个数据存储目录创建2级子目录，每级256，总共65536个目录，新写的文件会以hash的方式路由到其中一个子目录下，然后将文件数据直接作为一个本地文件存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client&lt;/strong&gt;
客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。
&lt;img src=&#34;https://pallcard.github.io/images/fastdfs001.png&#34; alt=&#34;文件上传&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;文件上传&#34;&gt;文件上传&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs002.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
&lt;strong&gt;生成file id&lt;/strong&gt;
选择存储目录之后，storage会生成一个file_id，采用base64编码，包含有：storage server ip，文件创建时间，文件大小，文件CRC32校验码和随机数。每个存储目录下有两个256*256个子目录，storage会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为名字存储。
文件路径如下：
group0/M00/00/00/rBAAAl0EkICAIiBOAAABowgL3Pk888.png
* 组名：group0
* 磁盘： M00
* 目录：00/00
* 文件名：rBAAAl0EkICAIiBOAAABowgL3Pk888.png&lt;/p&gt;

&lt;p&gt;文件索引信息包括：&lt;strong&gt;组名，虚拟磁盘路径，数据两级目录，文件名&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存。&lt;/li&gt;
&lt;li&gt;虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应。&lt;/li&gt;
&lt;li&gt;数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。&lt;/li&gt;
&lt;li&gt;文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;文件下载&#34;&gt;文件下载&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs003.png&#34; alt=&#34;文件下载&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-安装fastdfs环境&#34;&gt;2.安装FastDFS环境&lt;/h4&gt;

&lt;h5 id=&#34;下载安装-libfastcommon&#34;&gt;下载安装 libfastcommon&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;yum -y install libevent
# 下载libfastcommon
wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz
# 解压
tar -zxvf V1.0.7.tar.gz
# 编译、安装
cd libfastcommon-1.0.7
 ./make.sh
 ./make.sh install
 cd /usr/lib64
 ll libfast* 
 # 复制libfastcommon.so 到 usr/lib
 cp libfastcommon.so /usr/lib
 cd /usr/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;下载安装fastdfs&#34;&gt;下载安装FastDFS&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 下载FastDFS
wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz
# 解压FastDFS
tar -zxvf V5.05.tar.gz
# 编译、安装
cd fastdfs-5.05
 ./make.sh
 ./make.sh install
 
# 配置tracker
cd /usr/bin
ll fdfs*
cd /etc/fdfs/
# 进入 fastdfs-5.05/conf目录
cp * /etc/fdfs/
vim tracker.conf
# 修改 base_path=/fastdfs/tracker
cd /
mkdir /fastdfs/tracker -p
cd fastdfs/
mkdir storage
mkdir client
cd /usr/bin
fdfs_trackerd /etc/fdfs/tracker.conf
fdfs_trackerd /etc/fdfs/tracker.conf restart

# 配置storage
vim storage.conf
# 修改 base_path=/fastdfs/storage
#     store_path0=/fastdfs/storage
#     tracker_server=203.195.238.249:22122
cd /usr/bin
fdfs_storaged /etc/fdfs/storage.conf restart

# 配置client
vim client.conf
# 修改 base_path=/fastdfs/client
#     tracker_server=203.195.238.249:22122
# 测试 (先放一张图片到/root/test/headImg.jpg)
fdfs_test /etc/fdfs/client.conf upload /root/test/headImg.jpg
# 返回路径http://203.195.238.249/group1/M00/00/00/rBAAAl0EX5WAQtpGAACGZ5UrSuI275_big.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;目录结构&#34;&gt;目录结构&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;|--- /
	|---fastdfs
		|---client
		|---storage
			|---data
				|---存储的文件 256*256个目录
			|---logs
		|---tracker
			|---data
			|---logs
		|---tmp
	|---usr
		|---lib
			|---libfastcommon.so
		|---lib64
			|---libfastcommon.so
		|---bin
			|---fdfs* 命令工具
	|---etc
		|---fdfs
			|---client.conf
			|---tracker.conf
			|---storage.conf
			|---mod_fastdfs.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;安装nginx&#34;&gt;安装nginx&lt;/h5&gt;

&lt;p&gt;1.安装nginx
2.修改配置文件，加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	server  {
        listen       88;
        server_name  localhost;
       
        location /group1/M00 {
           alias /fastdfs/storage/data;
		}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.即可根据服务器的80端口访问到图片&lt;/p&gt;

&lt;h5 id=&#34;fastdfs-nginx-module&#34;&gt;fastdfs-nginx-module&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 下载
wget wget https://github.com/happyfish100/fastdfs-nginx-module/archive/5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 解压
unzip 5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 重命名
mv fastdfs-nginx-module-5e5f3566bbfa57418b5506aaefbe107a42c9fcb1  fastdfs-nginx-module-master
# 先停掉nginx服务
/usr/local/nginx/sbin/nginx -s stop
# 进入之前安装nginx的解压包的位置
cd nginx-1.14.2
# 添加fastdfs-nginx-module模块
./configure --add-module=../fastdfs-nginx-module-master/src
# 重新编译、安装
make &amp;amp;&amp;amp; make install
# 复制fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录
cp mod_fastdfs.conf /etc/fdfs
cd /etc/fdfs
mkdir /fastdfs/tmp
vim mod_fastdfs.conf
# 修改 store_path0=/fastdfs/storage
#     tracker_server=203.195.238.249:22122
#     base_path=/fastdfs/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改nginx的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	server  {
        listen       88;
        server_name  localhost;
       
        location /group1/M00 {
            ngx_fastdfs_module;
		}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;部署结构图&#34;&gt;部署结构图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs004.png&#34; alt=&#34;部署结构图&#34; /&gt;
参考：&lt;a href=&#34;https://www.cnblogs.com/chiangchou/p/fastdfs.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/chiangchou/p/fastdfs.html&lt;/a&gt;
           &lt;a href=&#34;https://www.cnblogs.com/chiangchou/p/fastdfs.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/chiangchou/p/fastdfs.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
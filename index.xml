<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Thu, 20 Jun 2019 19:00:36 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Mybaits</title>
      <link>https://pallcard.github.io/2019/mybaits/</link>
      <pubDate>Thu, 20 Jun 2019 19:00:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mybaits/</guid>
      <description>

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;整个实验使用Maven 来管理项目，编译器IDEA，github仓库 &lt;a href=&#34;https://github.com/pallcard/mybatis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/pallcard/mybatis&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;jdbc连接数据库&#34;&gt;JDBC连接数据库&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;1.引入依赖（pom.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependencies&amp;gt;
	&amp;lt;dependency&amp;gt;
	    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;5.1.32&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明：（pom.xml）&lt;/strong&gt;
Maven 项目默认编译项目为JDK 1.5，通过引入以下依赖来指定Maven 编译版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;build&amp;gt;
	  &amp;lt;plugins&amp;gt;
	        &amp;lt;plugin&amp;gt;
	            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
	            &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
	            &amp;lt;configuration&amp;gt;
	                &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
	                &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
	            &amp;lt;/configuration&amp;gt;
	        &amp;lt;/plugin&amp;gt;
	  &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.JDBC测试类JDBCTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JDBCTest {
    public static void main(String[] args) throws Exception {
        Connection connection = null;
        PreparedStatement prepareStatement = null;
        ResultSet rs = null;

        try {
            // 加载驱动(每次加载驱动，驱动名硬编码)
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            // 获取连接(每次获取连接，连接信息硬编码)
            String url = &amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo&amp;quot;;
            String user = &amp;quot;root&amp;quot;;
            String password = &amp;quot;&amp;quot;;
            connection = DriverManager.getConnection(url, user, password);
            // 获取statement，preparedStatement （sql和java代码耦合）
            String sql = &amp;quot;select * from tb_user where id=?&amp;quot;;
            prepareStatement = connection.prepareStatement(sql);
            // 设置参数（参数类型手动判断、设置）
            prepareStatement.setLong(1, 1l);
            // 执行查询
            rs = prepareStatement.executeQuery();
            // 处理结果集（结果集中数据类型、下标、列名要手动判断）
            while (rs.next()) {
                System.out.println(rs.getString(&amp;quot;user_name&amp;quot;));
                System.out.println(rs.getString(&amp;quot;name&amp;quot;));
                System.out.println(rs.getInt(&amp;quot;age&amp;quot;));
                System.out.println(rs.getDate(&amp;quot;birthday&amp;quot;));
            }
        } finally {
            //（每次都要打开或关闭连接，浪费资源）
            // 关闭连接，释放资源
            if (rs != null) {
                rs.close();
            }
            if (prepareStatement != null) {
                prepareStatement.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mybaits整体架构&#34;&gt;Mybaits整体架构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190620231844983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyZmljaWFsS25vd2xlZGdl,size_16,color_FFFFFF,t_70&#34; alt=&#34;Mybaits整体架构&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;mybaits快速入门&#34;&gt;Mybaits快速入门&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.引入依赖（pom.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--mybatis--&amp;gt;
&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;3.2.8&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&amp;lt;!--引入日志依赖包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.User.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private int id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private Integer sex;
    private Date birthday;
    private String created;
    private String updated;
	// get、set、toString省
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;添加log4j.properties&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;log4j.rootLogger=DEBUG,A1
log4j.logger.org.apache=DEBUG
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.全局配置文件（mybatis-config.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;!-- 根标签 --&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo?useUnicode=true&amp;amp;amp;characterEncoding=utf-8&amp;amp;amp;allowMultiQueries=true&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;quot;/&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!-- 环境，可以配置多个，default：指定采用哪个环境 --&amp;gt;
    &amp;lt;environments default=&amp;quot;test&amp;quot;&amp;gt;
        &amp;lt;!-- id：唯一标识 --&amp;gt;
        &amp;lt;environment id=&amp;quot;test&amp;quot;&amp;gt;
            &amp;lt;!-- 事务管理器，JDBC类型的事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot; /&amp;gt;
            &amp;lt;!-- 数据源，池类型的数据源 --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo?useUnicode=true&amp;amp;amp;characterEncoding=utf-8&amp;amp;amp;allowMultiQueries=true&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;!-- 事务管理器，JDBC类型的事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot; /&amp;gt;
            &amp;lt;!-- 数据源，池类型的数据源 --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot; /&amp;gt; &amp;lt;!-- 配置了properties，所以可以直接引用 --&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.配置Map.xml（UserMapper.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mappers:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;UserMapper&amp;quot;&amp;gt;
    &amp;lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一
       resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表
     --&amp;gt;
    &amp;lt;select id=&amp;quot;selectUser&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.first.User&amp;quot;&amp;gt;
      select * from tb_user where id = #{id};
   &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.MybatisTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MybatisTest {
    public static void main(String[] args) throws Exception {
        // 指定全局配置文件
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 构建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        // 获取sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId
            // 第二个参数：指定传入sql的参数：这里是用户id
            User user = sqlSession.selectOne(&amp;quot;UserMapper.selectUser&amp;quot;, 1);
            System.out.println(user);
        } finally {
            sqlSession.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.Mybatis步骤&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1)配置mybatis-config.xml 全局的配置文件 (1、数据源，2、外部的mapper)&lt;/p&gt;

&lt;p&gt;2)创建SqlSessionFactory&lt;/p&gt;

&lt;p&gt;3)通过SqlSessionFactory创建SqlSession对象&lt;/p&gt;

&lt;p&gt;4)通过SqlSession操作数据库 CRUD&lt;/p&gt;

&lt;p&gt;5)调用session.commit()提交事务&lt;/p&gt;

&lt;p&gt;6)调用session.close()关闭会话&lt;/p&gt;

&lt;h4 id=&#34;mybatis实现crud&#34;&gt;Mybatis实现CRUD&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.UserDao接口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
    /**
     * 根据id查询用户信息
     *
     * @param id
     * @return
     */
    public User queryUserById(int id);

    /**
     * 查询所有用户信息
     *
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserAll();

    /**
     * 新增用户
     *
     * @param user
     */
    public void insertUser(User user);

    /**
     * 更新用户信息
     *
     * @param user
     */
    public void updateUser(User user);

    /**
     * 根据id删除用户信息
     *
     * @param id
     */
    public void deleteUser(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.UserDaoImpl&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {
    public SqlSession sqlSession;

    public UserDaoImpl(SqlSession sqlSession) {
        this.sqlSession = sqlSession;
    }

    @Override
    public User queryUserById(int id) {
        return this.sqlSession.selectOne(&amp;quot;UserDao.queryUserById&amp;quot;, id);
    }

    @Override
    public List&amp;lt;User&amp;gt; queryUserAll() {
        return this.sqlSession.selectList(&amp;quot;UserDao.queryUserAll&amp;quot;);
    }

    @Override
    public void insertUser(User user) {
        this.sqlSession.insert(&amp;quot;UserDao.insertUser&amp;quot;, user);
    }

    @Override
    public void updateUser(User user) {
        this.sqlSession.update(&amp;quot;UserDao.updateUser&amp;quot;, user);
    }

    @Override
    public void deleteUser(int id) {
        this.sqlSession.delete(&amp;quot;UserDao.deleteUser&amp;quot;, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.UserDaoMapper.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;UserDao&amp;quot;&amp;gt;
    &amp;lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一
       resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表
     --&amp;gt;
    &amp;lt;!--&amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;--&amp;gt;
    &amp;lt;!--select * from tb_user where id = #{id}--&amp;gt;
    &amp;lt;!--&amp;lt;/select&amp;gt;--&amp;gt;

    &amp;lt;!--使用别名--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
      select
       tuser.id as id,
       tuser.user_name as userName,
       tuser.password as password,
       tuser.name as name,
       tuser.age as age,
       tuser.birthday as birthday,
       tuser.sex as sex,
       tuser.created as created,
       tuser.updated as updated
       from
       tb_user tuser
       where tuser.id = #{id};
   &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;queryUserAll&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user;
    &amp;lt;/select&amp;gt;

    &amp;lt;!--插入数据--&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        INSERT INTO tb_user (
        user_name,
        password,
        name,
        age,
        sex,
        birthday,
        created,
        updated
        )
        VALUES
        (
        #{userName},
        #{password},
        #{name},
        #{age},
        #{sex},
        #{birthday},
        now(),
        now()
        );
    &amp;lt;/insert&amp;gt;

    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;

    &amp;lt;delete id=&amp;quot;deleteUser&amp;quot;&amp;gt;
        delete from tb_user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.mybatis-config.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserDaoMapper.xml&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.测试&lt;/strong&gt;
引入依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--junit--&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserDaoTest .java(&lt;strong&gt;测试类的生成可以在UserDao上Alt+enter，选择创建测试类&lt;/strong&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoTest {

    public UserDao userDao;
    public SqlSession sqlSession;

    @Before
    public void setUp() throws Exception {
        // mybatis-config.xml
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream is = Resources.getResourceAsStream(resource);
        // 构建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        // 获取sqlSession
        sqlSession = sqlSessionFactory.openSession();
        this.userDao = new UserDaoImpl(sqlSession);
    }

    @Test
    public void queryUserById() {
        System.out.println(this.userDao.queryUserById(1));
    }

    @Test
    public void queryUserAll() {
        List&amp;lt;User&amp;gt; userList = this.userDao.queryUserAll();
        for (User user : userList) {
            System.out.println(user);
        }
    }

    @Test
    public void insertUser() {
        User user = new User();
        user.setAge(16);
        user.setBirthday(new Date(&amp;quot;1990/09/02&amp;quot;));
        user.setName(&amp;quot;大鹏&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(1);
        user.setUserName(&amp;quot;evan&amp;quot;);
        this.userDao.insertUser(user);
        this.sqlSession.commit();

    }

    @Test
    public void updateUser() {
        User user = new User();
        user.setBirthday(new Date());
        user.setName(&amp;quot;www&amp;quot;);
        user.setPassword(&amp;quot;654321&amp;quot;);
        user.setSex(1);
        user.setUserName(&amp;quot;www&amp;quot;);
        user.setId(1);
        this.userDao.updateUser(user);
        this.sqlSession.commit();

    }

    @Test
    public void deleteUser() {
        this.userDao.deleteUser(4);
        this.sqlSession.commit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态代理mapper实现类&#34;&gt;动态代理Mapper实现类&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.UserMapper&lt;/strong&gt;（对应原UserDao）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {
    /**
     * 登录（直接使用注解指定传入参数名称）
     * @param userName
     * @param password
     * @return
     */
    public User login(@Param(&amp;quot;userName&amp;quot;) String userName, @Param(&amp;quot;password&amp;quot;) String password);

    /**
     * 根据表名查询用户信息（直接使用注解指定传入参数名称）
     * @param tableName
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserByTableName(@Param(&amp;quot;tableName&amp;quot;) String tableName);

    /**
     * 根据Id查询用户信息
     * @param id
     * @return
     */
    public User queryUserById(int id);

    /**
     * 查询所有用户信息
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserAll();

    /**
     * 新增用户信息
     * @param user
     */
    public void insertUser(User user);

    /**
     * 根据id更新用户信息
     * @param user
     */
    public void updateUser(User user);

    /**
     * 根据id删除用户信息
     * @param id
     */
    public void deleteUserById(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.UserMapper.xml&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;mapper:根标签，namespace：命名空间，为了使用接口动态代理，这里必须是接口的全路径名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 ，为了使用接口动态代理，这里必须是接口的全路径名--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.mappers.UserMapper&amp;quot;&amp;gt;
    &amp;lt;!--
       1.#{},预编译的方式preparedstatement，使用占位符替换，防止sql注入，一个参数的时候，任意参数名可以接收
       2.${},普通的Statement，字符串直接拼接，不可以防止sql注入，一个参数的时候，必须使用${value}接收参数
     --&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from ${tableName}
    &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;login&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where user_name = #{userName} and password = #{password}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- statement，内容：sql语句。
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       resultType：sql语句查询结果集的封装类型，使用动态代理之后和方法的返回类型一致；resultMap：二选一
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where id = #{id}
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserAll&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user
    &amp;lt;/select&amp;gt;
    &amp;lt;!-- 新增的Statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
       useGeneratedKeys:开启主键回写
       keyColumn：指定数据库的主键
       keyProperty：主键对应的pojo属性名
     --&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; keyColumn=&amp;quot;id&amp;quot; keyProperty=&amp;quot;id&amp;quot;
            parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        INSERT INTO tb_user (
            id,
            user_name,
            password,
            name,
            age,
            sex,
            birthday,
            created,
            updated
        )
        VALUES
        (
            null,
            #{userName},
            #{password},
            #{name},
            #{age},
            #{sex},
            #{birthday},
            NOW(),
            NOW()
        );
    &amp;lt;/insert&amp;gt;
    &amp;lt;!--
       更新的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;
    &amp;lt;!--
       删除的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;delete id=&amp;quot;deleteUserById&amp;quot; parameterType=&amp;quot;java.lang.Integer&amp;quot;&amp;gt;
        delete from tb_user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.mybatis-config.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserDaoMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper2.xml&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;a.映射文件的命名空间（namespace）必须是mapper接口的全路径&lt;/p&gt;

&lt;p&gt;b.映射文件的statement的id必须和mapper接口的方法名保持一致&lt;/p&gt;

&lt;p&gt;c.Statement的resultType必须和mapper接口方法的返回类型一致&lt;/p&gt;

&lt;p&gt;d.statement的parameterType必须和mapper接口方法的参数类型一致（不一定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserMapperTest {

    public UserMapper userMapper;

    @Before
    public void setUp() throws Exception {
        // 指定配置文件
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 构建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        // 获取sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession(true);

        // 1. 映射文件的命名空间（namespace）必须是mapper接口的全路径
        // 2. 映射文件的statement的id必须和mapper接口的方法名保持一致
        // 3. Statement的resultType必须和mapper接口方法的返回类型一致
        // 4. statement的parameterType必须和mapper接口方法的参数类型一致（不一定）
        this.userMapper = sqlSession.getMapper(UserMapper.class);

    }

    @Test
    public void login() {
        System.out.println(this.userMapper.login(&amp;quot;lk&amp;quot;, &amp;quot;123456&amp;quot;));
    }

    @Test
    public void queryUserByTableName() {
        List&amp;lt;User&amp;gt; userList = this.userMapper.queryUserByTableName(&amp;quot;tb_user&amp;quot;);
        for (User user : userList) {
            System.out.println(user);
        }
    }

    @Test
    public void queryUserById() {
        System.out.println(this.userMapper.queryUserById(1));
    }

    @Test
    public void queryUserAll() {
        List&amp;lt;User&amp;gt; userList = this.userMapper.queryUserAll();
        for (User user : userList) {
            System.out.println(user);
        }
    }
    @Test
    public void insertUser() {
        User user = new User();
        user.setAge(20);
        user.setBirthday(new Date());
        user.setName(&amp;quot;大神&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(2);
        user.setUserName(&amp;quot;bigGod222&amp;quot;);
        this.userMapper.insertUser(user);
        System.out.println(user.getId());
    }

    @Test
    public void updateUser() {
        User user = new User();
        user.setBirthday(new Date());
        user.setName(&amp;quot;静静&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(0);
        user.setUserName(&amp;quot;Jinjin&amp;quot;);
        user.setId(1);
        this.userMapper.updateUser(user);
    }

    @Test
    public void deleteUserById() {
        this.userMapper.deleteUserById(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mapper-xml文件详解&#34;&gt;Mapper XML文件详解&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.CRUD标签&lt;/strong&gt;
* select&lt;/p&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识。必须。要求id和mapper接口中的方法的名字一致。
resultType：将结果集映射为java的对象类型。必须（和 resultMap 二选一）
parameterType：传入参数类型。可以省略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
useGeneratedKeys:开启主键回写
keyColumn：指定数据库的主键
keyProperty：主键对应的pojo属性名
标签内部：具体的sql语句。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识(必须属性)；
parameterType：传入的参数类型，可以省略。
标签内部：具体的sql语句。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识(必须属性)；
parameterType：传入的参数类型，可以省略。
标签内部：具体的sql语句。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.#{}和${}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;#{} 和 ${} 在预编译中的处理是不一样的。#{} 在预处理时，会把参数部分用一个占位符 ? 代替;而 ${} 则只是简单的字符串替换.&lt;strong&gt;优先使用 #{}, ${} 会导致 sql 注入的问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：数据库有两个一模一样的表。历史表，当前表
查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据。
希望使用1个方法来完成操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;
    select * from #{tableName}
&amp;lt;/select&amp;gt;
&amp;lt;-- 相当于select * from “tb_user”;  会报错 --&amp;gt;

&amp;lt;-- 正确做法 --&amp;gt;
&amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;
    select * from ${tableName}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：
使用${} 去取出参数值信息，需要使用${value}
#{} 只是表示占位，与参数的名字无关，如果只有一个参数，会自动对应。多参数时，通常在方法的参数列表上加上一个注释@Param(“xxxx”) 显式指定参数的名字&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.sql片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;--定义--&amp;gt;
&amp;lt;sql id=””&amp;gt;&amp;lt;/sql&amp;gt;
&amp;lt;--使用--&amp;gt;
&amp;lt;include refId=”” /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态sql&#34;&gt;动态sql&lt;/h4&gt;

&lt;p&gt;动态sql有
1. if
2. choose，when，otherwise
3. where，set
4. foreach&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.if&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：查询用户，如果输入了姓名，则按姓名查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByName(@Param(&amp;quot;userName&amp;quot;) String userName);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
    &amp;lt;!--if的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByName&amp;quot;
            resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
      select * from tb_user
      &amp;lt;if test=&amp;quot;userName != null and userName.trim() != &#39;&#39;&amp;quot;&amp;gt;
          where user_name like &#39;%${userName}%&#39;
      &amp;lt;/if&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.choose，when，otherwise&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：查询用户，如果输入了姓名则按照姓名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找姓名为“ls”的用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByNameOrAge(@Param(&amp;quot;userName&amp;quot;) String userName,
                                    @Param(&amp;quot;age&amp;quot;) Integer age);
                                        
&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--choose when otherwise的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByNameOrAge&amp;quot;
            resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user WHERE
        &amp;lt;!--
        1.一旦有条件成立的when，后续的when则不会执行
        2.当所有的when都不执行时,才会执行otherwise
        --&amp;gt;
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&amp;quot;userName!=null and userName.trim()!=&#39;&#39;&amp;quot;&amp;gt;
                user_name like &#39;%${userName}%&#39;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;age!=null&amp;quot;&amp;gt;
                age = #{age}
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise&amp;gt;
                user_name = &#39;ls&#39;
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.where 和set&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景一&lt;/strong&gt;：查询所有用户，如果输入了姓名按照姓名进行模糊查询，如果输入年龄，按照年龄进行查询，如果两者都输入，两个条件都要成立。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByNameAndAge(@Param(&amp;quot;userName&amp;quot;) String userName,
                                     @Param(&amp;quot;age&amp;quot;) Integer age);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--where 和set的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByNameAndAge&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user
        &amp;lt;!--如果多出一个and，会自动去除，如果缺少and或者多出多个and则会报错--&amp;gt;
        &amp;lt;where&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null and userName.trim()!=&#39;&#39;&amp;quot;&amp;gt;
                and name like &#39;%${userName}%&#39;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;
                and age = #{age}
            &amp;lt;/if&amp;gt;
        &amp;lt;/where&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;场景二&lt;/strong&gt;：修改用户信息，如果参数user中的某个属性为null，则不修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
void updateUser(User user);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.foreach&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：按照多个id查询用户信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByIds(@Param(&amp;quot;ids&amp;quot;) int[] ids);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--foreach的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByIds&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where id in
        &amp;lt;foreach collection=&amp;quot;ids&amp;quot; item=&amp;quot;id&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
            #{id}
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;高级查询&#34;&gt;高级查询&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;一对一查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：查询订单，并查询出下单人的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Order {
    private Integer id;
    private Long userId;
    private String orderNumber;
    private Date createdTime;
    private Date updatedTime;
    private User user;
    // get,set,toString
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OrderMapper.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface OrderMapper {
	Order queryOrderWithUserByOrderNumber(@Param(&amp;quot;number&amp;quot;) String number);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OrderMapper.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!-- mappers:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.OrderMapper&amp;quot;&amp;gt;
    &amp;lt;resultMap id=&amp;quot;OrderUserResultMap&amp;quot;
               type=&amp;quot;cn.wishhust.mybatis.pojo.Order&amp;quot;
               autoMapping=&amp;quot;true&amp;quot;&amp;gt;
        &amp;lt;!--
            指定主键
            column：数据库的列名
            property：java实体类中的属性名
        --&amp;gt;
        &amp;lt;id column=&amp;quot;id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
        &amp;lt;!--association:完成子对象的映射--&amp;gt;
        &amp;lt;!--property:子对象在父对象中的属性名--&amp;gt;
        &amp;lt;!--javaType:子对象的java类型--&amp;gt;
        &amp;lt;!--autoMapping:完成子对象的自动映射，若开启驼峰，则按驼峰匹配--&amp;gt;
        &amp;lt;association property=&amp;quot;user&amp;quot;
                     javaType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;
                     autoMapping=&amp;quot;true&amp;quot;&amp;gt;
            &amp;lt;id column=&amp;quot;user_id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
        &amp;lt;/association&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;select id=&amp;quot;queryOrderWithUserByOrderNumber&amp;quot;
            resultMap=&amp;quot;OrderUserResultMap&amp;quot;&amp;gt;
      select * from tb_order o left join tb_user u
        on o.user_id=u.id
        where o.order_number = #{number}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缓存&#34;&gt;缓存&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mybatis的一级缓存的&lt;strong&gt;作用域是session&lt;/strong&gt;，当openSession()后，如果执行相同的SQL（相同语句和参数），Mybatis不进行执行SQL，而是从缓存中命中返回。原理：Mybatis执行查询时首先去缓存区命中，如果命中直接返回，没有命中则执行SQL，从数据库中查询。&lt;/p&gt;

&lt;p&gt;在mybatis中，一级缓存默认是开启的，并且一直无法关闭&lt;/p&gt;

&lt;p&gt;一级缓存满足条件：
1、同一个session中
2、相同的SQL和参数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mybatis 的二级缓存的&lt;strong&gt;作用域是一个mapper的namespace&lt;/strong&gt; ，同一个namespace中查询sql可以从缓存中命中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.UserMapper&amp;quot;&amp;gt;
    &amp;lt;cache/&amp;gt;
    ...
&amp;lt;/mapper&amp;gt;

&amp;lt;settings&amp;gt;
    &amp;lt;!--开启驼峰匹配--&amp;gt;
    &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;!--开启二级缓存,全局总开关，这里关闭，mapper中开启了也没用--&amp;gt;
    &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sql语句中出现-的解决方案&#34;&gt;sql语句中出现’&amp;lt;’的解决方案&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;| 转义字符 | 字符 |说明|
|&amp;ndash;|&amp;ndash;|&amp;ndash;|
| &amp;amp;lt； | &amp;lt; | 小于 |
| &amp;amp;gt； | &amp;gt; | 小于 |
| &amp;amp;amp； | &amp;amp; | 和 |
| &amp;amp;apos； | &amp;lsquo; | 省略号 |
| &amp;amp;quot； | &amp;ldquo; | 引号 |&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;![CDATA[ 符号 ]]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：使用&amp;lt;![CDATA[ ]]&amp;gt;标记的sql语句中的&amp;lt;where&amp;gt; &amp;lt;if&amp;gt;等标签不会被解析。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;报错1：&lt;/p&gt;

&lt;p&gt;org.apache.ibatis.binding.BindingException: Type interface cn.wishhust.mybatis.mappers.OrderMapper is not known to the MapperRegistry.&lt;/p&gt;

&lt;p&gt;原因：
xml文件的namespace的值对应的mapper接口写错了，没使用全名。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx问题</title>
      <link>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 19 Jun 2019 19:12:01 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;常用命令&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/usr/local/webserver/nginx/sbin/nginx -s reload            # 重新载入配置文件
/usr/local/webserver/nginx/sbin/nginx -s reopen            # 重启 Nginx
/usr/local/webserver/nginx/sbin/nginx -s stop              # 停止 Nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;错误信息1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后期添加配置文件后，重新运行报错，（云服务器为centos，最初按照时直接用的默认安装）&lt;/p&gt;

&lt;p&gt;错误信息：./configure: error: SSL modules require the OpenSSL library.&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 安装 
yum -y install openssl openssl-devel

yum -y install openssl openssl-devel

./configure --prefix=/usr/local/nginx --with-http_ssl_module
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;错误信息2&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 防火墙问题（也可能是安全组设置的问题）

# 关闭防火墙命令：
systemctl stop firewalld.service

# 开启防火墙：
systemctl start firewalld.service

# 关闭开机自启动：
systemctl disable firewalld.service

# 开启开机启动：
systemctl enable firewalld.service

# 开放80

firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）

# 开放1000-2000

firewall-cmd --zone=public --add-port=1000-2000/tcp --permanent 

# 查看指定端口被哪个进程占用的情况

netstat -tunlp|grep 端口号
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;错误信息3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;linux下启动nginx报错libpcre.so.0&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;p&gt;命令查找nginx动态关联的lib包&lt;/p&gt;

&lt;p&gt;ldd $(which /usr/local/nginx/sbin/nginx)&lt;/p&gt;

&lt;p&gt;使用关联命令，重新关联&lt;/p&gt;

&lt;p&gt;ln -s /usr/local/lib/libpcre.so.0 /lib64&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;错误信息4&lt;/strong&gt;
nginx: [error] invalid PID number ; in /usr/local/nginx/logs/nginx.pid&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步：执行命令  killall -9 nginx   杀掉nginx 进程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二步：执行命令  /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf  &lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三步：重新加载配置文件，执行命令  ./nginx -s reload &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;错误信息5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置ssl报错&lt;/p&gt;

&lt;p&gt;nginx: [emerg] unknown directive &amp;ldquo;ssl&amp;rdquo; in /usr/local/nginx/conf/nginx.conf:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 到解压的nginx目录下
./configure --with-http_ssl_module
# nginx之前添加了fastdfs-nginx-module
# ./configure --with-http_ssl_module --add-module=../fastdfs-nginx-module-master/src
make # 不能执行make install 会覆盖
# 把原来nginx备份
cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak
# 把新的nginx覆盖旧的
cp objs/nginx /usr/local/nginx/sbin/nginx
# 出现错误时cp: cannot create regular file ‘/usr/local/nginx/sbin/nginx’: Text file busy ，使用以下命令解决
# cp -rfp objs/nginx /usr/local/nginx/sbin/nginx
# 测试nginx是否正确
/usr/local/nginx/sbin/nginx -t
# 重启nginx
/usr/local/nginx/sbin/nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>FastDFS</title>
      <link>https://pallcard.github.io/2019/fastdfs/</link>
      <pubDate>Sat, 15 Jun 2019 19:43:24 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/fastdfs/</guid>
      <description>

&lt;h4 id=&#34;1-fastdfs-理论&#34;&gt;1. FastDFS 理论&lt;/h4&gt;

&lt;p&gt;FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。
FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tracker server&lt;/strong&gt;
跟踪服务器，主要做调度工作，起负载均衡的作用。负责管理所有的storage server和group，每个storage在启动后会连接tracker，告诉tracker自己所属的group，并保持周期性心跳，tracker根据storage的心跳信息，建立映射表，tracke管理的元数据很少（tracker上的元数据都是由storage汇报产生），并且直接存在内存中，本身不需要持久化任何数据。tracker之间是对等的，因此扩展tracker是很容易的，直接增加tracker服务，同时修改storage的配置，增加新增的tarcker服务的地址和端口，重启即可。所有的tracker都会接受storage的心跳信息，以生成元数据信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;storage server&lt;/strong&gt;
存储服务器（又称：存储节点或数据服务器），顾名思义是用来保存文件的和文件属性的。以group为单位，每个group内可以包含多台storage server，数据互为备份，存储容量空间以group中storage server容量最小的为准。以group为单位组织存储能够方便的进行应用隔离、负责均衡和副本数定制；确定是group的容量受单机容量的限制。group内机器故障，需要依赖group内其他机器重新同步数据来恢复数据（更换坏盘，重启fdfs_storaged即可）。storage存储依赖本地文件系统，storage课配置多个数据存储目录，磁盘不做raid，直接分别挂在到多个目录，将这些目录配置为storage的数据目录即可。&lt;/p&gt;

&lt;p&gt;storage接收写请求的时候，会根据配置好的规则，选择其中一个存储目录来存储文件；为了避免单个目录下的文件过多，storage第一次启动的时候，会在每个数据存储目录创建2级子目录，每级256，总共65536个目录，新写的文件会以hash的方式路由到其中一个子目录下，然后将文件数据直接作为一个本地文件存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client&lt;/strong&gt;
客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。
&lt;img src=&#34;https://pallcard.github.io/images/fastdfs001.png&#34; alt=&#34;文件上传&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;文件上传&#34;&gt;文件上传&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs002.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
&lt;strong&gt;生成file id&lt;/strong&gt;
选择存储目录之后，storage会生成一个file_id，采用base64编码，包含有：storage server ip，文件创建时间，文件大小，文件CRC32校验码和随机数。每个存储目录下有两个256*256个子目录，storage会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为名字存储。
文件路径如下：
group0/M00/00/00/rBAAAl0EkICAIiBOAAABowgL3Pk888.png
* 组名：group0
* 磁盘： M00
* 目录：00/00
* 文件名：rBAAAl0EkICAIiBOAAABowgL3Pk888.png&lt;/p&gt;

&lt;p&gt;文件索引信息包括：&lt;strong&gt;组名，虚拟磁盘路径，数据两级目录，文件名&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存。&lt;/li&gt;
&lt;li&gt;虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应。&lt;/li&gt;
&lt;li&gt;数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。&lt;/li&gt;
&lt;li&gt;文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;文件下载&#34;&gt;文件下载&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs003.png&#34; alt=&#34;文件下载&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-安装fastdfs环境&#34;&gt;2.安装FastDFS环境&lt;/h4&gt;

&lt;h5 id=&#34;下载安装-libfastcommon&#34;&gt;下载安装 libfastcommon&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;yum -y install libevent
# 下载libfastcommon
wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz
# 解压
tar -zxvf V1.0.7.tar.gz
# 编译、安装
cd libfastcommon-1.0.7
 ./make.sh
 ./make.sh install
 cd /usr/lib64
 ll libfast* 
 # 复制libfastcommon.so 到 usr/lib
 cp libfastcommon.so /usr/lib
 cd /usr/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;下载安装fastdfs&#34;&gt;下载安装FastDFS&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 下载FastDFS
wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz
# 解压FastDFS
tar -zxvf V5.05.tar.gz
# 编译、安装
cd fastdfs-5.05
 ./make.sh
 ./make.sh install
 
# 配置tracker
cd /usr/bin
ll fdfs*
cd /etc/fdfs/
# 进入 fastdfs-5.05/conf目录
cp * /etc/fdfs/
vim tracker.conf
# 修改 base_path=/fastdfs/tracker
cd /
mkdir /fastdfs/tracker -p
cd fastdfs/
mkdir storage
mkdir client
cd /usr/bin
fdfs_trackerd /etc/fdfs/tracker.conf
fdfs_trackerd /etc/fdfs/tracker.conf restart

# 配置storage
vim storage.conf
# 修改 base_path=/fastdfs/storage
#     store_path0=/fastdfs/storage
#     tracker_server=203.195.238.249:22122
cd /usr/bin
fdfs_storaged /etc/fdfs/storage.conf restart

# 配置client
vim client.conf
# 修改 base_path=/fastdfs/client
#     tracker_server=203.195.238.249:22122
# 测试 (先放一张图片到/root/test/headImg.jpg)
fdfs_test /etc/fdfs/client.conf upload /root/test/headImg.jpg
# 返回路径http://203.195.238.249/group1/M00/00/00/rBAAAl0EX5WAQtpGAACGZ5UrSuI275_big.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;目录结构&#34;&gt;目录结构&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;|--- /
	|---fastdfs
		|---client
		|---storage
			|---data
				|---存储的文件 256*256个目录
			|---logs
		|---tracker
			|---data
			|---logs
		|---tmp
	|---usr
		|---lib
			|---libfastcommon.so
		|---lib64
			|---libfastcommon.so
		|---bin
			|---fdfs* 命令工具
	|---etc
		|---fdfs
			|---client.conf
			|---tracker.conf
			|---storage.conf
			|---mod_fastdfs.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;安装nginx&#34;&gt;安装nginx&lt;/h5&gt;

&lt;p&gt;1.安装nginx
2.修改配置文件，加入如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	server  {
        listen       88;
        server_name  localhost;
       
        location /group1/M00 {
           alias /fastdfs/storage/data;
		}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.即可根据服务器的80端口访问到图片&lt;/p&gt;

&lt;h5 id=&#34;fastdfs-nginx-module&#34;&gt;fastdfs-nginx-module&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 下载
wget wget https://github.com/happyfish100/fastdfs-nginx-module/archive/5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 解压
unzip 5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 重命名
mv fastdfs-nginx-module-5e5f3566bbfa57418b5506aaefbe107a42c9fcb1  fastdfs-nginx-module-master
# 先停掉nginx服务
/usr/local/nginx/sbin/nginx -s stop
# 进入之前安装nginx的解压包的位置
cd nginx-1.14.2
# 添加fastdfs-nginx-module模块
./configure --add-module=../fastdfs-nginx-module-master/src
# 重新编译、安装
make &amp;amp;&amp;amp; make install
# 复制fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录
cp mod_fastdfs.conf /etc/fdfs
cd /etc/fdfs
mkdir /fastdfs/tmp
vim mod_fastdfs.conf
# 修改 store_path0=/fastdfs/storage
#     tracker_server=203.195.238.249:22122
#     base_path=/fastdfs/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改nginx的配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	server  {
        listen       88;
        server_name  localhost;
       
        location /group1/M00 {
            ngx_fastdfs_module;
		}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;部署结构图&#34;&gt;部署结构图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/fastdfs004.png&#34; alt=&#34;部署结构图&#34; /&gt;
参考：&lt;a href=&#34;https://www.cnblogs.com/chiangchou/p/fastdfs.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/chiangchou/p/fastdfs.html&lt;/a&gt;
           &lt;a href=&#34;https://www.cnblogs.com/chiangchou/p/fastdfs.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/chiangchou/p/fastdfs.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>初试部署项目到腾讯云（环境的安装）</title>
      <link>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 15 Jun 2019 19:32:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h4 id=&#34;linux常用命令&#34;&gt;linux常用命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ls：查看该目录下文件&lt;/li&gt;
&lt;li&gt;pwd：查看文件目录&lt;/li&gt;
&lt;li&gt;rm -f 文件名：删除文件&lt;/li&gt;
&lt;li&gt;/usr/local/mysql/bin/mysql -u root -p 登录mysql&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;第一步-jdk的安装&#34;&gt;第一步：jdk的安装&lt;/h4&gt;

&lt;p&gt;下载jdk后，解压报错（原因是选择接受协议的问题），输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wget --no-check-certificate --no-cookies --header &amp;quot;Cookie: oraclelicense=accept-securebackup-cookie&amp;quot; https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压jdk压缩包，使用命令 tar -zxvf 文件名&lt;/p&gt;

&lt;p&gt;然后配置环境变量，主要编辑以下两个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;vi /etc/environment 
vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后使用java -version查看版本信息&lt;/p&gt;

&lt;h4 id=&#34;第二步-mysql的安装&#34;&gt;第二步：mysql的安装&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.下载mysql ，以5.7为例&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;sudo wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz
# 解压  
tar -zxvf mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.移动 文件到 /usr/local/&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;重命名 mv 文件名 mysql&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.新建data目录 mkdir data&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.新建mysql用户、mysql用户组&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mysql用户组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;groupadd mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;mysql用户&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;useradd mysql -g mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;5.将/usr/local/mysql的所有者及所属组改为mysql&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;chown -R mysql.mysql /usr/local/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;6.配置，初始化&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后出错，libnuma原因，执行如下命令，后再初始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;yum install -y numactl
vim /etc/my.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;my.cnf中改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[mysqld]
datadir=/usr/local/mysql/data
basedir=/usr/local/mysql
socket=/tmp/mysql.sock
user=mysql
port=3306
character-set-server=utf8
# 取消密码验证
skip-grant-tables
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
# skip-grant-tables
[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;7.开启服务&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;将mysql加入服务
cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql
# 开机自启
chkconfig mysql on
# 开启
service mysql start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;8.设置密码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 登录（由于/etc/my.cnf中设置了取消密码验证，所以此处密码任意）

/usr/local/mysql/bin/mysql -u root -p

# 操作mysql数据库

&amp;gt;&amp;gt;use mysql;

# 修改密码

&amp;gt;&amp;gt;update user set authentication_string=password(&#39;你的密码&#39;) where user=&#39;root&#39;;

&amp;gt;&amp;gt;flush privileges;

&amp;gt;&amp;gt;exit;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;9.将/etc/my.cnf中的skip-grant-tables删除，至此mysql安装完成&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注: mysql 远程连接问题&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;use mysql

select host,user from user;

update user set host=&#39;%&#39; where user =&amp;quot;root&amp;quot;;

# 刷新权限
flush privileges;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;第三步-redis的安装&#34;&gt;第三步：redis的安装&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.下载 解压&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wget http://download.redis.io/releases/redis-4.0.10.tar.gz

tar -xzf redis-4.0.10.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.编译&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cd redis-4.0.10
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：若执行make出错，可能是c++未装，使用命令 yum -y install gcc-c++&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.配置远程访问&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进入redis目录，vi redis.conf 修改配置文件&lt;/p&gt;

&lt;p&gt;注释绑定的本机地址
​​&lt;img src=&#34;https://pallcard.github.io/images/linux001.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
设置redis-service为后台服务
将&amp;rdquo;daemonize no&amp;rdquo;改为&amp;rdquo;daemonize yes&amp;rdquo;
​​​​​​​​&lt;img src=&#34;https://pallcard.github.io/images/linux002.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;
设置redis-cli连接redis服务器的密码
&lt;img src=&#34;https://pallcard.github.io/images/linux003.png&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 启动redis（进入redis目录）
./src/redis-server redis.conf
# 查看进程
ps -ef | grep redis
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;第四步-nginx的安装&#34;&gt;第四步：nginx的安装&lt;/h5&gt;

&lt;p&gt;准备(安装pcre和zlib最新版本):&lt;/p&gt;

&lt;p&gt;1.pcre:&lt;a href=&#34;https://ftp.pcre.org/pub/pcre/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://ftp.pcre.org/pub/pcre/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.zlib:&lt;a href=&#34;http://www.zlib.net/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.zlib.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.nginx：&lt;a href=&#34;https://nginx.org/en/download.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://nginx.org/en/download.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;wget 下载地址
tar -xvzf 文件名
cd 文件目录
./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：在阿里云添加安全组规则&lt;/p&gt;

&lt;p&gt;参考博客：&lt;/p&gt;

&lt;p&gt;主要参考：&lt;a href=&#34;https://www.jianshu.com/p/9cac6c9df0e0&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.jianshu.com/p/9cac6c9df0e0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;mysql：&lt;a href=&#34;https://www.cnblogs.com/hl15/p/9541479.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/hl15/p/9541479.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;redis：&lt;a href=&#34;https://www.cnblogs.com/wangchunniu1314/p/6339416.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/wangchunniu1314/p/6339416.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;make出错：&lt;a href=&#34;https://blog.csdn.net/weixin_40493969/article/details/81150469&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/weixin_40493969/article/details/81150469&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot之配置文件</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 08 Jun 2019 20:21:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>

&lt;h5 id=&#34;1-配置文件基本使用&#34;&gt;1.配置文件基本使用&lt;/h5&gt;

&lt;p&gt;使用.yml配置文件，在resources目录下新建application.yml文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;server:
  port: 8081 #修改端口号
  servlet:
    context-path: /lk  #端口号后需额外添加字符
#以上等同于application.properties的以下写法
#server.port=8081
#server.servlet.context-path=/zed

swagger:
  title: SpringBoot学习
  description: SpringBoot学习
  version: 1.0.0
  name: lk
  url: https://pallcard.github.io
  email: 1250585541@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;其中空格有严格的要求&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;2-切换配置文件&#34;&gt;2.切换配置文件&lt;/h5&gt;

&lt;p&gt;在resources目录下新建application-dev.yml文件，application-prod.yml文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//文件目录
resources|-
         application.yml
         application-dev.yml
         application-prod.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中application.yml来切换配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;spring:
  profiles:
    active: dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;激活文件选择&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用上述application.yml来设置&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用java -jar ***.jar &amp;ndash;spring.profiles.active=dev;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IDEA中可以如下设置
&lt;img src=&#34;images/springboot001.png&#34; alt=&#34;激活配置文件&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-配置文件使用&#34;&gt;3.配置文件使用&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;单值注入 （.yml中值若用双引号，转义字符会转义）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//.yml中
person:
  name: zhangsan \n lisi
  name2: &#39;zhangsan \n lisi&#39;
  name3: &amp;quot;zhangsan \n lisi&amp;quot;
  age: 18
  boss: false

//使用
    @Value(&amp;quot;${person.name}&amp;quot;)
    private String name;

    @Value(&amp;quot;${person.name2}&amp;quot;)
    private String name2;


    @Value(&amp;quot;${person.name3}&amp;quot;)
    private String name3;

    @Value(&amp;quot;${person.age}&amp;quot;)
    private String age;

    @Value(&amp;quot;${person.boss}&amp;quot;)
    private String boss;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;批量注入&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//application.yml
student:
  name: lk
  age: 23
  boss: false
  birth: 1997/1/1
  maps: {k1: v1, k2: v2}
  lists:
  - 张三
  - 李四
  dog:
    name: 小黑
    age: 2
    
// pojo.Student
@ConfigurationProperties(prefix = &amp;quot;student&amp;quot;)
@Component
@Data
public class Student {
    private String name;
    private Integer age;
    private Boolean boss;
    private Date birth;
    private Map&amp;lt;String, Object&amp;gt; maps;
    private List&amp;lt;String&amp;gt; lists;
    private Dog dog;
}
// pojo.Dog 
@Data
public class Dog {
    private String name;
    private Integer age;
}

//值注入
 @Autowired
 private Student student;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将配置文件中配置的每一个属性的值，映射到这个组件中&lt;/li&gt;
&lt;li&gt;@ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；&lt;/li&gt;
&lt;li&gt;prefix = &amp;ldquo;person&amp;rdquo;：配置文件中哪个下面的所有属性进行一一映射&lt;/li&gt;
&lt;li&gt;只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能；&lt;/li&gt;
&lt;li&gt;@Data是一个插件，免去了getter/setter和toString这些繁琐的东西&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-两种注入区别&#34;&gt;4.两种注入区别&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;@ConfigurationProperties&lt;/th&gt;
&lt;th&gt;@Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;功能&lt;/td&gt;
&lt;td&gt;批量注入配置文件中的属性&lt;/td&gt;
&lt;td&gt;一个个指定&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;松散绑定（松散语法）&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SpEL： #{}&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;JSR303数据校验&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;复杂类型封装&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;松散语法绑定：last_name = last-name = lastName 他们取的值都是相同的&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot之Swagger</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</link>
      <pubDate>Sat, 08 Jun 2019 17:49:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</guid>
      <description>

&lt;h5 id=&#34;swagger框架&#34;&gt;Swagger框架&lt;/h5&gt;

&lt;p&gt;描述和测试API接口,自动生成API接口文档。&lt;/p&gt;

&lt;h6 id=&#34;1-添加依赖&#34;&gt;1.添加依赖&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--lombok依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.18.8&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;2-swagger配置&#34;&gt;2.Swagger配置&lt;/h6&gt;

&lt;p&gt;在resources目录下新建application.yml文件，添加如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;swagger:
  title: SpringBoot学习
  description: SpringBoot学习
  version: 1.0.0
  name: lk
  url: https://pallcard.github.io
  email: 1250585541@qq.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建SwaggerConfig文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableWebMvc
@EnableSwagger2
@ConfigurationProperties(prefix = &amp;quot;swagger&amp;quot;)
@Data //lombok
@ComponentScan(basePackages = {&amp;quot;cn.wishhust.demo.controller&amp;quot;})
public class SwaggerConfig {

    private String title;
    private String description;
    private String version;

    private String name;
    private String url;
    private String email;

    @Bean
    public Docket customDocket() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
    }

    private ApiInfo apiInfo() {
        Contact contact = new Contact(name, url, email);
        return new ApiInfoBuilder()
                .title(title)
                .description(description)
                .contact(contact)
                .version(version)
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MVC配置:过滤网页静态资源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
class WebMvcConfig implements WebMvcConfigurer {

    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&amp;quot;swagger-ui.html&amp;quot;)
                .addResourceLocations(&amp;quot;classpath:/META-INF/resources/&amp;quot;);

        registry.addResourceHandler(&amp;quot;/webjars/**&amp;quot;)
                .addResourceLocations(&amp;quot;classpath:/META-INF/resources/webjars/&amp;quot;);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;3-使用&#34;&gt;3.使用&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
@Api(value = &amp;quot;测试&amp;quot;)
public class HelloWorld {

    Logger log = LoggerFactory.getLogger(HelloWorld.class);
    
    @GetMapping(value={&amp;quot;/hello&amp;quot;})
    @ApiOperation(value = &amp;quot;hello&amp;quot;)
//    @ApiImplicitParam
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot传递参数</title>
      <link>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 08 Jun 2019 17:08:34 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</guid>
      <description>

&lt;h5 id=&#34;url传参&#34;&gt;url传参&lt;/h5&gt;

&lt;h6 id=&#34;1-get方式&#34;&gt;1.get方式&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; 	// 访问：http://localhost:8080/test/get/xxx
    @GetMapping(&amp;quot;/get/{name}&amp;quot;)
    public String get(@PathVariable(&amp;quot;name&amp;quot;) String name2){
        System.out.println(&amp;quot;name: &amp;quot;+ name2);
        return &amp;quot;Hi &amp;quot;+ name2;
    }

    // 访问：http://localhost:8080/test/get2?name=yyy
    @GetMapping(&amp;quot;/get2&amp;quot;)
    // 请求参数名字与方法中的形参一致，可以省略@RequestParam
    // public String get2(String name2) {
    public String get2(@RequestParam(&amp;quot;name&amp;quot;) String name2) {
        System.out.println(&amp;quot;name: &amp;quot;+ name2);
        return &amp;quot;Hi &amp;quot;+ name2;
    }

    @GetMapping(&amp;quot;/get3&amp;quot;)
    //给一个默认值或者required = false
    public String get3(@RequestParam(value = &amp;quot;name&amp;quot;, defaultValue = &amp;quot;admin&amp;quot;) String name) {
        System.out.println(&amp;quot;name: &amp;quot;+ name);
        return &amp;quot;Hi &amp;quot;+ name;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;2-post方式&#34;&gt;2.post方式&lt;/h6&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @PostMapping(&amp;quot;/post&amp;quot;)
    //@RequestParam同get
    public String post(@RequestParam(&amp;quot;username&amp;quot;) String name, Integer age){
        log.info(&amp;quot;name=&amp;quot; + name+&amp;quot;, age=&amp;quot; + age);
        return &amp;quot;name=&amp;quot; + name+&amp;quot;, age=&amp;quot; + age;
    }
    
    @PostMapping(&amp;quot;post2&amp;quot;)
    public String post2(HttpServletRequest request) {
        ServletInputStream is = null;
        StringBuilder sb = null;
        try {
            is = request.getInputStream();
            sb = new StringBuilder();
            byte[] buf = new byte[1024];
            int len = 0;
            while ((len = is.read(buf)) != -1){
                sb.append(new String(buf,0,len));
            }
            System.out.println(sb.toString());
            return sb.toString();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return sb.toString();
    }

    @PostMapping(&amp;quot;/post3&amp;quot;)
    public String post3(@RequestBody User user) {
        log.info(user.toString());
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
* 把json作为参数传递,要用【RequestBody】&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot启动类</title>
      <link>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jun 2019 10:53:04 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</guid>
      <description>

&lt;h5 id=&#34;1-pom文件&#34;&gt;1.POM文件&lt;/h5&gt;

&lt;p&gt;整个项目的pom文件中（pom.xml）,可以看到该项目的parent，通过点击&lt;artifactId&gt;标签，可以进入parent中，这样可以看到项目的最终的parent。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-启动器&#34;&gt;2.启动器&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt;
spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；
SpringBoot启动器文档：&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-主程序类&#34;&gt;3.主程序类&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;@SpringBootApplication：用来标注这个类为SpringBoot的主配置类，该注解是一个组合注解。&lt;/li&gt;
&lt;li&gt;将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；&lt;/li&gt;
&lt;li&gt;Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；
&lt;code&gt;java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
excludeFilters = {@Filter(
type = FilterType.CUSTOM,
classes = {TypeExcludeFilter.class}
), @Filter(
type = FilterType.CUSTOM,
classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
&lt;/code&gt;
* @SpringBootConfiguration: SpringBoot的配置类，
* @EnableAutoConfiguration：开启自动配置功能

参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot入门</title>
      <link>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 08 Jun 2019 10:18:29 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</guid>
      <description>

&lt;h5 id=&#34;创建工程&#34;&gt;创建工程&lt;/h5&gt;

&lt;p&gt;使用IDEA，按照提示创建即可。&lt;/p&gt;

&lt;h5 id=&#34;修改banner&#34;&gt;修改Banner&lt;/h5&gt;

&lt;p&gt;在resources目录下创建banner.txt文件，改文件用于指定banner，文字生成banner的网址：&lt;a href=&#34;http://patorjk.com/software/taag。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://patorjk.com/software/taag。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;${AnsiColor.BLUE}
.____     ____  __.
|    |   |    |/ _|
|    |   |      &amp;lt;  
|    |___|    |  \ 
|_______ \____|__ \
        \/       \/
-----版本号-----${spring-boot.version}      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：
${AnsiColor.BLUE}   表示Banner文字的颜色
${spring-boot.version}  当前使用的SpringBoot版本&lt;/p&gt;

&lt;h5 id=&#34;创建controller类&#34;&gt;创建Controller类&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HelloWorld {
    @RequestMapping(value = &amp;quot;/hello&amp;quot;,method = RequestMethod.GET)
    @ResponseBody
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问：&lt;a href=&#34;http://localhost:8080/hello，即可以看到Hello&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/hello，即可以看到Hello&lt;/a&gt; Spring Boot
&lt;strong&gt;&lt;em&gt;另外一种注解方式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
public class HelloWorld {
    @GetMapping(&amp;quot;/hello&amp;quot;)
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明
* @RestController：处理http请求：等同于@Controller+@ResponseBody
* @GetMapping：@RequestMapping以get请求的简写&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;url的其他形式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/test&amp;quot;)
public class HelloWorld {
    @GetMapping(value={&amp;quot;/hello&amp;quot;,&amp;quot;/hi&amp;quot;})
    public String hello(){
        return &amp;quot;Hello Spring Boot&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://zed058.cn&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zed058.cn&lt;/a&gt;
文档：&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法008</title>
      <link>https://pallcard.github.io/2019/algorithm008/</link>
      <pubDate>Wed, 05 Jun 2019 20:40:17 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm008/</guid>
      <description>&lt;p&gt;public class Question008 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int [][] array = new int [m][n];
    for (int i = 0; i &amp;lt; m; i++) {
        for (int j = 0; j &amp;lt; n; j++) {
            array[i][j] = -1;
        }
    }
    int x = 0, y = 0;
    int count = 1;
    // 右1 下2 左3 上4
    int last_t = 1;
    while (count &amp;lt;= m*n) {
        array[x][y] = count++;
        if(last_t == 1) {
            if (y+1&amp;lt;n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0){
                y++;
            } else {
                last_t = 2;
                if (x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) {
                    x++;
                }else {
                    break;
                }
            }
            //下
        } else if (last_t == 2) {
            if(x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) {
                x++;
            } else {
                last_t = 3;
                if (y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) {
                    y--;
                } else {
                    break;
                }
            }
            //左
        } else if (last_t == 3) {
            if(y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) {
                y--;
            } else {
                last_t = 4;
                if (x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) {
                    x--;
                } else {
                    break;
                }
            }
        }
        //上
        else {
            if(x-1 &amp;gt;= 0  &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) {
                x--;
            } else {
                last_t = 1;
                if (y+1 &amp;lt; n  &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0) {
                    y++;
                } else {
                    break;
                }
            }
        }
    }
    for (int i = 0; i &amp;lt; m; i++) {
        for (int j = 0; j &amp;lt; n; j++) {
            System.out.print(array[i][j]+&amp;quot;\t&amp;quot;);
        }
        System.out.println();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>算法007</title>
      <link>https://pallcard.github.io/2019/algorithm007/</link>
      <pubDate>Wed, 05 Jun 2019 15:40:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm007/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;一个栈负责入队，另一个栈负责出队。
 *  队列push操作，直接进第一个栈
 *  队列pop操作，判断第二个栈是否为空，若空将第一个栈所有元素进栈到第二个栈中，若不为空，则第二个栈直接出栈&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question007 {
    private static Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;&amp;gt;();
    private static Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;&amp;gt;();

    public void push(Integer item){
        stack1.push(item);
    }

    public Integer pop() throws Exception {
        if(stack2.isEmpty()) {
            while (!stack1.isEmpty()){
                stack2.push(stack1.peek());
            }
        }
        if(stack2.isEmpty()) {
            throw new Exception(&amp;quot;队列为空&amp;quot;);
        }
        return stack2.peek();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法006</title>
      <link>https://pallcard.github.io/2019/algorithm006/</link>
      <pubDate>Wed, 05 Jun 2019 14:50:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm006/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	二叉树
Output:
	中序遍历顺序的下一个结点
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;中序遍历顺序的下一个结点，中序遍历是左根右，
判断该结点是否有右孩子，
 1.若有，则下一个结点的最左子结点
 2.若无，则下一个结点为第一个左链指向该结点的祖先结点的结点&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question006 {

    class TreeLinkNode {
        int val;
        TreeLinkNode left = null;
        TreeLinkNode right = null;
        TreeLinkNode next = null;

        TreeLinkNode(int val) {
            this.val = val;
        }
    }

    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        TreeLinkNode resultNode = null;
        if(null != pNode.right) {
            resultNode = pNode.right;
            while (null != resultNode.left) {
                resultNode = resultNode.next;
            }
        } else {
            TreeLinkNode temp = pNode;
            resultNode = pNode.next;
            while (null != resultNode &amp;amp;&amp;amp; resultNode.left != temp) {
                temp = pNode.next;
                resultNode = temp.next;
            }
        }
        return resultNode;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法005</title>
      <link>https://pallcard.github.io/2019/algorithm005/</link>
      <pubDate>Wed, 05 Jun 2019 10:22:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm005/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	preorder：{3,9,20,15,7}
	inorder：{9,3,15,20,7}
Output:
	该二叉树
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;根据先序遍历确定根，再通过中序遍历将数组划分为两部分，分别是左子树、右子树。
故可以通过一个HashMap存储中序遍历的数组值与下标，key为值，value为下标。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class TreeNode {
    private TreeNode leftChild;
    private TreeNode rightChild;
    private int value;

    public TreeNode(int value) {
        this.value = value;
    }

    public TreeNode getLeftChild() {
        return leftChild;
    }

    public void setLeftChild(TreeNode leftChild) {
        this.leftChild = leftChild;
    }

    public TreeNode getRightChild() {
        return rightChild;
    }

    public void setRightChild(TreeNode rightChild) {
        this.rightChild = rightChild;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }
}

public class Question005 {
	//中序遍历结果，用来对二叉树进行划分，左右子树
    //为了方便快速的找出根结点对应的下标，来确定左右子树结点个数
    private static HashMap&amp;lt;Integer, Integer&amp;gt; preorderMap = new HashMap&amp;lt;&amp;gt;();
    public static void main(String[] args) {
        int [] preorder = new int[] {3,9,20,15,7};
        int [] inorder = new int[] {9,3,15,20,7};

        for (int i = 0; i &amp;lt; preorder.length; i++) {
            preorderMap.put(inorder[i],i);
        }
        TreeNode root = reConstructBinaryTree(preorder,0, preorder.length);
    }
    /**
     * pre：前序遍历数组
     * preL：二叉树起始结点下标
     * length：长度
     */
    public static TreeNode reConstructBinaryTree(int [] pre, int preL, int length) {
        if (length == 1) {
            return new TreeNode(pre[preL]);
        }
        TreeNode root = new TreeNode(pre[preL]);
        Integer index = preorderMap.get(root.getValue());
        int leftLength = index - preL;
        root.setLeftChild(reConstructBinaryTree(pre,preL+1,leftLength));
        root.setRightChild(reConstructBinaryTree(pre,index+1,length-leftLength-1));
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法004</title>
      <link>https://pallcard.github.io/2019/algorithm004/</link>
      <pubDate>Tue, 04 Jun 2019 19:45:58 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm004/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;从尾到头反过来打印出每个结点的值。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	1 -&amp;gt; 2 -&amp;gt; 3
Output:
	3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;方法一：递归调用
方法二：使用栈&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Node {
    private Node next;
    private int val;

    public Node(Node next, int val) {
        this.next = next;
        this.val = val;
    }

    public Node getNext() {
        return next;
    }

    public void setNext(Node next) {
        this.next = next;
    }

    public int getVal() {
        return val;
    }

    public void setVal(int val) {
        this.val = val;
    }
}

public class Question004 {
    public static void main(String[] args) {
        Node node3 = new Node(null, 3);
        Node node2 = new Node(node3, 2);
        Node node1 = new Node(node2, 1);
        Node node = node1;
		//使用栈
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        while (node != null) {
            stack.push(node.getVal());
            node = node.getNext();
        }

        while (!stack.empty()) {
            System.out.println(stack.pop());
        }
        //递归调用
//        printListFromTailToHead(node1);
    }
    public static void printListFromTailToHead(Node list) {
        if (list.getNext() != null) {
            printListFromTailToHead(list.getNext());
        }
        System.out.println(list.getVal());
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法003</title>
      <link>https://pallcard.github.io/2019/algorithm003/</link>
      <pubDate>Tue, 04 Jun 2019 19:24:08 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm003/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;将一个字符串中的空格替换成 &amp;ldquo;%20&amp;rdquo;。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	&amp;quot;A B&amp;quot;
Output:
	&amp;quot;A%20B&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;由于要将字符串中所用空格替换为%20，故若字符串含有一个空格，则字符串的总长度会增长2，故可以先遍历一遍字符串，若将字符串的总长度变为相应的长度，需要两个指针，分别指向原字符串长度的最后一个票p1，和新字符串的最后一个p2，若原字符串为字符，则直接赋值给p2；若原字符串为空格，则赋值%20。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Question003 {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder(&amp;quot;A B&amp;quot;);
        int p1 = sb.length()-1;//指向原字符串最后一个
        for (int i = 0; i &amp;lt;= p1; i++) {
            if(sb.charAt(i) == &#39; &#39;) {
                sb.append(&amp;quot;  &amp;quot;);
            }
        }
        int p2 = sb.length()-1;//指向新字符串最后一个
        while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p1 &amp;lt; p2) {
            if(sb.charAt(p1) != &#39; &#39;) {
                sb.setCharAt(p2--,sb.charAt(p1--));
            } else if(sb.charAt(p1--) == &#39; &#39;) {
                sb.setCharAt(p2--, &#39;0&#39;);
                sb.setCharAt(p2--, &#39;2&#39;);
                sb.setCharAt(p2--, &#39;%&#39;);
            }
        }
        System.out.println(sb);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
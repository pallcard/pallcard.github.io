<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sun, 02 Jun 2019 10:28:33 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JMM</title>
      <link>https://pallcard.github.io/2019/jmm/</link>
      <pubDate>Sun, 02 Jun 2019 10:28:33 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm/</guid>
      <description>

&lt;h4 id=&#34;jmm&#34;&gt;JMM&lt;/h4&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。&lt;/p&gt;

&lt;h4 id=&#34;jmm模型下的线程间通信&#34;&gt;JMM模型下的线程间通信&lt;/h4&gt;

&lt;p&gt;线程和主内存之间的抽象关系图：
&lt;img src=&#34;https://pallcard.github.io/images/jmm001.png&#34; alt=&#34;线程和主内存&#34; /&gt;
线程间通信必须要经过主内存。&lt;/p&gt;

&lt;p&gt;如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：&lt;/p&gt;

&lt;p&gt;1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。&lt;/p&gt;

&lt;p&gt;2）线程B到主内存中去读取线程A之前已更新过的共享变量。
&lt;img src=&#34;https://pallcard.github.io/images/jmm002.png&#34; alt=&#34;线程通讯&#34; /&gt;
&lt;strong&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/strong&gt; 当线程操作某个对象时，执行顺序如下：
(1) 从主存复制变量到当前工作内存 (read and load)
(2) 执行代码，改变共享变量值 (use and assign)
(3) 用工作内存数据刷新主存相关内容 (store and write)&lt;/p&gt;

&lt;h4 id=&#34;jmm解决的问题&#34;&gt;JMM解决的问题&lt;/h4&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;原子性&lt;/em&gt;&lt;/strong&gt; ：一个操作不能被打断，要么全部执行完毕，要么不执行。
基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;可见性&lt;/em&gt;&lt;/strong&gt; ：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;无论是 &lt;strong&gt;&lt;em&gt;普通变量&lt;/em&gt;&lt;/strong&gt; 还是 &lt;strong&gt;&lt;em&gt;volatile变量&lt;/em&gt;&lt;/strong&gt; 都是如此，区别在于：&lt;strong&gt;&lt;em&gt;volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新&lt;/em&gt;&lt;/strong&gt; ，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。
除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 &lt;strong&gt;&lt;em&gt;synchronized&lt;/em&gt;&lt;/strong&gt; 关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 &lt;strong&gt;&lt;em&gt;Lock接口&lt;/em&gt;&lt;/strong&gt; 的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;strong&gt;&lt;em&gt;final关键字&lt;/em&gt;&lt;/strong&gt; 的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去，那么其他线程就可以看到final变量的值。
　　
&lt;strong&gt;&lt;em&gt;有序性&lt;/em&gt;&lt;/strong&gt; ：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（&lt;strong&gt;&lt;em&gt;单线程&lt;/em&gt;&lt;/strong&gt;）程序的执行结果不会改变。&lt;/p&gt;

&lt;p&gt;happens-before原则定义如下：
1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 01 Jun 2019 20:42:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</guid>
      <description>

&lt;h4 id=&#34;题目描述&#34;&gt;题目描述&lt;/h4&gt;

&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素出现两次。找出只出现一次的元素。&lt;/p&gt;

&lt;h5 id=&#34;示例&#34;&gt;示例&lt;/h5&gt;

&lt;p&gt;输入: [2,2,3]
输出: 3&lt;/p&gt;

&lt;h5 id=&#34;思想&#34;&gt;思想&lt;/h5&gt;

&lt;p&gt;使用按位异或。异或：如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
	int a [] = new int []{2,2,3};
	int temp = 0;
	for (int i = 0; i &amp;lt; a.length; i++) {
		temp ^= a[i];
	}
	System.out.println(temp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;加强&#34;&gt;加强&lt;/h4&gt;

&lt;p&gt;上述数组中有两个数出现一次，求这两个数。&lt;/p&gt;

&lt;h5 id=&#34;示例-1&#34;&gt;示例&lt;/h5&gt;

&lt;p&gt;输入: [2, 2, 6, 4, 5, 5]
输出: 4, 6&lt;/p&gt;

&lt;h5 id=&#34;思想-1&#34;&gt;思想&lt;/h5&gt;

&lt;p&gt;先将所有数按位异或，得到temp，找到temp中二进制位为1的下标，通过这个下标将所用数分为两个数组，分别异或可以得到两个值。
&lt;strong&gt;&lt;em&gt;若有两个数都只出现了一次，若将所有数进行按位异或后，所得到的数中，若按照上述划分，必然可以将这两个数分到不同的数组中&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
	int a [] = new int []{2, 2, 6, 4, 5, 5};
	int temp = 0;
	int max = 0;
	for (int i = 0; i &amp;lt; a.length; i++) {
		temp ^= a[i];
		if (max &amp;lt; a[i]) {
			max = a[i];
		}
	}

	int maxLength = Integer.toBinaryString(max).length();
	String tempString = Integer.toBinaryString(temp);
	StringBuilder sb = new StringBuilder(maxLength);
	for (int i = 0; i &amp;lt; maxLength-tempString.length(); i++) {
		sb.append(&amp;quot;0&amp;quot;);
	}
	sb.append(tempString);
	int index = sb.length() - 1;
	for (; index &amp;gt;= 0; index--) {
		if(sb.charAt(index) == &#39;1&#39;) {
			break;
		}
	}
	int temp1 = 0;
	int temp2 = 0;
	for (int i = 0; i &amp;lt; a.length; i++) {
		String aiBinary = Integer.toBinaryString(a[i]);
		if(aiBinary.length()&amp;gt;index &amp;amp;&amp;amp; aiBinary.charAt(aiBinary.length()-index-1) == &#39;1&#39;) {
			temp1 ^= a[i];
		} else {
			temp2 ^= a[i];
		}
	}
	System.out.print(temp1 + &amp;quot;, &amp;quot; + temp2);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Mysql题</title>
      <link>https://pallcard.github.io/2019/mysql%E9%A2%98/</link>
      <pubDate>Sat, 01 Jun 2019 18:52:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E9%A2%98/</guid>
      <description>

&lt;h4 id=&#34;1-左连接-右连接-内连接&#34;&gt;1.左连接、右连接、内连接&lt;/h4&gt;

&lt;h5 id=&#34;左连接&#34;&gt;左连接&lt;/h5&gt;

&lt;p&gt;以左表为基础，根据on后面的条件进行连接，若右表中无对应数据，则右表数据为NULL。&lt;/p&gt;

&lt;h5 id=&#34;右连接&#34;&gt;右连接&lt;/h5&gt;

&lt;p&gt;以右表为基础，根据on后面的条件进行连接，若左表中无对应数据，则左表数据为NULL。&lt;/p&gt;

&lt;h5 id=&#34;内连接&#34;&gt;内连接&lt;/h5&gt;

&lt;p&gt;两个表做笛卡尔积后根据on后面的条件进行筛选。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://pallcard.github.io/2019/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 31 May 2019 17:15:52 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;p&gt;通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。&lt;/p&gt;

&lt;h4 id=&#34;1-懒汉式&#34;&gt;1.懒汉式&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton1 {
    private static Singleton1 singleton1 = null;
    private Singleton1(){}
    public static Singleton1 newInstance() {
        if (singleton1 == null){
            singleton1 = new Singleton1();
        }
        return  singleton1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-饿汉式&#34;&gt;2.饿汉式&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Singleton2 {
    private static Singleton2 singleton2 = new Singleton2();
    private Singleton2(){}
    public static Singleton2 newSingleton(){
        return singleton2;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-懒汉式改&#34;&gt;3.懒汉式改&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//序列化
public class Singleton3 implements Serializable {
    // volatile保证变量一致性
    private volatile static Singleton3 singleton3 = null;
    private Singleton3(){
        //防止反射调用私有方法
        if(singleton3 != null){
            throw new RuntimeException(&amp;quot;此类对象为单例模式，已被实例化&amp;quot;);
        }
    }

    public static Singleton3 newInstance(){
        //为了避免每次都加锁，避免了一定的加锁的开销
        if(singleton3 == null) {
            //多线程
            synchronized (singleton3) {
                if (singleton3 == null) {
                    singleton3 = new Singleton3();
                }
            }
        }
        return singleton3;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：
1. 外层singleton3 == null，为了避免每次都加锁，避免了一定的加锁的开销；
2. 把类的构造函数定义为私有private，外部便无法通过new生成对象。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo搭建blog</title>
      <link>https://pallcard.github.io/2019/hugo%E6%90%AD%E5%BB%BAblog/</link>
      <pubDate>Fri, 31 May 2019 16:21:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/hugo%E6%90%AD%E5%BB%BAblog/</guid>
      <description>

&lt;p&gt;在windows下使用hugo搭建blog&lt;/p&gt;

&lt;h4 id=&#34;官方网站&#34;&gt;官方网站&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.gohugo.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.gohugo.org/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;1-安装hugo&#34;&gt;1.安装hugo&lt;/h5&gt;

&lt;p&gt;在&lt;a href=&#34;https://github.com/gohugoio/hugo/releases找到相应版本的hugo镜像，下载后解压，如下：&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/gohugoio/hugo/releases找到相应版本的hugo镜像，下载后解压，如下：&lt;/a&gt;
&lt;img src=&#34;https://pallcard.github.io/images/hugo001.png&#34; alt=&#34;windows&#34; /&gt;
配置环境变量：将解压后压缩包放在E盘，则添加如下环境变量
&lt;img src=&#34;https://pallcard.github.io/images/hugo002.png&#34; alt=&#34;环境变量&#34; /&gt;
输入如下命令判断是否按照成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;hugo version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/hugo003.png&#34; alt=&#34;检查安装&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-建立站点&#34;&gt;2.建立站点&lt;/h5&gt;

&lt;p&gt;使用如下命令（blog为路径名）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;hugo new site blog
cd blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成目录如下
&lt;img src=&#34;https://pallcard.github.io/images/hugo004.png&#34; alt=&#34;blog目录&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;3-增加文章&#34;&gt;3.增加文章&lt;/h5&gt;

&lt;p&gt;输入以下命令后会在content里创建一个文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开文件，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;---
title: &amp;quot;About&amp;quot;
date: 2019-05-31T15:47:28+08:00
draft: true
---
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-安装主题&#34;&gt;4.安装主题&lt;/h5&gt;

&lt;p&gt;主题选择的是LeaveIt，安装后会在themes中生成对应文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cd themes
git clone https://github.com/liuzc/LeaveIt.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在config.toml中配置如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;theme = &amp;quot;LeaveIt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;4-运行hugo&#34;&gt;4.运行hugo&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;hugo server -D
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;5-配置&#34;&gt;5.配置&lt;/h5&gt;

&lt;p&gt;在content中新建文件夹posts，并在config.toml中加入配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;# 菜单的配置
[menu]
  [[menu.main]]
    name = &amp;quot;博客&amp;quot;
    url = &amp;quot;/posts/&amp;quot;
    weight = 1
  [[menu.main]]
    name = &amp;quot;分类&amp;quot;
    url = &amp;quot;/categories/&amp;quot;
    weight = 2
  [[menu.main]]
    name = &amp;quot;标签&amp;quot;
    url = &amp;quot;/tags/&amp;quot;
    weight = 3
  [[menu.main]]
    name = &amp;quot;关于&amp;quot;
    url = &amp;quot;/about/&amp;quot;
    weight = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在建新文章时，categories中为文章分类，tags为标签。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;---
title: &amp;quot;代理模式&amp;quot;
date: 2019-05-29T20:06:16+08:00
draft: false
categories: [&amp;quot;Java&amp;quot;]
tags: [&amp;quot;Java&amp;quot;,&amp;quot;设计模式&amp;quot;]
---
#### 内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;5-部署&#34;&gt;5.部署&lt;/h5&gt;

&lt;p&gt;部署到GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：pallcard.github.io （pallcard替换为你的github用户名）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;hugo --theme=LeaveIt --baseUrl=&amp;quot;http://pallcard.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cd public
git init
git remote add origin https://github.com/pallcard/pallcard.github.io.git
git add -A
git commit -m &amp;quot;first commit&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器里访问:&lt;a href=&#34;http://coderzh.pallcard.io/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://coderzh.pallcard.io/&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;6-注意&#34;&gt;6.注意&lt;/h5&gt;

&lt;p&gt;1.每次使用hugo new posts/xxx.md创建文章后，&lt;strong&gt;&lt;em&gt;记得要将draft 改为false&lt;/em&gt;&lt;/strong&gt;
2.更新部署时，在根目录执行hugo，然后push到github上即可&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://pallcard.github.io/2019/java-proxy/</link>
      <pubDate>Wed, 29 May 2019 20:06:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/java-proxy/</guid>
      <description>

&lt;h4 id=&#34;代理模式&#34;&gt;代理模式&lt;/h4&gt;

&lt;p&gt;代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/p&gt;

&lt;p&gt;简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。
&lt;img src=&#34;https://pallcard.github.io/images/java-proxy001.png&#34; alt=&#34;代理模式&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;静态代理&#34;&gt;静态代理&lt;/h4&gt;

&lt;p&gt;静态代理目录结构
&lt;img src=&#34;https://pallcard.github.io/images/java-proxy002.png&#34; alt=&#34;目录结构&#34; /&gt;
&lt;strong&gt;&lt;em&gt;主题接口 IUserDao&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IUserDao {
    void saveUser();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;主题接口实现类（被代理类） UserDao&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDao implements IUserDao{
    @Override
    public void saveUser() {
        System.out.println(&amp;quot;保存用户数据&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;代理类 UserDaoProxy&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoProxy implements IUserDao {
    
    //目标对象
    private IUserDao targer;

    public UserDaoProxy(IUserDao iUserDao){
        this.targer = iUserDao;
    }

    @Override
    public void saveUser() {
        System.out.println(&amp;quot;开启事务&amp;quot;);
        targer.saveUser();
        System.out.println(&amp;quot;提交事务&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;测试类 ProxyTest&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyTest {
    @Test
    void testStaticProxy(){
        //目标对象
        IUserDao target = new UserDao();
        //代理对象
        UserDaoProxy proxy = new UserDaoProxy(target);
        proxy.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态代理&#34;&gt;动态代理&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;要求真实对象必须有实现接口&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;说明：&lt;/em&gt;&lt;/strong&gt;
* Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。
public static Object newProxyInstance(ClassLoader loader,//类加载器
                                      类&amp;lt;?&amp;gt;[] interfaces,//代理类实现的接口列表
                                      InvocationHandler h//调度方法调用的调用处理函数
                                      ) throws IllegalArgumentException                                  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;InvocationHandler&lt;/em&gt;&lt;/strong&gt; 是由代理实例的调用处理程序实现的接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Object invoke(Object proxy,   //调用该方法的代理实例
              方法 method,  //所述方法对应于调用代理实例上的接口方法的实例
              Object[] args) //接口方法参数
       throws Throwable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;IUserDao、UserDao同上&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;UserDaoProxy&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyFactory {

    //目标对象
    private Object targer;

    public ProxyFactory(Object targer){
        this.targer = targer;
    }

    public Object getProxyInstance() {
        return Proxy.newProxyInstance(targer.getClass().getClassLoader(), targer.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(proxy.getClass());
                System.out.println(&amp;quot;开启事务&amp;quot;);
                method.invoke(targer, args);
                System.out.println(&amp;quot;提交事务&amp;quot;);
                return null;
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;一般可以改成如下&lt;/em&gt;&lt;/strong&gt;
说明：
代理类继承InvocationHandler&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyFactory2 implements InvocationHandler{

    //目标对象
    private Object targer;

    public ProxyFactory2(Object targer){
        this.targer = targer;
    }

    public &amp;lt;T&amp;gt; T getProxyInstance() {
        return (T) Proxy.newProxyInstance(targer.getClass().getClassLoader(),
                targer.getClass().getInterfaces(),
                this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&amp;quot;开启事务&amp;quot;);
        Object invoke = method.invoke(targer, args);
        System.out.println(&amp;quot;提交事务&amp;quot;);
        return invoke;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;动态代理测试&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyTest {
    @Test
    void testStaticProxy(){
        //目标对象
        IUserDao target = new UserDao();
        //代理对象
//        IUserDao proxyInstance = (IUserDao) new UserDaoProxy(target).getProxyInstance();
        IUserDao proxyInstance = new UserDaoProxy2(target).getProxyInstance();//将强转放到了代理类中
        proxyInstance.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;
* 若在invoke中调用 proxy.toString()会出现栈溢出，原因是改方法会继续调用invoke方法，出现循环调用，最终栈溢出。
* 关于invoke方法中proxy参数的作用：只有proxy 实例在InvocationHandler 实现类里加载才能产生第二个参数method (静态代码块是虚拟机加载类的时候执行的，而且只执行一次）&lt;/p&gt;

&lt;h4 id=&#34;cglib代理&#34;&gt;cglib代理&lt;/h4&gt;

&lt;p&gt;引入依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;compile &amp;quot;cglib:cglib:3.2.5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;UserDao&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDao {
    public void saveUser() {
        System.out.println(&amp;quot;保存用户数据&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;ProxyFactory&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyFactory implements MethodInterceptor {
    //目标对象
    private Object target;

    public ProxyFactory(Object target){
        this.target = target;
    }

    public Object getProxyInstance() {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(&amp;quot;开启事务&amp;quot;);
        Object invoke = method.invoke(target, args);
        System.out.println(&amp;quot;提交事务&amp;quot;);
        return invoke;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProxyTest类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProxyTest {
    @Test
    public void testcglibProxy(){
        //目标对象
        UserDao target = new UserDao();
        //代理对象
        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();
        proxy.saveUser();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代理方式&lt;/th&gt;
&lt;th&gt;实现&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JDK静态代理&lt;/td&gt;
&lt;td&gt;代理类与委托类实现同一接口，并且在代理类中需要硬编码接口&lt;/td&gt;
&lt;td&gt;实现简单，容易理解&lt;/td&gt;
&lt;td&gt;代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;JDK动态代理&lt;/td&gt;
&lt;td&gt;代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理&lt;/td&gt;
&lt;td&gt;不需要硬编码接口，代码复用率高&lt;/td&gt;
&lt;td&gt;只能够代理实现了接口的委托类&lt;/td&gt;
&lt;td&gt;底层使用反射机制进行方法的调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CGLIB动态代理&lt;/td&gt;
&lt;td&gt;代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理&lt;/td&gt;
&lt;td&gt;可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口&lt;/td&gt;
&lt;td&gt;不能对final类以及final方法进行代理&lt;/td&gt;
&lt;td&gt;底层将方法全部存入一个数组中，通过数组索引直接进行方法调用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://segmentfault.com/a/1190000011291179#articleHeader3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://segmentfault.com/a/1190000011291179#articleHeader3&lt;/a&gt;
&lt;a href=&#34;https://www.jianshu.com/p/9a61af393e41?from=timeline&amp;amp;isappinstalled=0&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.jianshu.com/p/9a61af393e41?from=timeline&amp;amp;isappinstalled=0&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mysql基础</title>
      <link>https://pallcard.github.io/2019/mysql%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 27 May 2019 18:56:26 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E5%9F%BA%E7%A1%80/</guid>
      <description>

&lt;h4 id=&#34;dbms分类&#34;&gt;DBMS分类&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;基于共享文件系统的DBMS，例如：Microsoft Access&lt;/li&gt;
&lt;li&gt;基于客户机—服务器的DBMS，例如：MySql，Oracle，SQL Server&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;连接mysql&#34;&gt;连接mysql&lt;/h4&gt;

&lt;p&gt;格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mysql -h 主机地址 -u 用户名 -p 用户密码
例如：/usr/local/mysql/bin/mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;选择数据库&#34;&gt;选择数据库&lt;/h4&gt;

&lt;p&gt;最初连接mysql时，没有任何数据库可供使用，需要使用use来选择一个数据库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;use 数据库名称
例如：USE mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;显示数据库一些信息&#34;&gt;显示数据库一些信息&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SHOW DATABASES;   //显示所有数据库
SHOW TABLES;       //显示当前数据库中所有表
SHOW COLUMNS FROM xxx;   //显示xxx表中的列
DESCRIBE xxx；//同上
SHOW STATUS;   //用于显示广泛的服务器状态信息
SHOW GRANTS;  //显示授权用户权限
SHOW ERRORS和SHOW WARNINGS；//用来显示服务器错误或警告消息
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;检索数据&#34;&gt;检索数据&lt;/h4&gt;

&lt;p&gt;许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有 列和表名使用小写，这样做使代码更易于阅读和调试。&lt;/p&gt;

&lt;h5 id=&#34;select&#34;&gt;select&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT DISTINCT yyy FROM xxx LIMIT 5; //检索xxx表中yyy列(DISTINCT去重，不多于5)
SELECT * FROM xxx LIMIT 5, 5; //从第5行开始5行，下标0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
DITINCT会作用于所有的列，不会部分使用&lt;/p&gt;

&lt;h5 id=&#34;order-by&#34;&gt;order by&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;select * from xxx order by yyy;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
1.默认升序，降序使用DESC
2.可以指定多列，先按第一列排，再按照第二列，。。。
3.在多个列上降序排序 如果想在多个列上进行降序排序，必须 对每个列指定DESC关键字。
4. limit要在order by之后&lt;/p&gt;

&lt;h5 id=&#34;where&#34;&gt;where&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;select * from xxx where yyy=&amp;quot;&amp;quot;;
例：
SELECT * FROM news WHERE title = &amp;quot;新闻4&amp;quot; ORDER BY title;
SELECT * FROM news WHERE title BETWEEN &amp;quot;新闻1&amp;quot; AND &amp;quot;新闻5&amp;quot; ORDER BY title;
SELECT * FROM news WHERE creator_id IS NULL LIMIT 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
1.在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤
2.order by位于where之后&lt;/p&gt;

&lt;h5 id=&#34;and-or-in&#34;&gt;AND OR IN&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT * FROM news WHERE title BETWEEN &amp;quot;新闻3&amp;quot; AND &amp;quot;新闻6&amp;quot; OR id &amp;lt; 3;
例如：IN的使用
SELECT * FROM news WHERE title NOT IN (&amp;quot;新闻1&amp;quot;,&amp;quot;新闻2&amp;quot;,&amp;quot;新闻3&amp;quot;,&amp;quot;新闻10&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SQL（像多数语言一样）在处理OR操作符前，优先处理AND操 作符。&lt;strong&gt;&lt;em&gt;使用圆括号明确地分组相应的操作符&lt;/em&gt;&lt;/strong&gt;，圆括号具有较AND或OR操作符高的计算次序
2.IN在WHERE子句中用来指定要匹配值的清单的关键字，功能与OR 相当。&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;通配符&#34;&gt;通配符&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT * FROM news WHERE title LIKE &amp;quot;新闻1%&amp;quot;
SELECT * FROM news WHERE title LIKE &amp;quot;新闻_&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;%表示任何字符出现 &lt;strong&gt;&lt;em&gt;任意次数&lt;/em&gt;&lt;/strong&gt;,不能匹配到NULL&lt;/li&gt;
&lt;li&gt;_匹配单个字符&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT * FROM news WHERE title REGEXP &amp;quot;新闻1|新闻2&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.注意与like的区别&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;搜索两个串之一（或者为这个串，或者为另一个串），使用|,例如1|2&lt;/li&gt;
&lt;li&gt;匹配任何单一字符[],例如[1,2,3]是匹配1或2或3&lt;/li&gt;
&lt;li&gt;匹配特殊字符，必须用\为前导，例如\.&lt;/li&gt;
&lt;li&gt;重复元素&lt;/li&gt;
&lt;li&gt;^有两种用法。在集合中（用[和]定义），用它 来否定该集合，否则，用来指串的开始处。[0-9\.]一个数（包括以小数点开始的数）&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;0个或多个匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;1个或多个匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;td&gt;0个或1个匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;｛n｝&lt;/td&gt;
&lt;td&gt;指定数目的匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;｛n,｝&lt;/td&gt;
&lt;td&gt;不少于指定数目的匹配&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;匹配数目的范围（m不超过255）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;文本的开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;文本的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;计算字段&#34;&gt;计算字段&lt;/h4&gt;

&lt;h5 id=&#34;拼接&#34;&gt;拼接&lt;/h5&gt;

&lt;p&gt;拼接（concatenate） 将值联结到一起构成单个值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT CONCAT(&amp;quot;title:&amp;quot;,title,&amp;quot;,id:&amp;quot;,id) AS test2 FROM news LIMIT 0,10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;trim(),ltrim(),rtrim(),去掉串左右空格
as 别名
计算+ - * /&lt;/p&gt;

&lt;h5 id=&#34;函数&#34;&gt;函数&lt;/h5&gt;

&lt;h5 id=&#34;聚集函数&#34;&gt;聚集函数&lt;/h5&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AVG()&lt;/td&gt;
&lt;td&gt;返回某列的平均值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COUNT()&lt;/td&gt;
&lt;td&gt;返回某列的行数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MAX()&lt;/td&gt;
&lt;td&gt;返回某列的最大值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MIN()&lt;/td&gt;
&lt;td&gt;返回某列的最小值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SUM()&lt;/td&gt;
&lt;td&gt;返回某列值之和&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
聚集函数中使用 DISTINCT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT COUNT(DISTINCT title) FROM news;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;分组&#34;&gt;分组&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;格式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT type, COUNT(*) AS num FROM news GROUP BY type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;筛选&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT *, COUNT(title) AS num FROM news GROUP BY TYPE HAVING num &amp;gt; 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子句&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;是否必须使用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SELECT&lt;/td&gt;
&lt;td&gt;要返回的列或表达式&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FROM&lt;/td&gt;
&lt;td&gt;从中检索数据的表&lt;/td&gt;
&lt;td&gt;仅在从表选择数据时使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WHERE&lt;/td&gt;
&lt;td&gt;行级过滤&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GROUP BY&lt;/td&gt;
&lt;td&gt;分组说明&lt;/td&gt;
&lt;td&gt;仅在按组计算聚集时使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HAVING&lt;/td&gt;
&lt;td&gt;组级过滤&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ORDER BY&lt;/td&gt;
&lt;td&gt;输出排序顺序&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LIMIT&lt;/td&gt;
&lt;td&gt;要检索的行数&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;子查询&#34;&gt;子查询&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT * FROM theme WHERE id IN (SELECT id FROM news WHERE create_time &amp;gt; &amp;quot;2019-01-12&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;联结&#34;&gt;联结&lt;/h4&gt;

&lt;p&gt;1.内部联结&lt;/p&gt;

&lt;p&gt;它基于两个表之间的 相等测试。这种联结也称为内部联结。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT * FROM movie_arrange,films WHERE movie_arrange.id = films.id;
//推荐
SELECT * FROM movie_arrange INNER JOIN films ON movie_arrange.id = films.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.外部联结
许多联结将一个表中的行与另一个表中的行相关联。但有时候会需 要包含没有关联行的那些行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//左外连接，左表所有行保留
SELECT * FROM movie_arrange LEFT OUTER JOIN films ON movie_arrange.id = films.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;组合查询&#34;&gt;组合查询&lt;/h4&gt;

&lt;p&gt;MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个 查询结果集返回。这些组合查询通常称为并（union）或复合查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SELECT cinema_id, movie_name FROM movie_arrange
UNION
SELECT id, name FROM films
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;
UNION 会自动取消重复行，如果想返回所有匹配行，可使用UNION ALL&lt;/p&gt;

&lt;h4 id=&#34;全文搜索&#34;&gt;全文搜索&lt;/h4&gt;

&lt;p&gt;为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改 变不断地重新索引。&lt;/p&gt;

&lt;p&gt;全文搜索会将行中内容使用分词器进行拆分，并建立索引，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;建表时加入
FULLTEXT (title,body)
查询时，Match()指定被搜索的列，Against()指定要使用的搜索表达式。
SELECT * FROM articles 
WHERE MATCH (title,body)
AGAINST (&#39;database&#39; IN NATURAL LANGUAGE MODE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://blog.csdn.net/bbirdsky/article/details/45368897&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://blog.csdn.net/bbirdsky/article/details/45368897&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;插入-更新-删除&#34;&gt;插入 更新 删除&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;插入&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;INSERT INTO articles (title,body) VALUES
(&#39;How To Use MySQL Well&#39;,&#39;After you went...&#39;),
 (&#39;MySQL Tutorial&#39;,&#39;DBMS stands for DataBase ...&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;更新&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;UPDATE articles SET title = &#39;def&#39; WHERE id = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;删除&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DELETE FROM articles WHERE id = 7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果省略了WHERE子句，则UPDATE或DELETE将被应用到表中 所有的行&lt;/p&gt;

&lt;h4 id=&#34;表操作&#34;&gt;表操作&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;创建表&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CREATE TABLE articles (
     id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
     title VARCHAR(200) DEFAULT &#39;no title&#39;,
     body TEXT,
     FULLTEXT (title,body)
) ENGINE=INNODB;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;更新表&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ALTER TABLE articles ADD score CHAR(2);
ALTER TABLE articles DROP score;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;删除表&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;DROP TABLE articles
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;重命名表&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;RENAME TABLE articles TO articles2;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://pallcard.github.io/about/</link>
      <pubDate>Mon, 27 May 2019 18:55:29 +0800</pubDate>
      
      <guid>https://pallcard.github.io/about/</guid>
      <description>&lt;p&gt;研一学生&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
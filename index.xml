<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Tue, 06 Aug 2019 22:10:05 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>装饰者模式</title>
      <link>https://pallcard.github.io/2019/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 06 Aug 2019 22:10:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h2 id=&#34;装饰者模式&#34;&gt;装饰者模式&lt;/h2&gt;

&lt;p&gt;在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;

&lt;h2 id=&#34;举例说明&#34;&gt;举例说明&lt;/h2&gt;

&lt;p&gt;包含四个部分
1. 抽象组件 &amp;mdash;-&amp;gt; IDrink
2. 具体组件 &amp;mdash;-&amp;gt; Coffee
3. 抽象装饰 &amp;mdash;-&amp;gt; DrinkDecorator
4. 具体装饰 &amp;mdash;-&amp;gt; Milk, Ice&lt;/p&gt;

&lt;h3 id=&#34;抽象主键-idrink&#34;&gt;抽象主键 IDrink&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IDrink {
    double cost();
    String describe();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;具体组件-coffee&#34;&gt;具体组件 Coffee&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Coffee implements IDrink{
    @Override
    public double cost() {
        return 10;
    }

    @Override
    public String describe() {
        return &amp;quot;coffer&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽象装饰-drinkdecorator&#34;&gt;抽象装饰 DrinkDecorator&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class DrinkDecorator implements IDrink {
    protected IDrink drink;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽象装饰-milk&#34;&gt;抽象装饰 Milk&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Milk extends DrinkDecorator{

    public Milk(IDrink drink) {
        this.drink = drink;
    }


    @Override
    public double cost() {
        return 1 + this.drink.cost();
    }

    @Override
    public String describe() {
        return  this.drink.describe() + &amp;quot; with milk&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;主要使用类的组合来实现对于一个类进行动态的增加功能。具体组件和抽象装饰都实现了抽象组件，具体组件又是抽象组件的子类，当调用时，可以要修饰的对象传递给修饰类，这样就可以对抽象对类进行功能对增强。&lt;/p&gt;

&lt;h2 id=&#34;使用动态代理对coffer类进行增强&#34;&gt;使用动态代理对coffer类进行增强&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class CoffeeProxyFactory implements InvocationHandler {

    private Object target;

    public CoffeeProxyFactory(Object target) {
        this.target = target;
    }

    public Object getInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke;

        if (&amp;quot;describe&amp;quot;.equals(method.getName())) {
            invoke = method.invoke(target, args);
            invoke += &amp;quot; with milk&amp;quot;;
            return invoke;
        } else {
            invoke = method.invoke(target, args);
//            invoke = 1 + (Integer) invoke;
            return invoke;
        }

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        IDrink drink = new Coffee();
        drink = new Milk(drink);
        drink = new Ice(drink);
        System.out.println(drink.cost());
        System.out.println(drink.describe());

        System.out.println(&amp;quot;+++++++++++++++&amp;quot;);
        System.out.println(&amp;quot;动态代理&amp;quot;);
        System.out.println(&amp;quot;+++++++++++++++&amp;quot;);
        IDrink iDrink = new Coffee();
        IDrink drinkProxy =  (IDrink) new CoffeeProxyFactory(iDrink).getInstance();
        System.out.println(drinkProxy.cost());
        System.out.println(drinkProxy.describe());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;装饰器模式可以在不增加新的装饰类的情况下对已有的功能进行组合而得到新的功能，但得修改客户端代码才能使用新的功能。动态代理则是增加一个新的类来实现功能，哪怕这个功能是对已有功能的组合，但可以不用修改客户端代码。&lt;strong&gt;a.增不增加新类。b.是否需要更改客户端代码&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理模式主要是控制对某个特定对象访问，而装饰模式主要是为了给对象添加行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot注解</title>
      <link>https://pallcard.github.io/2019/springboot%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2019 20:08:00 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E6%B3%A8%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;spring-web-mvc&#34;&gt;Spring Web MVC&lt;/h2&gt;

&lt;h3 id=&#34;requestmapping&#34;&gt;@RequestMapping&lt;/h3&gt;

&lt;p&gt;主要用途是将web请求与请求处理类中的方法进行映射。&lt;/p&gt;

&lt;p&gt;属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;value:映射的请求URL或者其别名&lt;/li&gt;
&lt;li&gt;method:兼容HTTP的方法名&lt;/li&gt;
&lt;li&gt;params:根据HTTP参数的存在、缺省或值对请求进行过滤&lt;/li&gt;
&lt;li&gt;header:根据HTTP Header的存在、缺省或值对请求进行过滤&lt;/li&gt;
&lt;li&gt;consume:设定在HTTP请求正文中允许使用的媒体类型&lt;/li&gt;
&lt;li&gt;product:在HTTP响应体中允许使用的媒体类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般主要使用前3个属性。改注解也可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(value=&amp;quot;/demo&amp;quot;)
public class Demo {
	@RequestMapping(value=&amp;quot;/test&amp;quot;, method=RequestMethod.GET)
	public String test() {
		return &amp;quot;test&amp;quot;;
	}
}
// 说明：请求路径为 /demo/test时，调用test()方法处理
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestbody&#34;&gt;@RequestBody&lt;/h3&gt;

&lt;p&gt;在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过HttpMessageConverter传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。还可以通过 &lt;strong&gt;@Valid&lt;/strong&gt; 注解对请求主体中的参数进行校验。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/api/v1&amp;quot;)
public class UserController {

	@PostMapping(&amp;quot;/Login&amp;quot;)
    public IJSONResult Login(@RequestBody Users user) throws Exception {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestparam&#34;&gt;@RequestParam&lt;/h3&gt;

&lt;p&gt;用于将方法的参数与Web请求的传递的参数进行绑定。使用@RequestParam可以轻松的访问HTTP请求参数的值。该注解的其他属性配置与@PathVariable的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(/users)
public Role getUserRole(@RequestParam(name=&amp;quot;id&amp;quot;, defaultValue=&amp;quot;0&amp;quot;) long id) {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h3&gt;

&lt;p&gt;将方法中的参数绑定到请求URI中的模板变量上。可以通过@RequestMapping注解来指定URI的模板变量，然后使用@PathVariable注解将方法中的参数绑定到模板变量上。特别地，@PathVariable注解允许我们使用value或name属性来给参数取一个别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(&amp;quot;/users/{id}&amp;quot;)
public Role getUserRole(@PathVariable(name=&amp;quot;id&amp;quot;) long id) {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;responsebody&#34;&gt;@ResponseBody&lt;/h3&gt;

&lt;p&gt;@ResponseBody会自动将控制器中方法的返回值写入到HTTP响应中。特别的，@ResponseBody注解只能用在被@Controller注解标记的类中。如果在被@RestController标记的类中，则方法不需要使用@ResponseBody注解进行标注。@RestController相当于是@Controller和@ResponseBody的组合注解。&lt;/p&gt;

&lt;h3 id=&#34;getmapping&#34;&gt;@GetMapping&lt;/h3&gt;

&lt;p&gt;用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是@RequestMapping(method=RequestMethod.GET)的快捷方式。&lt;strong&gt;@PostMapping @PutMapping @DeleteMapping @PatchMapping&lt;/strong&gt;这几个注解与其类似，用于处理不同的请求。&lt;/p&gt;

&lt;h3 id=&#34;controller&#34;&gt;@Controller&lt;/h3&gt;

&lt;p&gt;@Controller是@Component注解的一个延伸，Spring会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。 &lt;strong&gt;一般直接使用@RestController&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;restcontroller&#34;&gt;@RestController&lt;/h3&gt;

&lt;p&gt;@RestController是在Spring 4.0开始引入的，这是一个特定的控制器注解。此注解相当于@Controller和@ResponseBody的快捷方式。当使用此注解时，不需要再在方法上使用@ResponseBody注解。&lt;/p&gt;

&lt;h3 id=&#34;exceptionhandler&#34;&gt;@ExceptionHandler&lt;/h3&gt;

&lt;p&gt;用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被@ExceptionHandler标注的方法。&lt;/p&gt;

&lt;h3 id=&#34;responsestatus&#34;&gt;@ResponseStatus&lt;/h3&gt;

&lt;p&gt;可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(UserNotFoundExceptin.class)
public RespnseEntity&amp;lt;Object&amp;gt; userNotFoundExceptionHandler(UserNotFoundException ex, WebRequest request) {
	UserErrorDetail detail = new UserErrorDetail(new Date(), ex.getMessage(), request.getDescription(false));

	return new ResponseEntity&amp;lt;&amp;gt;(detail, HttpStatus.NOT_FOUND);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;controlleradvice&#34;&gt;@ControllerAdvice&lt;/h3&gt;

&lt;p&gt;@ControllerAdvice是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。@ControllerAdvice需要和@ExceptionHandler、@InitBinder以及@ModelAttribute注解搭配使用，主要是用来处理控制器所抛出的异常信息。首先，我们需要定义一个被@ControllerAdvice所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。此外，在有必要的时候，可以使用@InitBinder在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用@ControllerAdvice注解，就可以快速的创建统一的，自定义的异常处理类。&lt;/p&gt;

&lt;h3 id=&#34;modelattribute&#34;&gt;@ModelAttribute&lt;/h3&gt;

&lt;p&gt;通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。与@PathVariable和@RequestParam注解一样，如果参数名与模型具有相同的名字，则不必指定索引名称。如果使用@ModelAttribute对方法进行标注，Spring会将方法的返回值绑定到具体的Model上。在Spring调用具体的处理方法之前，被@ModelAttribute注解标注的所有方法都将被执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostMapping(&amp;quot;/users&amp;quot;)
public void createUser(@ModelAttribute User user) {
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;crossorigin&#34;&gt;@CrossOrigin&lt;/h3&gt;

&lt;p&gt;将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CrossOrigin
@PostMapping(&amp;quot;/users&amp;quot;)
public void createUser(@ModelAttribute User user) {
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initbinder&#34;&gt;@InitBinder&lt;/h3&gt;

&lt;p&gt;用于标注初始化WebDataBinider的方法，该方法用于对Http请求传递的表单数据进行处理，如时间格式化、字符串处理等。&lt;/p&gt;

&lt;h2 id=&#34;spring-bean&#34;&gt;Spring Bean&lt;/h2&gt;

&lt;h3 id=&#34;componentscan&#34;&gt;@ComponentScan&lt;/h3&gt;

&lt;p&gt;用于配置Spring需要扫描的被组件注解注释的类所在的包。可以通过配置其basePackages属性或者value属性来配置需要扫描的包路径。value属性是basePackages的别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages=&amp;quot;cn.wishhust.domain&amp;quot;)
public class componnetCofig(){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;component&#34;&gt;@Component&lt;/h3&gt;

&lt;p&gt;用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。&lt;/p&gt;

&lt;h3 id=&#34;service&#34;&gt;@Service&lt;/h3&gt;

&lt;p&gt;是@Component的一个延伸（特例），它用于标注业务逻辑类。与@Component注解一样，被此注解标注的类，会自动被Spring所管理。&lt;/p&gt;

&lt;h3 id=&#34;repository&#34;&gt;@Repository&lt;/h3&gt;

&lt;p&gt;是@Component注解的延伸，与@Component注解一样，被此注解标注的类会被Spring自动管理起来，@Repository注解用于标注DAO层的数据持久化类。&lt;/p&gt;

&lt;h2 id=&#34;spring-di-scope&#34;&gt;Spring DI &amp;amp; Scope&lt;/h2&gt;

&lt;h3 id=&#34;dependson&#34;&gt;@DependsOn&lt;/h3&gt;

&lt;p&gt;可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。&lt;/p&gt;

&lt;h3 id=&#34;bean&#34;&gt;@Bean&lt;/h3&gt;

&lt;p&gt;主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。&lt;/p&gt;

&lt;h3 id=&#34;scope&#34;&gt;@Scope&lt;/h3&gt;

&lt;p&gt;@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：singleton、prototype、request、session、globalSession或者其他的自定义范围。&lt;/p&gt;

&lt;p&gt;当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。在默认情况下，Spring IoC容器所初始化的类实例都为singleton。&lt;/p&gt;

&lt;h2 id=&#34;容器配置注解&#34;&gt;容器配置注解&lt;/h2&gt;

&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;

&lt;p&gt;@Autowired注解用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。&lt;/p&gt;

&lt;h3 id=&#34;primary&#34;&gt;@Primary&lt;/h3&gt;

&lt;p&gt;当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。&lt;/p&gt;

&lt;h3 id=&#34;qualifier&#34;&gt;@Qualifier&lt;/h3&gt;

&lt;p&gt;当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。&lt;/p&gt;

&lt;h2 id=&#34;spring-boot注解&#34;&gt;Spring Boot注解&lt;/h2&gt;

&lt;h3 id=&#34;springbootapplication&#34;&gt;@SpringBootApplication&lt;/h3&gt;

&lt;p&gt;@SpringBootApplication注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于@Configuration、@EnableAutoConfiguration和@ComponentScan的组合。在Spring Boot应用程序的主类中，就使用了此注解。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class Application{
 public static void main(String [] args){
   SpringApplication.run(Application.class,args);
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enableautoconfiguration&#34;&gt;@EnableAutoConfiguration&lt;/h3&gt;

&lt;p&gt;@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。&lt;/p&gt;

&lt;p&gt;@ConditionalOnClass与@ConditionalOnMissingClass&lt;/p&gt;

&lt;p&gt;这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass(DataSource.class)
class MySQLAutoConfiguration {
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonbean与-conditionalonmissingbean&#34;&gt;@ConditionalOnBean与@ConditionalOnMissingBean&lt;/h3&gt;

&lt;p&gt;这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalOnBean(name=&amp;quot;dataSource&amp;quot;)
LocalContainerEntityManagerFactoryBean entityManagerFactory(){
 //...
}
@Bean
@ConditionalOnMissingBean
public MyBean myBean(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonproperty&#34;&gt;@ConditionalOnProperty&lt;/h3&gt;

&lt;p&gt;@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalOnProperty(name=&amp;quot;alipay&amp;quot;,havingValue=&amp;quot;on&amp;quot;)
Alipay alipay(){
 return new Alipay();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonresource&#34;&gt;@ConditionalOnResource&lt;/h3&gt;

&lt;p&gt;此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnResource(resources = &amp;quot;classpath:website.properties&amp;quot;)
Properties addWebsiteProperties(){
 //...
}
@ConditionalOnWebApplication与@ConditionalOnNotWebApplication
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnWebApplication
HealthCheckController healthCheckController(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalexpression&#34;&gt;@ConditionalExpression&lt;/h3&gt;

&lt;p&gt;此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalException(&amp;quot;${localstore} &amp;amp;&amp;amp; ${local == &#39;true&#39;}&amp;quot;)
LocalFileStore store(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditional&#34;&gt;@Conditional&lt;/h3&gt;

&lt;p&gt;@Conditional注解可以控制更为复杂的配置条件。在Spring内置的条件控制注解不满足应用需求的时候，可以使用此注解定义自定义的控制条件，以达到自定义的要求。下面是使用该注解的简单示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Conditioanl(CustomConditioanl.class)
CustomProperties addCustomProperties(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>意向锁</title>
      <link>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</link>
      <pubDate>Sat, 20 Jul 2019 22:31:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</guid>
      <description>

&lt;h3 id=&#34;封锁粒度&#34;&gt;封锁粒度&lt;/h3&gt;

&lt;p&gt;一般有两种封锁粒度：&lt;strong&gt;行级锁以及表级锁&lt;/strong&gt;。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。&lt;/p&gt;

&lt;h3 id=&#34;读写锁&#34;&gt;读写锁&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;排它锁（Exclusive），简写为 X 锁，又称写锁。&lt;/li&gt;
&lt;li&gt;共享锁（Shared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
&lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;意向锁&#34;&gt;意向锁&lt;/h3&gt;

&lt;p&gt;使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。&lt;strong&gt;意向锁是一种不与行级锁冲突表级锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系(特别说明，以下是&lt;strong&gt;表锁&lt;/strong&gt;直接的兼容关系)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;IX&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;IS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意向锁不会与行级的共享 / 排他锁互斥。IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;

&lt;p&gt;用户表user：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;lisi&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;wangwu&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务A，更新id为2的用户名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取user表上的IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取id=2数据行的X锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务B，查询user表&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;检查到user表上用IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务B加锁请求阻塞。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务C，更新id为1的用户名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取user表的IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检测到user表有IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;意向锁不排斥，故事务C获得IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;id=1不存在其他行级锁，获取行级X锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说明：若无意向锁，则对于事务B，将要查询表中的行来确定是否存在其他行级锁。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 06 Jul 2019 23:15:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</guid>
      <description>

&lt;h3 id=&#34;一-定义&#34;&gt;一、定义&lt;/h3&gt;

&lt;p&gt;反射（reflection）是java的特征之一，它允许允许中的Java程序获取自身的信息，并且可以操作累或对象的内部属性。&lt;/p&gt;

&lt;h3 id=&#34;二-基本运用&#34;&gt;二、基本运用&lt;/h3&gt;

&lt;p&gt;反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。反射相关的类一般都在 java.lang.relfect 包里。&lt;/p&gt;

&lt;h4 id=&#34;1-获取class对象&#34;&gt;1. 获取Class对象&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo01 {
    public static void main(String[] args) throws Exception{
        String str = new String();
        // 1.通过对象的getClass方法获得
        Class strClass = str.getClass();
        System.out.println(strClass.getName());

        // 2.通过class属性获得
        // 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
        Class strClass2 = String.class;
        System.out.println(strClass2.getName());
        System.out.println(strClass2 == strClass);

        // 3.使用Class类的forName静态方法
        // 注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
        try{
            Class strClass3 = Class.forName(&amp;quot;java.lang.String&amp;quot;);
            System.out.println(strClass3 == strClass2);
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));

        System.out.println(strClass instanceof Object);

    }

}

// 结果：
java.lang.String
java.lang.String
true
true
true
true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;获取Class对象的三种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用某个对象的getClass方法；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接获取某个类型的class属性：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Class类的forName静态方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：在运行期间，一个类，只有一个Class对象产生。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-判断是否为某个类的实例&#34;&gt;2. 判断是否为某个类的实例&lt;/h4&gt;

&lt;p&gt;一般使用instanceof关键字判断是否为某个类的实例，也可以使用反射中Class对象的isInstance()方法（native方法）判断是否为某个类的实例，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));
System.out.println(strClass instanceof Object);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-创建实例&#34;&gt;3. 创建实例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建实例
// 1. newInstance()
String string = (String) strClass.newInstance();
System.out.println(string);

// 2. 先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。
// 这种方法可以指定构造器的实例。
Constructor constructor = strClass.getConstructor(String.class);
String string2 = (String) constructor.newInstance(&amp;quot;23333&amp;quot;);
System.out.println(string2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Class对象的newInstance()方法来创建Class对象对应类的实例。&lt;/li&gt;
&lt;li&gt;先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-获取方法&#34;&gt;4. 获取方法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo02 {

    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; clazz = MethodClass.class;

        // 创建类实例
        Object obj = clazz.newInstance();


        // 获取所有共有方法, 包括继承
        Method[] methods = clazz.getMethods();
        for (Method m : methods) {
            System.out.println(m);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取所有私有方法，不包括继承
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for (Method dm : declaredMethods) {
            System.out.println(dm);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法
        Method add = clazz.getMethod(&amp;quot;add&amp;quot;, int.class, int.class);
        // 调用方法 （要先创建实例对象）
        Object r = add.invoke(obj, 1, 1);
        System.out.println(r);
        System.out.println(add);

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法(私有)
        Method sub = clazz.getDeclaredMethod(&amp;quot;sub&amp;quot;, int.class, int.class);
        sub.setAccessible(true);
        Object result = sub.invoke(obj,12, 2);
        System.out.println(result);

    }


}

class MethodClass {
    public int add(int a, int b) {
        return a + b;
    }
    private int sub(int a, int b){
        return a - b;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getDeclaredMethod()方法可以获取特定的私有方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethod()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>算法016</title>
      <link>https://pallcard.github.io/2019/algorithm016/</link>
      <pubDate>Sat, 06 Jul 2019 17:35:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm016/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;正则表达式匹配问题&lt;/p&gt;

&lt;p&gt;请实现一个函数用来匹配包括 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;&lt;em&gt;&amp;rsquo; 的正则表达式。模式中的字符 &amp;lsquo;.&amp;rsquo; 表示任意一个字符，而 &amp;lsquo;&lt;/em&gt;&amp;rsquo; 表示它前面的字符可以出现任意次（包含 0 次）。&lt;/p&gt;

&lt;p&gt;. 一个任意字符&lt;/p&gt;

&lt;p&gt;* 表示*前字符出现（0-？）字符&lt;/p&gt;

&lt;p&gt;aaa
ab*ac*a  a.a&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;采用两个下标，分别记录目标串与模式串。
循环模式串，若为.，则下标加1；
若为模式串与目标串字符相同，则下标加1，否则看模式串下一个字符算法为*；&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo016 {
    public static void main(String[] args) {
        String string = &amp;quot;aaa&amp;quot;;
        String pattern = &amp;quot;ab*a&amp;quot;;

        int index = 0;
        int i = 0;
        boolean result = true;

        for (i = 0; i &amp;lt; pattern.length(); i++) {
            if (index &amp;gt;= string.length()) {
                result = false;
                break;
            }
            if (pattern.charAt(i) == &#39;.&#39;) {
                index++;
                continue;
            }
            if(pattern.charAt(i) == string.charAt(index)) {
                index++;
            } else if(pattern.charAt(i+1) != &#39;*&#39;) {
                result = false;
                break;
            } else if (pattern.charAt(i+1) == &#39;*&#39;) {
                i++;
            }
        }
        if(index != string.length() || i != pattern.length()) {
            result = false;
        }
        System.out.println(result);
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法015</title>
      <link>https://pallcard.github.io/2019/algorithm015/</link>
      <pubDate>Sat, 06 Jul 2019 17:32:45 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm015/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;二进制中1的个数&lt;/p&gt;

&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;n&amp;amp;(n-1)会去除掉n的位级表示中的最低的一位&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo015 {

    public static int numberOf1(int n) {
        int count = 0;

        if (n == 0) {
            return 0;
        }

        while (n != 0) {
            count++;
            n &amp;amp;= (n-1);
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(numberOf1(10));
        System.out.println(Integer.bitCount(10));
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法014</title>
      <link>https://pallcard.github.io/2019/algorithm014/</link>
      <pubDate>Sat, 06 Jul 2019 17:24:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm014/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;剪绳子&lt;/p&gt;

&lt;p&gt;把一根绳子剪成多段（&amp;gt;1），并使得所得到每段绳子的长度之积最大。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	n(绳长)
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;方法一：
&lt;strong&gt;贪婪算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使得所得到的绳子中&lt;strong&gt;3&lt;/strong&gt;的数量最多，1的数量最少（没有）&lt;/p&gt;

&lt;p&gt;方法二：
&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义 f(n) : 最大乘积，f(n) = max{f(i)*f(n-i)}&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo014 {

    // 贪婪算法
    public static int maxLength(int n) {
        if (n &amp;lt; 2) {
            return 0;
        } else if (n == 2) {
            return 1;
        } else if (n == 3) {
            return 2;
        } else {
            if (n%3==1){
                return (int) Math.pow(3, n/3-1)*4;
            } else if(n%3==0) {
                return (int) Math.pow(3, n/3);
            } else {
                return (int) Math.pow(3, n/3)*2;
            }
        }
    }

    // 动态规划
    // 定义 f(n) : 最大乘积
    // f(n) = max{f(i)*f(n-i)}
    public static int dp(int n) {
        if (n &amp;lt; 2) {
            return 0;
        } else if (n == 2) {
            return 1;
        } else if (n == 3) {
            return 2;
        } else {
            int [] dp = new int [n+1];
            // 分割绳子长度1，2，3，具体动态规划从4开始计算
            // dp[i]数组,绳子长度为i时，乘积最大值
            dp[1] = 1;
            dp[2] = 2;
            dp[3] = 3;
            int max = 0;
            // 存放中间值
            int temp = 0;
            for (int i = 4; i &amp;lt;= n; i++) {
                max = 0;
                // i/2 对于绳子i的切分，j*(i-j) 与 (i-j)*j结果一样
                for (int j = 1; j &amp;lt;= i / 2; j++) {
                    temp = dp[j] * dp[i-j];
                    if (temp &amp;gt; max) {
                        max = temp;
                    }
                }
                dp[i] = max;
            }
            return dp[n];
        }
    }

    public static void main(String[] args) {
        System.out.println(maxLength(11));
        System.out.println(dp(11));
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 06 Jul 2019 09:10:02 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>

&lt;h3 id=&#34;一-简介&#34;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;正则表达式用于文本内容的查找和替换。在线工具&lt;a href=&#34;https://regexr.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://regexr.com/&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;回退&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;换页符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;换行符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;回车符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;制表符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直制表符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\d&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数字字符，等价于 [0-9]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\w&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\s&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;任何一个空白字符，等价于 [\f\n\r\t\v]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\l&lt;/td&gt;
&lt;td&gt;把下个字符转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\u&lt;/td&gt;
&lt;td&gt;把下个字符转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\L&lt;/td&gt;
&lt;td&gt;把\L 和\E 之间的字符全部转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\U&lt;/td&gt;
&lt;td&gt;把\U 和\E 之间的字符全部转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\E&lt;/td&gt;
&lt;td&gt;结束\L 或者\U&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明:
\D,\W,\S是对上述3个的取非；&lt;/p&gt;

&lt;h3 id=&#34;二-匹配单个字符&#34;&gt;二、匹配单个字符&lt;/h3&gt;

&lt;p&gt;.可以用来&lt;strong&gt;匹配任意单个字符&lt;/strong&gt;，但是在绝大多数实现里面，不能匹配换行符；&lt;/p&gt;

&lt;p&gt;. 是&lt;strong&gt;元字符&lt;/strong&gt;，表示它有特殊的含义，而不是字符本身的含义。若要匹配.使用\.&lt;/p&gt;

&lt;h3 id=&#34;三-匹配一组字符&#34;&gt;三、匹配一组字符&lt;/h3&gt;

&lt;p&gt;[]定义&lt;strong&gt;一个字符集合&lt;/strong&gt;；
0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。&lt;/p&gt;

&lt;p&gt;- 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；&lt;/p&gt;

&lt;p&gt;^ 在 [ ] 中是取非操作。&lt;/p&gt;

&lt;h3 id=&#34;四-重复匹配&#34;&gt;四、重复匹配&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;+ 匹配 1 个或者多个字符&lt;/li&gt;
&lt;li&gt;* 匹配 0 个或者多个&lt;/li&gt;
&lt;li&gt;? 匹配 0 个或者 1 个&lt;/li&gt;
&lt;li&gt;{n} 匹配 n 个字符&lt;/li&gt;
&lt;li&gt;{m, n} 匹配 m~n 个字符&lt;/li&gt;
&lt;li&gt;{m,} 至少匹配 m 个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
(1)    a.+c
(2)    a.+?c
target:
    abcabcabccc
第一个正则会匹配到abcabcabccc，有1个匹配
第二个正则会匹配到abc abc abc，有3个匹配
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;五-位置匹配&#34;&gt;五、位置匹配&lt;/h3&gt;

&lt;h4 id=&#34;单词边界&#34;&gt;单词边界&lt;/h4&gt;

&lt;p&gt;\b 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；\B 匹配一个不是单词边界的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    \Babc\b
target:
    aabc
    aabc1
第一个目标串可以匹配到abc
第一个目标串不能匹配
说明abc前面要有字母、数字或下划线，abc后面不能有字母、数字或下划线
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;字符串边界&#34;&gt;字符串边界&lt;/h4&gt;

&lt;p&gt;^ 匹配整个字符串的开头，$ 匹配结尾。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分行匹配模式（multiline）下，换行被当做字符串的边界。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    ^\s*\/\/.*$
target:
    // 注释
    
说明匹配代码中以 // 开始的注释行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;六-子表达式&#34;&gt;六、子表达式&lt;/h3&gt;

&lt;p&gt;使用 ( ) 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。可以嵌套。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    (ab){2,}
target:
    ababab
说明:匹配2个以上ab组成的字符串

regexr:
    (19|20)/d{2}
target:
    1900
说明：匹配19或20后面两个数的字字符串

例子：匹配IP地址
IP地址每部分都是0-255，
将其划分为一下5个部分
0-9
10-99
100-199
200-249
250-255
故0-255的正则是 ((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))

regexr:
    (((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))
target:
    1.1.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;七-回溯引用&#34;&gt;七、回溯引用&lt;/h3&gt;

&lt;p&gt;回溯引用使用 &lt;strong&gt;\n&lt;/strong&gt; (n为数字) 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    &amp;lt;(h[1-6])&amp;gt;\w*?&amp;lt;\/\1&amp;gt;
target:
    &amp;lt;h1&amp;gt;x&amp;lt;/h1&amp;gt;
说明：匹配html中标题元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;八-前后查找&#34;&gt;八、前后查找&lt;/h3&gt;

&lt;p&gt;向前查找用 ?= 来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    \w+(?=@)
target:
    abc@qq.com
说明：查找出邮件地址 @ 字符前面的部分。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;九-在java中使用&#34;&gt;九、在Java中使用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        String str = &amp;quot;&amp;lt;h1&amp;gt;test&amp;lt;/h1&amp;gt;&amp;quot;;
        boolean result = str.matches(&amp;quot;&amp;lt;(h[1-6])&amp;gt;\\w*?&amp;lt;\\/\\1&amp;gt;&amp;quot;);
        System.out.println(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法013</title>
      <link>https://pallcard.github.io/2019/algorithm013/</link>
      <pubDate>Fri, 05 Jul 2019 08:22:30 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm013/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;机器人的运动范围&lt;/p&gt;

&lt;p&gt;地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。&lt;/p&gt;

&lt;p&gt;例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	m(行数) n(列数) k(阀值)
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;先将数组中的值计算按位出来存入数组，使用深度优先遍历，将经过的格子中的值置k+1，使用count记录所有走过的格子。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo013 {

    // 左 上 右 下
    public static int [][] direct = new int [][]
            {{0,-1},{-1,0},{0,1},{1,0}};

    public static int count = 0;
    public static int m = 11;
    public static int n = 11;
    public static int k = 10;


    public static void main(String[] args) {
        int [][] array = new int[m][n];
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                int i_temp = i;
                int j_temp = j;
                // 处理数位
                int i_sum = i_temp%10;
                int j_sum = j_temp%10;

                i_temp /= 10;
                j_temp /= 10;
                while (i_temp &amp;gt; 0){
                    i_sum += i_temp%10;
                    i_temp /= 10;
                }
                while (j_temp &amp;gt; 0) {
                    j_sum += j_temp%10;
                    j_temp /= 10;
                }
                array[i][j] = i_sum+j_sum;
            }
        }
        count++;
        array[0][0] = k + 1;
        DPsearch(array,0,0);
        System.out.println(count);
    }

    public static void DPsearch(int [][] array, int x, int y) {
        for (int i = 0; i &amp;lt; 4; i++) {
            if (x + direct[i][0] &amp;gt;= 0
                    &amp;amp;&amp;amp; x + direct[i][0] &amp;lt; m
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;gt;= 0
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;lt; n) {
                x += direct[i][0];
                y += direct[i][1];

                if(array[x][y] &amp;lt;= k) {
                    // 走过的格子失效
                    array[x][y] = k + 1;
                    count++;
                    DPsearch(array,x,y);
                }

                // x,y 坐标还原
                x -= direct[i][0];
                y -= direct[i][1];
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法012</title>
      <link>https://pallcard.github.io/2019/algorithm012/</link>
      <pubDate>Thu, 04 Jul 2019 22:28:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm012/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;矩阵中的路径
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;先将所给一维数组转化为二维数组，找到目标字符串首个字符所在位置。然后进行深度递归匹配目标字符串。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo012 {

    public static void main(String[] args) {
        char[] matrix = new char[]{&#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;s&#39;, &#39;f&#39;, &#39;c&#39;, &#39;s&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;e&#39;};
        int rows = 3;
        int cols = 4;
        char [] target = new char[]{&#39;b&#39;,&#39;f&#39;,&#39;c&#39;,&#39;e&#39;};

        char[][] array = new char[3][4];
        int index = 0;
        int x = 0, y = 0;
        for (int i = 0; i &amp;lt; rows; i++) {
            for (int j = 0; j &amp;lt; cols; j++) {
                array[i][j] = matrix[index++];

            }
        }

        boolean result = false;
        for (int i = 0; i &amp;lt; rows; i++) {
            for (int j = 0; j &amp;lt; cols; j++) {
                if (array[i][j] == target[0]) {
                    result = search(array,i,j,target,1);
                    if (result) {
                        System.out.println(result);
                        return;
                    }
                }
            }
        }

        System.out.println(result);

    }
    // 左 上 右 下
    public static int [][] direct = new int [][]
            {{0,-1},{-1,0},{0,1},{1,0}};

    public static boolean search(char[][] array, int x, int y, char [] target, int index) {
        for (int i = 0; i &amp;lt; 4; i++) {
            if (x + direct[i][0] &amp;gt;= 0
                    &amp;amp;&amp;amp; x + direct[i][0] &amp;lt; 3
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;gt;= 0
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;lt; 4) {
                x += direct[i][0];
                y += direct[i][1];
                if (array[x][y] == target[index] &amp;amp;&amp;amp; target.length == index+1) {
                    return true;
                } else if (array[x][y] == target[index]) {
                    return search(array,x,y,target,++index);
                }
                // x,y 坐标还原
                x -= direct[i][0];
                y -= direct[i][1];
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法011</title>
      <link>https://pallcard.github.io/2019/algorithm011/</link>
      <pubDate>Thu, 04 Jul 2019 21:12:50 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm011/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;旋转数组(非递减)的最小数&lt;/p&gt;

&lt;p&gt;把一个数组最开始的若干位搬到数组的末尾，称为旋转数组。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;采用二分的方式来处理，&lt;/p&gt;

&lt;p&gt;正常情况&lt;/p&gt;

&lt;p&gt;4 5 6 7 1 2，分成两部分4 5 6，7 1 2；可知4 5 6为非递减数列，7 1 2为旋转数组，故结果在循环数组中，可以去掉另外一半数组；&lt;/p&gt;

&lt;p&gt;两种特殊情况：&lt;/p&gt;

&lt;p&gt;（1）1 1 1 1 0 1，num[left] == num[mid] == num[right],此时无法分区，故只能遍历&lt;/p&gt;

&lt;p&gt;（2）4 5 6 1 2 3，分区后两个部分均为非递减数组，则返回num[left]和num[mid+1]中较小的数即可。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo011 {
    public static void main(String[] args) {
        int [] arr = new int[] {1,1,1,0,1};
        System.out.println(searchMin(arr,arr.length));
    }

    public static int searchMin(int [] array, int length) {
        int left = 0, right = length - 1;
        int mid = (left + right) / 2;
        while(left &amp;lt; right) {
            // 分区间后刚好左右都为非递减数组
            if(array[left] &amp;lt; array[mid] &amp;amp;&amp;amp; array[mid+1] &amp;lt; array[right]) {
                if (array[left] &amp;gt; array[mid+1]) {
                    left = mid+1;
                }
                break;
            }
            // 无法分区间情况
            if (array[left] == array[mid] &amp;amp;&amp;amp; array[mid] == array[right]) {
                int minIndex = left;
                for (int i = left; i &amp;lt;= right; i++) {
                    if (array[minIndex] &amp;gt; array[i]) {
                        minIndex = i;
                    }
                }
                left = minIndex;
                break;
            }
            // 正常分区间
            if (array[left] &amp;lt; array[mid]) {
                // 左侧为非递减数组，右侧为旋转数组==&amp;gt;取右侧
                left = mid+1;
            } else {
                // 取左侧
                right = mid - 1;
            }
        }
        return array[left];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法010</title>
      <link>https://pallcard.github.io/2019/algorithm010/</link>
      <pubDate>Thu, 04 Jul 2019 21:08:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm010/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;变态跳青蛙&lt;/p&gt;

&lt;p&gt;青蛙可以跳1，2，3，，，n阶。问跳到n有多少种不同方法。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;f(n) = f(n-1) + f(n-2) + ,,, + f(0)

f(n-1) = f(n-2) + f(n-3) + ,,, + f(0)

==&amp;gt;  f(n) = 2 * f(n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo010 {

    public static void main(String[] args) {
        System.out.println(jumpFloor(3));
        System.out.println(jumpFloor2(3));
    }

//    f(0) = 1
//    f(1) = 1
//    f(2) = 2
//    f(3) = 4
    public static int jumpFloor(int target) {
        int [] dp = new int[target];
        Arrays.fill(dp,1);  // 数组所有元素置1（相当于所有元素+f(0)）
        for (int i = 1; i &amp;lt; target; i++) {
            for (int j = 0; j &amp;lt; i; j++) {
                dp[i] += dp[j];
            }
        }
        return dp[target-1];
    }

    public static int jumpFloor2(int target) {
        return (int) Math.pow(2, target-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法009</title>
      <link>https://pallcard.github.io/2019/algorithm009/</link>
      <pubDate>Thu, 04 Jul 2019 21:01:25 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm009/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;斐波那契数列，
*  应用1：矩形覆盖,n个2*1小矩形覆盖2*n的大矩形，有多少种方法
*  应用2：跳台阶,可以跳1列或者2列，跳n阶有多少种方法&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;f(n) = n;  n = 0,1

f(n) = f(n-1) + f(n-2); n &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方法一：递归实现&lt;/p&gt;

&lt;p&gt;方法二：使用一个数组存放所用的数据&lt;/p&gt;

&lt;p&gt;方法三：发现第n项只与相邻的前两项有关，故只用存储前两项数据即可。&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo009 {

    public static void main(String[] args) {
        System.out.println(fibonacci(10));
        System.out.println(fibonacci2(10));
        System.out.println(fibonacci3(10));
    }


    public static int fibonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else
            return  fibonacci(n-1) + fibonacci(n-2);
    }

//    0 1 2 3 4 5 6 7  8  9  10
//    0 1 1 2 3 5 8 13 21 34 55
    public static int fibonacci2(int n) {
        if (n &amp;lt;= 1) {
            return n;
        }
        int [] fib = new int[n+1];
        fib[0] = 0;
        fib[1] = 1;
        for (int i = 2; i &amp;lt;= n; i++) {
            fib[i] = fib[i-1] + fib[i-2];
        }
        return fib[n];
    }

    public static int fibonacci3(int n) {
        if (n &amp;lt;= 1) {
            return n;
        }
        int temp1 = 0, temp2 = 1;
        int result = 0;
        for (int i = 2; i &amp;lt;= n; i++) {
            result = temp1 + temp2;
            temp1 = temp2;
            temp2 = result;
        }
        return result;
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JMM例子</title>
      <link>https://pallcard.github.io/2019/jmm%E4%BE%8B%E5%AD%90/</link>
      <pubDate>Mon, 01 Jul 2019 22:26:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm%E4%BE%8B%E5%AD%90/</guid>
      <description>&lt;p&gt;例子1，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo001 {
    private static boolean initFlag = false;
//    private static volatile boolean initFlag = false;

    public static void main(String[] args) throws InterruptedException {
        // 线程1
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;等待数据准备&amp;quot;);
                while (!initFlag) {}
                System.out.println(&amp;quot;数据准备完毕，执行程序逻辑&amp;quot;);
            }
        }).start();

        Thread.sleep(2000);
        // 线程2
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;数据准备中。。。&amp;quot;);
                initFlag = true;
                System.out.println(&amp;quot;数据准备完成&amp;quot;);
            }
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/jmm003.png&#34; alt=&#34;initFlag无volatile关键字修饰时&#34; /&gt;&lt;/p&gt;

&lt;p&gt;initFlag无volatile关键字修饰时，线程1将initFlag从主内存读入到工作内存，线程1一直循环，线程2将initFlag从主内存读入到工作内存，并通过线程执行引擎对initFlag进行修改，然后写回到主内存中，但是线程1中的initFlag仍然是工作内存中的值，线程1无法感知到其他内存对该共享变量的修改，故会一直循环下去。&lt;strong&gt;缓存一致性问题&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;缓存一致性问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;总线加锁（性能太低）&lt;/strong&gt;
cpu从主内存读取数据到高速缓存，会在总线对该数据加锁，这样其他cpu无法读或写该数据，直到cpu使用完数据并释放锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;MESI缓存一致性协议&lt;/strong&gt;
多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存中的数据时，该数据马上同步到主内存中，其他cpu通过&lt;strong&gt;总线嗅探机制&lt;/strong&gt;感知到变化从而将自己缓存里数据失效。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Volatile缓存可见性&lt;/strong&gt;实现原理底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存并回写到主内存，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/jmm004.png&#34; alt=&#34;initFlag有volatile关键字修饰时&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例子2，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo002 {

    //volatile 不能解决原子性问题
    public static volatile int num = 0;

    public static void increase() {
        num++; // 非原子操作
    }

    public static void main(String[] args) throws InterruptedException {
        final Thread[] threads = new Thread[10];
        for (int i = 0; i &amp;lt; threads.length; i++) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j &amp;lt; 1000; j++) {
                        increase();
                    }
                }
            });
            threads[i].start();
        }
        for(Thread t : threads) {
            t.join();
        }
        System.out.println(num);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://pallcard.github.io/images/jmm005.png&#34; alt=&#34;原子性&#34; /&gt;&lt;/p&gt;

&lt;p&gt;（说明代码中存在的问题，以两个线程为例）初始时，主内存中num=0，然后线程1和2将其读到各自的工作内存中，然后在各自的执行引擎中进行num++,此时工作内存num=1，若线程1先将num写回到主内存中，线程2的cpu通过主线嗅探机制使得其工作内存中的值失效，然后从主内存中读到num=1，但是线程2已经执行了一次num++，期望的结果应该是num=2，但是实际上结果为1。&lt;strong&gt;volatile不能保证数据的原子性。&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mybaits</title>
      <link>https://pallcard.github.io/2019/mybaits/</link>
      <pubDate>Thu, 20 Jun 2019 19:00:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mybaits/</guid>
      <description>

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;整个实验使用Maven 来管理项目，编译器IDEA，github仓库 &lt;a href=&#34;https://github.com/pallcard/mybatis&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/pallcard/mybatis&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&#34;jdbc连接数据库&#34;&gt;JDBC连接数据库&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;1.引入依赖（pom.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependencies&amp;gt;
	&amp;lt;dependency&amp;gt;
	    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;5.1.32&amp;lt;/version&amp;gt;
	&amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明：（pom.xml）&lt;/strong&gt;
Maven 项目默认编译项目为JDK 1.5，通过引入以下依赖来指定Maven 编译版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;build&amp;gt;
	  &amp;lt;plugins&amp;gt;
	        &amp;lt;plugin&amp;gt;
	            &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	            &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
	            &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
	            &amp;lt;configuration&amp;gt;
	                &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
	                &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
	            &amp;lt;/configuration&amp;gt;
	        &amp;lt;/plugin&amp;gt;
	  &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.JDBC测试类JDBCTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JDBCTest {
    public static void main(String[] args) throws Exception {
        Connection connection = null;
        PreparedStatement prepareStatement = null;
        ResultSet rs = null;

        try {
            // 加载驱动(每次加载驱动，驱动名硬编码)
            Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
            // 获取连接(每次获取连接，连接信息硬编码)
            String url = &amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo&amp;quot;;
            String user = &amp;quot;root&amp;quot;;
            String password = &amp;quot;&amp;quot;;
            connection = DriverManager.getConnection(url, user, password);
            // 获取statement，preparedStatement （sql和java代码耦合）
            String sql = &amp;quot;select * from tb_user where id=?&amp;quot;;
            prepareStatement = connection.prepareStatement(sql);
            // 设置参数（参数类型手动判断、设置）
            prepareStatement.setLong(1, 1l);
            // 执行查询
            rs = prepareStatement.executeQuery();
            // 处理结果集（结果集中数据类型、下标、列名要手动判断）
            while (rs.next()) {
                System.out.println(rs.getString(&amp;quot;user_name&amp;quot;));
                System.out.println(rs.getString(&amp;quot;name&amp;quot;));
                System.out.println(rs.getInt(&amp;quot;age&amp;quot;));
                System.out.println(rs.getDate(&amp;quot;birthday&amp;quot;));
            }
        } finally {
            //（每次都要打开或关闭连接，浪费资源）
            // 关闭连接，释放资源
            if (rs != null) {
                rs.close();
            }
            if (prepareStatement != null) {
                prepareStatement.close();
            }
            if (connection != null) {
                connection.close();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mybaits整体架构&#34;&gt;Mybaits整体架构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190620231844983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyZmljaWFsS25vd2xlZGdl,size_16,color_FFFFFF,t_70&#34; alt=&#34;Mybaits整体架构&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;mybaits快速入门&#34;&gt;Mybaits快速入门&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.引入依赖（pom.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--mybatis--&amp;gt;
&amp;lt;dependency&amp;gt;
     &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
     &amp;lt;version&amp;gt;3.2.8&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&amp;lt;!--引入日志依赖包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.User.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class User {
    private int id;
    private String userName;
    private String password;
    private String name;
    private Integer age;
    private Integer sex;
    private Date birthday;
    private String created;
    private String updated;
	// get、set、toString省
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;添加log4j.properties&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;log4j.rootLogger=DEBUG,A1
log4j.logger.org.apache=DEBUG
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.全局配置文件（mybatis-config.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &amp;quot;-//mybatis.org//DTD Config 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;quot;&amp;gt;
&amp;lt;!-- 根标签 --&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo?useUnicode=true&amp;amp;amp;characterEncoding=utf-8&amp;amp;amp;allowMultiQueries=true&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;quot;/&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!-- 环境，可以配置多个，default：指定采用哪个环境 --&amp;gt;
    &amp;lt;environments default=&amp;quot;test&amp;quot;&amp;gt;
        &amp;lt;!-- id：唯一标识 --&amp;gt;
        &amp;lt;environment id=&amp;quot;test&amp;quot;&amp;gt;
            &amp;lt;!-- 事务管理器，JDBC类型的事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot; /&amp;gt;
            &amp;lt;!-- 数据源，池类型的数据源 --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo?useUnicode=true&amp;amp;amp;characterEncoding=utf-8&amp;amp;amp;allowMultiQueries=true&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;&amp;quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
        &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
            &amp;lt;!-- 事务管理器，JDBC类型的事务管理器 --&amp;gt;
            &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot; /&amp;gt;
            &amp;lt;!-- 数据源，池类型的数据源 --&amp;gt;
            &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot; /&amp;gt; &amp;lt;!-- 配置了properties，所以可以直接引用 --&amp;gt;
                &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot; /&amp;gt;
                &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot; /&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.配置Map.xml（UserMapper.xml）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mappers:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;UserMapper&amp;quot;&amp;gt;
    &amp;lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一
       resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表
     --&amp;gt;
    &amp;lt;select id=&amp;quot;selectUser&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.first.User&amp;quot;&amp;gt;
      select * from tb_user where id = #{id};
   &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.MybatisTest.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MybatisTest {
    public static void main(String[] args) throws Exception {
        // 指定全局配置文件
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 构建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        // 获取sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        try {
            // 操作CRUD，第一个参数：指定statement，规则：命名空间+“.”+statementId
            // 第二个参数：指定传入sql的参数：这里是用户id
            User user = sqlSession.selectOne(&amp;quot;UserMapper.selectUser&amp;quot;, 1);
            System.out.println(user);
        } finally {
            sqlSession.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.Mybatis步骤&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1)配置mybatis-config.xml 全局的配置文件 (1、数据源，2、外部的mapper)&lt;/p&gt;

&lt;p&gt;2)创建SqlSessionFactory&lt;/p&gt;

&lt;p&gt;3)通过SqlSessionFactory创建SqlSession对象&lt;/p&gt;

&lt;p&gt;4)通过SqlSession操作数据库 CRUD&lt;/p&gt;

&lt;p&gt;5)调用session.commit()提交事务&lt;/p&gt;

&lt;p&gt;6)调用session.close()关闭会话&lt;/p&gt;

&lt;h4 id=&#34;mybatis实现crud&#34;&gt;Mybatis实现CRUD&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.UserDao接口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserDao {
    /**
     * 根据id查询用户信息
     *
     * @param id
     * @return
     */
    public User queryUserById(int id);

    /**
     * 查询所有用户信息
     *
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserAll();

    /**
     * 新增用户
     *
     * @param user
     */
    public void insertUser(User user);

    /**
     * 更新用户信息
     *
     * @param user
     */
    public void updateUser(User user);

    /**
     * 根据id删除用户信息
     *
     * @param id
     */
    public void deleteUser(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.UserDaoImpl&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoImpl implements UserDao {
    public SqlSession sqlSession;

    public UserDaoImpl(SqlSession sqlSession) {
        this.sqlSession = sqlSession;
    }

    @Override
    public User queryUserById(int id) {
        return this.sqlSession.selectOne(&amp;quot;UserDao.queryUserById&amp;quot;, id);
    }

    @Override
    public List&amp;lt;User&amp;gt; queryUserAll() {
        return this.sqlSession.selectList(&amp;quot;UserDao.queryUserAll&amp;quot;);
    }

    @Override
    public void insertUser(User user) {
        this.sqlSession.insert(&amp;quot;UserDao.insertUser&amp;quot;, user);
    }

    @Override
    public void updateUser(User user) {
        this.sqlSession.update(&amp;quot;UserDao.updateUser&amp;quot;, user);
    }

    @Override
    public void deleteUser(int id) {
        this.sqlSession.delete(&amp;quot;UserDao.deleteUser&amp;quot;, id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.UserDaoMapper.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;UserDao&amp;quot;&amp;gt;
    &amp;lt;!-- statement，内容：sql语句。id：唯一标识，随便写，在同一个命名空间下保持唯一
       resultType：sql语句查询结果集的封装类型,tb_user即为数据库中的表
     --&amp;gt;
    &amp;lt;!--&amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;--&amp;gt;
    &amp;lt;!--select * from tb_user where id = #{id}--&amp;gt;
    &amp;lt;!--&amp;lt;/select&amp;gt;--&amp;gt;

    &amp;lt;!--使用别名--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
      select
       tuser.id as id,
       tuser.user_name as userName,
       tuser.password as password,
       tuser.name as name,
       tuser.age as age,
       tuser.birthday as birthday,
       tuser.sex as sex,
       tuser.created as created,
       tuser.updated as updated
       from
       tb_user tuser
       where tuser.id = #{id};
   &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;queryUserAll&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user;
    &amp;lt;/select&amp;gt;

    &amp;lt;!--插入数据--&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        INSERT INTO tb_user (
        user_name,
        password,
        name,
        age,
        sex,
        birthday,
        created,
        updated
        )
        VALUES
        (
        #{userName},
        #{password},
        #{name},
        #{age},
        #{sex},
        #{birthday},
        now(),
        now()
        );
    &amp;lt;/insert&amp;gt;

    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;

    &amp;lt;delete id=&amp;quot;deleteUser&amp;quot;&amp;gt;
        delete from tb_user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.mybatis-config.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserDaoMapper.xml&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.测试&lt;/strong&gt;
引入依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--junit--&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UserDaoTest .java(&lt;strong&gt;测试类的生成可以在UserDao上Alt+enter，选择创建测试类&lt;/strong&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserDaoTest {

    public UserDao userDao;
    public SqlSession sqlSession;

    @Before
    public void setUp() throws Exception {
        // mybatis-config.xml
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream is = Resources.getResourceAsStream(resource);
        // 构建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
        // 获取sqlSession
        sqlSession = sqlSessionFactory.openSession();
        this.userDao = new UserDaoImpl(sqlSession);
    }

    @Test
    public void queryUserById() {
        System.out.println(this.userDao.queryUserById(1));
    }

    @Test
    public void queryUserAll() {
        List&amp;lt;User&amp;gt; userList = this.userDao.queryUserAll();
        for (User user : userList) {
            System.out.println(user);
        }
    }

    @Test
    public void insertUser() {
        User user = new User();
        user.setAge(16);
        user.setBirthday(new Date(&amp;quot;1990/09/02&amp;quot;));
        user.setName(&amp;quot;大鹏&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(1);
        user.setUserName(&amp;quot;evan&amp;quot;);
        this.userDao.insertUser(user);
        this.sqlSession.commit();

    }

    @Test
    public void updateUser() {
        User user = new User();
        user.setBirthday(new Date());
        user.setName(&amp;quot;www&amp;quot;);
        user.setPassword(&amp;quot;654321&amp;quot;);
        user.setSex(1);
        user.setUserName(&amp;quot;www&amp;quot;);
        user.setId(1);
        this.userDao.updateUser(user);
        this.sqlSession.commit();

    }

    @Test
    public void deleteUser() {
        this.userDao.deleteUser(4);
        this.sqlSession.commit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态代理mapper实现类&#34;&gt;动态代理Mapper实现类&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.UserMapper&lt;/strong&gt;（对应原UserDao）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface UserMapper {
    /**
     * 登录（直接使用注解指定传入参数名称）
     * @param userName
     * @param password
     * @return
     */
    public User login(@Param(&amp;quot;userName&amp;quot;) String userName, @Param(&amp;quot;password&amp;quot;) String password);

    /**
     * 根据表名查询用户信息（直接使用注解指定传入参数名称）
     * @param tableName
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserByTableName(@Param(&amp;quot;tableName&amp;quot;) String tableName);

    /**
     * 根据Id查询用户信息
     * @param id
     * @return
     */
    public User queryUserById(int id);

    /**
     * 查询所有用户信息
     * @return
     */
    public List&amp;lt;User&amp;gt; queryUserAll();

    /**
     * 新增用户信息
     * @param user
     */
    public void insertUser(User user);

    /**
     * 根据id更新用户信息
     * @param user
     */
    public void updateUser(User user);

    /**
     * 根据id删除用户信息
     * @param id
     */
    public void deleteUserById(int id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.UserMapper.xml&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;mapper:根标签，namespace：命名空间，为了使用接口动态代理，这里必须是接口的全路径名&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &amp;quot;-//mybatis.org//DTD Mapper 3.0//EN&amp;quot;
        &amp;quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&amp;quot;&amp;gt;
&amp;lt;!-- mapper:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 ，为了使用接口动态代理，这里必须是接口的全路径名--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.mappers.UserMapper&amp;quot;&amp;gt;
    &amp;lt;!--
       1.#{},预编译的方式preparedstatement，使用占位符替换，防止sql注入，一个参数的时候，任意参数名可以接收
       2.${},普通的Statement，字符串直接拼接，不可以防止sql注入，一个参数的时候，必须使用${value}接收参数
     --&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from ${tableName}
    &amp;lt;/select&amp;gt;

    &amp;lt;select id=&amp;quot;login&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where user_name = #{userName} and password = #{password}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- statement，内容：sql语句。
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       resultType：sql语句查询结果集的封装类型，使用动态代理之后和方法的返回类型一致；resultMap：二选一
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserById&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where id = #{id}
    &amp;lt;/select&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserAll&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user
    &amp;lt;/select&amp;gt;
    &amp;lt;!-- 新增的Statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
       useGeneratedKeys:开启主键回写
       keyColumn：指定数据库的主键
       keyProperty：主键对应的pojo属性名
     --&amp;gt;
    &amp;lt;insert id=&amp;quot;insertUser&amp;quot; useGeneratedKeys=&amp;quot;true&amp;quot; keyColumn=&amp;quot;id&amp;quot; keyProperty=&amp;quot;id&amp;quot;
            parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        INSERT INTO tb_user (
            id,
            user_name,
            password,
            name,
            age,
            sex,
            birthday,
            created,
            updated
        )
        VALUES
        (
            null,
            #{userName},
            #{password},
            #{name},
            #{age},
            #{sex},
            #{birthday},
            NOW(),
            NOW()
        );
    &amp;lt;/insert&amp;gt;
    &amp;lt;!--
       更新的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;
    &amp;lt;!--
       删除的statement
       id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
       parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
     --&amp;gt;
    &amp;lt;delete id=&amp;quot;deleteUserById&amp;quot; parameterType=&amp;quot;java.lang.Integer&amp;quot;&amp;gt;
        delete from tb_user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.mybatis-config.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserDaoMapper.xml&amp;quot; /&amp;gt;
    &amp;lt;mapper resource=&amp;quot;mappers/UserMapper2.xml&amp;quot; /&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;a.映射文件的命名空间（namespace）必须是mapper接口的全路径&lt;/p&gt;

&lt;p&gt;b.映射文件的statement的id必须和mapper接口的方法名保持一致&lt;/p&gt;

&lt;p&gt;c.Statement的resultType必须和mapper接口方法的返回类型一致&lt;/p&gt;

&lt;p&gt;d.statement的parameterType必须和mapper接口方法的参数类型一致（不一定）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UserMapperTest {

    public UserMapper userMapper;

    @Before
    public void setUp() throws Exception {
        // 指定配置文件
        String resource = &amp;quot;mybatis-config.xml&amp;quot;;
        // 读取配置文件
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 构建sqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        // 获取sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession(true);

        // 1. 映射文件的命名空间（namespace）必须是mapper接口的全路径
        // 2. 映射文件的statement的id必须和mapper接口的方法名保持一致
        // 3. Statement的resultType必须和mapper接口方法的返回类型一致
        // 4. statement的parameterType必须和mapper接口方法的参数类型一致（不一定）
        this.userMapper = sqlSession.getMapper(UserMapper.class);

    }

    @Test
    public void login() {
        System.out.println(this.userMapper.login(&amp;quot;lk&amp;quot;, &amp;quot;123456&amp;quot;));
    }

    @Test
    public void queryUserByTableName() {
        List&amp;lt;User&amp;gt; userList = this.userMapper.queryUserByTableName(&amp;quot;tb_user&amp;quot;);
        for (User user : userList) {
            System.out.println(user);
        }
    }

    @Test
    public void queryUserById() {
        System.out.println(this.userMapper.queryUserById(1));
    }

    @Test
    public void queryUserAll() {
        List&amp;lt;User&amp;gt; userList = this.userMapper.queryUserAll();
        for (User user : userList) {
            System.out.println(user);
        }
    }
    @Test
    public void insertUser() {
        User user = new User();
        user.setAge(20);
        user.setBirthday(new Date());
        user.setName(&amp;quot;大神&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(2);
        user.setUserName(&amp;quot;bigGod222&amp;quot;);
        this.userMapper.insertUser(user);
        System.out.println(user.getId());
    }

    @Test
    public void updateUser() {
        User user = new User();
        user.setBirthday(new Date());
        user.setName(&amp;quot;静静&amp;quot;);
        user.setPassword(&amp;quot;123456&amp;quot;);
        user.setSex(0);
        user.setUserName(&amp;quot;Jinjin&amp;quot;);
        user.setId(1);
        this.userMapper.updateUser(user);
    }

    @Test
    public void deleteUserById() {
        this.userMapper.deleteUserById(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mapper-xml文件详解&#34;&gt;Mapper XML文件详解&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.CRUD标签&lt;/strong&gt;
* select&lt;/p&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识。必须。要求id和mapper接口中的方法的名字一致。
resultType：将结果集映射为java的对象类型。必须（和 resultMap 二选一）
parameterType：传入参数类型。可以省略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id：唯一标识，随便写，在同一个命名空间下保持唯一，使用动态代理之后要求和方法名保持一致
parameterType：参数的类型，使用动态代理之后和方法的参数类型一致
useGeneratedKeys:开启主键回写
keyColumn：指定数据库的主键
keyProperty：主键对应的pojo属性名
标签内部：具体的sql语句。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识(必须属性)；
parameterType：传入的参数类型，可以省略。
标签内部：具体的sql语句。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;id属性：当前名称空间下的statement的唯一标识(必须属性)；
parameterType：传入的参数类型，可以省略。
标签内部：具体的sql语句。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.#{}和${}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;#{} 和 ${} 在预编译中的处理是不一样的。#{} 在预处理时，会把参数部分用一个占位符 ? 代替;而 ${} 则只是简单的字符串替换.&lt;strong&gt;优先使用 #{}, ${} 会导致 sql 注入的问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：数据库有两个一模一样的表。历史表，当前表
查询表中的信息，有时候从历史表中去查询数据，有时候需要去新的表去查询数据。
希望使用1个方法来完成操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;
    select * from #{tableName}
&amp;lt;/select&amp;gt;
&amp;lt;-- 相当于select * from “tb_user”;  会报错 --&amp;gt;

&amp;lt;-- 正确做法 --&amp;gt;
&amp;lt;select id=&amp;quot;queryUserByTableName&amp;quot; resultType=&amp;quot;com.zpc.mybatis.pojo.User&amp;quot;&amp;gt;
    select * from ${tableName}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：
使用${} 去取出参数值信息，需要使用${value}
#{} 只是表示占位，与参数的名字无关，如果只有一个参数，会自动对应。多参数时，通常在方法的参数列表上加上一个注释@Param(“xxxx”) 显式指定参数的名字&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.sql片段&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;--定义--&amp;gt;
&amp;lt;sql id=””&amp;gt;&amp;lt;/sql&amp;gt;
&amp;lt;--使用--&amp;gt;
&amp;lt;include refId=”” /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;动态sql&#34;&gt;动态sql&lt;/h4&gt;

&lt;p&gt;动态sql有
1. if
2. choose，when，otherwise
3. where，set
4. foreach&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.if&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：查询用户，如果输入了姓名，则按姓名查询&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByName(@Param(&amp;quot;userName&amp;quot;) String userName);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
    &amp;lt;!--if的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByName&amp;quot;
            resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
      select * from tb_user
      &amp;lt;if test=&amp;quot;userName != null and userName.trim() != &#39;&#39;&amp;quot;&amp;gt;
          where user_name like &#39;%${userName}%&#39;
      &amp;lt;/if&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.choose，when，otherwise&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：查询用户，如果输入了姓名则按照姓名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找姓名为“ls”的用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByNameOrAge(@Param(&amp;quot;userName&amp;quot;) String userName,
                                    @Param(&amp;quot;age&amp;quot;) Integer age);
                                        
&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--choose when otherwise的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByNameOrAge&amp;quot;
            resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user WHERE
        &amp;lt;!--
        1.一旦有条件成立的when，后续的when则不会执行
        2.当所有的when都不执行时,才会执行otherwise
        --&amp;gt;
        &amp;lt;choose&amp;gt;
            &amp;lt;when test=&amp;quot;userName!=null and userName.trim()!=&#39;&#39;&amp;quot;&amp;gt;
                user_name like &#39;%${userName}%&#39;
            &amp;lt;/when&amp;gt;
            &amp;lt;when test=&amp;quot;age!=null&amp;quot;&amp;gt;
                age = #{age}
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise&amp;gt;
                user_name = &#39;ls&#39;
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choose&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.where 和set&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景一&lt;/strong&gt;：查询所有用户，如果输入了姓名按照姓名进行模糊查询，如果输入年龄，按照年龄进行查询，如果两者都输入，两个条件都要成立。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByNameAndAge(@Param(&amp;quot;userName&amp;quot;) String userName,
                                     @Param(&amp;quot;age&amp;quot;) Integer age);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--where 和set的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByNameAndAge&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user
        &amp;lt;!--如果多出一个and，会自动去除，如果缺少and或者多出多个and则会报错--&amp;gt;
        &amp;lt;where&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null and userName.trim()!=&#39;&#39;&amp;quot;&amp;gt;
                and name like &#39;%${userName}%&#39;
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;
                and age = #{age}
            &amp;lt;/if&amp;gt;
        &amp;lt;/where&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;场景二&lt;/strong&gt;：修改用户信息，如果参数user中的某个属性为null，则不修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
void updateUser(User user);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;update id=&amp;quot;updateUser&amp;quot; parameterType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        UPDATE tb_user
        &amp;lt;trim prefix=&amp;quot;set&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
            &amp;lt;if test=&amp;quot;userName!=null&amp;quot;&amp;gt;user_name = #{userName},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;password!=null&amp;quot;&amp;gt;password = #{password},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;name!=null&amp;quot;&amp;gt;name = #{name},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;age!=null&amp;quot;&amp;gt;age = #{age},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;sex!=null&amp;quot;&amp;gt;sex = #{sex},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&amp;quot;birthday!=null&amp;quot;&amp;gt;birthday = #{birthday},&amp;lt;/if&amp;gt;
            updated = now(),
        &amp;lt;/trim&amp;gt;
        WHERE
        (id = #{id});
    &amp;lt;/update&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.foreach&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;场景：按照多个id查询用户信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 接口
List&amp;lt;User&amp;gt; queryUserListByIds(@Param(&amp;quot;ids&amp;quot;) int[] ids);

&amp;lt;--mapper--&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.DynamicSqlMapper&amp;quot;&amp;gt;
	&amp;lt;!--foreach的简单使用--&amp;gt;
    &amp;lt;select id=&amp;quot;queryUserListByIds&amp;quot; resultType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;&amp;gt;
        select * from tb_user where id in
        &amp;lt;foreach collection=&amp;quot;ids&amp;quot; item=&amp;quot;id&amp;quot; open=&amp;quot;(&amp;quot; close=&amp;quot;)&amp;quot; separator=&amp;quot;,&amp;quot;&amp;gt;
            #{id}
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;高级查询&#34;&gt;高级查询&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;一对一查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：查询订单，并查询出下单人的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Order {
    private Integer id;
    private Long userId;
    private String orderNumber;
    private Date createdTime;
    private Date updatedTime;
    private User user;
    // get,set,toString
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OrderMapper.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface OrderMapper {
	Order queryOrderWithUserByOrderNumber(@Param(&amp;quot;number&amp;quot;) String number);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;OrderMapper.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!-- mappers:根标签，namespace：命名空间，随便写，一般保证命名空间唯一 --&amp;gt;
&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.OrderMapper&amp;quot;&amp;gt;
    &amp;lt;resultMap id=&amp;quot;OrderUserResultMap&amp;quot;
               type=&amp;quot;cn.wishhust.mybatis.pojo.Order&amp;quot;
               autoMapping=&amp;quot;true&amp;quot;&amp;gt;
        &amp;lt;!--
            指定主键
            column：数据库的列名
            property：java实体类中的属性名
        --&amp;gt;
        &amp;lt;id column=&amp;quot;id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
        &amp;lt;!--association:完成子对象的映射--&amp;gt;
        &amp;lt;!--property:子对象在父对象中的属性名--&amp;gt;
        &amp;lt;!--javaType:子对象的java类型--&amp;gt;
        &amp;lt;!--autoMapping:完成子对象的自动映射，若开启驼峰，则按驼峰匹配--&amp;gt;
        &amp;lt;association property=&amp;quot;user&amp;quot;
                     javaType=&amp;quot;cn.wishhust.mybatis.pojo.User&amp;quot;
                     autoMapping=&amp;quot;true&amp;quot;&amp;gt;
            &amp;lt;id column=&amp;quot;user_id&amp;quot; property=&amp;quot;id&amp;quot;/&amp;gt;
        &amp;lt;/association&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;select id=&amp;quot;queryOrderWithUserByOrderNumber&amp;quot;
            resultMap=&amp;quot;OrderUserResultMap&amp;quot;&amp;gt;
      select * from tb_order o left join tb_user u
        on o.user_id=u.id
        where o.order_number = #{number}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;缓存&#34;&gt;缓存&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;一级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mybatis的一级缓存的&lt;strong&gt;作用域是session&lt;/strong&gt;，当openSession()后，如果执行相同的SQL（相同语句和参数），Mybatis不进行执行SQL，而是从缓存中命中返回。原理：Mybatis执行查询时首先去缓存区命中，如果命中直接返回，没有命中则执行SQL，从数据库中查询。&lt;/p&gt;

&lt;p&gt;在mybatis中，一级缓存默认是开启的，并且一直无法关闭&lt;/p&gt;

&lt;p&gt;一级缓存满足条件：
1、同一个session中
2、相同的SQL和参数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二级缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mybatis 的二级缓存的&lt;strong&gt;作用域是一个mapper的namespace&lt;/strong&gt; ，同一个namespace中查询sql可以从缓存中命中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;mapper namespace=&amp;quot;cn.wishhust.mybatis.dao.mappers.UserMapper&amp;quot;&amp;gt;
    &amp;lt;cache/&amp;gt;
    ...
&amp;lt;/mapper&amp;gt;

&amp;lt;settings&amp;gt;
    &amp;lt;!--开启驼峰匹配--&amp;gt;
    &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;!--开启二级缓存,全局总开关，这里关闭，mapper中开启了也没用--&amp;gt;
    &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sql语句中出现-的解决方案&#34;&gt;sql语句中出现’&amp;lt;’的解决方案&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;转义字符&lt;/th&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;lt；&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;gt；&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;amp；&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;和&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;apos；&lt;/td&gt;
&lt;td&gt;&amp;lsquo;&lt;/td&gt;
&lt;td&gt;省略号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;quot；&lt;/td&gt;
&lt;td&gt;&amp;ldquo;&lt;/td&gt;
&lt;td&gt;引号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;![CDATA[ 符号 ]]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：使用&amp;lt;![CDATA[ ]]&amp;gt;标记的sql语句中的&amp;lt;where&amp;gt; &amp;lt;if&amp;gt;等标签不会被解析。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;报错1：&lt;/p&gt;

&lt;p&gt;org.apache.ibatis.binding.BindingException: Type interface cn.wishhust.mybatis.mappers.OrderMapper is not known to the MapperRegistry.&lt;/p&gt;

&lt;p&gt;原因：
xml文件的namespace的值对应的mapper接口写错了，没使用全名。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
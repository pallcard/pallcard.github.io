<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Fri, 06 Mar 2020 19:15:26 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ReentrantLock</title>
      <link>https://pallcard.github.io/2020/reentrantlock/</link>
      <pubDate>Fri, 06 Mar 2020 19:15:26 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2020/reentrantlock/</guid>
      <description>

&lt;h1 id=&#34;reentrantlock&#34;&gt;ReentrantLock&lt;/h1&gt;

&lt;h2 id=&#34;reentrantlock流程&#34;&gt;ReentrantLock流程&lt;/h2&gt;

&lt;h3 id=&#34;测试代码&#34;&gt;测试代码&lt;/h3&gt;

&lt;p&gt;main方法中通过&lt;code&gt;new ReentrantLock();&lt;/code&gt;创建了一个可重入锁，然后通过线程池创建了5个线程，在各个线程中通过&lt;code&gt;rlock.lock();&lt;/code&gt;进行加锁，然后执行逻辑，最后通过&lt;code&gt;rlock.unlock();&lt;/code&gt;进行解锁。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest {

  public static volatile int count = 0;

  public static void main(String[] args) throws InterruptedException {
    // ReentrantLock rlock = new ReentrantLock(true);
    ReentrantLock rlock = new ReentrantLock();
    ExecutorService executorService = Executors.newFixedThreadPool(5);
    for (int i = 0; i &amp;lt; 5; i++) {
      executorService.execute(()-&amp;gt;{
        rlock.lock();
        System.out.println(Thread.currentThread().getName()+ &amp;quot; start&amp;quot;);
        for (int j = 0; j &amp;lt; 10; j++) {
          System.out.println(Thread.currentThread().getName()+ &amp;quot; &amp;quot; +count++);
        }
        System.out.println(Thread.currentThread().getName()+ &amp;quot; end&amp;quot;);
        rlock.unlock();
      });
    }

    Thread.sleep(5000);
    System.out.println(count);

  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;上锁流程&#34;&gt;上锁流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/04/04/1585988828882-1585988828890.png&#34; alt=&#34;title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说明：ReentrantLock 调用lock时，若为非公平锁先直接通过cas设置state的状态，若设置失败，在调用acquire，acquire会先调用tryAcquire(AQS子类实现)，线程会尝试通过cas设置状态，若失败，将thread封装成Node加入到队列（CLH队列）中，然后调用acquireQueued，acquireQueued中会自旋，判断前一个结点是否为head，若为则通过tryAcquire获取锁，若失败去修改前一个结点的waitstatus，挂起当前线程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/04/04/1585988196704-1585988196707.png&#34; alt=&#34;title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说明：ReentrantLock 调用unlock时，然后调用release，而release通过tryRelease来设置state状态，并设置线程为null，最后unpark后面的结点。&lt;/p&gt;

&lt;h3 id=&#34;代码说明&#34;&gt;代码说明&lt;/h3&gt;

&lt;h4 id=&#34;上锁相关代码&#34;&gt;上锁相关代码&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
// ReentrantLock
    public void lock() {
        sync.lock();
    }

// ReentrantLock#NonfairSync
        final void lock() {
            if (compareAndSetState(0, 1))//若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);// 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续
        }

// ReentrantLock#FairSync
        final void lock() {
            acquire(1);
        }


    // AbstractQueuedSynchronizer
    public final void acquire(int arg) {
        //去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。tryAcquire尝试获取锁，子类实现
        if (!tryAcquire(arg) &amp;amp;&amp;amp; 
            //如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 
            //acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。
            selfInterrupt(); 
    }

    // ReentrantLock#FairSync
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
	    // 若队列中无有效结点才进行cas操作拿锁，非公平锁无需判断hasQueuedPredecessors
            if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &amp;lt; 0)
                throw new Error(&amp;quot;Maximum lock count exceeded&amp;quot;);
            setState(nextc);
            return true;
        }
        return false;
    }

// 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。
    public final boolean hasQueuedPredecessors() {
        Node t = tail; 
        Node h = head;
        Node s;
        // 双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。
	// 当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True。 
	// 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；
	// 如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。
        return h != t &amp;amp;&amp;amp;
            ((s = h.next) == null || s.thread != Thread.currentThread());

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;解锁相关代码&#34;&gt;解锁相关代码&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    // ReentrantLock
    public void unlock() {
        sync.release(1);
    }

    // AbstractQueuedSynchronizer
    public final boolean release(int arg) {
        // 释放锁成功后则执行后面的唤醒后续节点的逻辑了
        if (tryRelease(arg)) { 
            Node h = head;
            // addWaiter 方法默认的节点状态为 0，此时节点还没有进入就绪状态
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0) 
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    // ReentrantLock#Sync
    protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }

    private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        // 将头节点的状态设置为0, 尝试清除头节点的状态，改为初始状态
        if (ws &amp;lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        // 后继节点
        Node s = node.next; 
        // 如果后继节点为null，或者已经被取消了
        if (s == null || s.waitStatus &amp;gt; 0) {
            s = null;
            // for循环从队列尾部一直往前找可以唤醒的节点
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                if (t.waitStatus &amp;lt;= 0)
                    s = t;
        }
        if (s != null)
	    // 唤醒后继节点
            LockSupport.unpark(s.thread); 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;例子说明&#34;&gt;例子说明&lt;/h3&gt;

&lt;p&gt;开头例子启动了5个线程(t1,&amp;hellip;t5)，启动后他们会去争抢锁，假设t1最先lock，他通过cas操作拿到了锁（假设长时间占用），然后t2(可能是其他线程)在取lock时会失败，然后调用acquire，会再次去获取锁，又失败了，就会将t2封装成一个Node对象，将其加入到队列中，然后在调用acquireQueued，此时t2为第一个结点，会再次去获取锁，若失败，修改前一个结点（head）的waitstatus=-1，自旋再次调用一遍，此时前一个结点的waitstaus=-1，故阻塞改线程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/04/04/1585997115494-1585997115496.png&#34; alt=&#34;title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/04/04/1585997180105-1585997180109.png&#34; alt=&#34;title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/04/04/1585997141559-1585997141562.png&#34; alt=&#34;title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/jCBrHSVK647bdVIPvJHxOg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://mp.weixin.qq.com/s/jCBrHSVK647bdVIPvJHxOg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AQS</title>
      <link>https://pallcard.github.io/2020/aqs/</link>
      <pubDate>Wed, 04 Mar 2020 19:14:41 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2020/aqs/</guid>
      <description>

&lt;h1 id=&#34;aqs&#34;&gt;AQS&lt;/h1&gt;

&lt;p&gt;AbstractQueuedSynchronizer（AQS）是同步器实现框架，它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。&lt;/p&gt;

&lt;p&gt;AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。&lt;/p&gt;

&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;

&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    private transient volatile Node head;  // 头结点
    private transient volatile Node tail;  // 尾结点
    private volatile int state; //state 字段为同步状态，其中 state &amp;gt; 0 为有锁状态，每次加锁就在原有 state 基础上加 1，即代表当前持有锁的线程加了 state 次锁，反之解锁时每次减一，当 statte = 0 为无锁状态；


}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;node&#34;&gt;Node&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; static final class Node {
        // 共享模式，表示线程要获取的是共享锁，即一个锁可以被不同的线程拥有
        static final Node SHARED = new Node();  
        // 独占模式，表示线程要获取的独占锁，即一个锁只能被一个线程拥有
        static final Node EXCLUSIVE = null;  

        //表示当前节点的线程因为超时或中断被取消了
        static final int CANCELLED =  1;  
        // 表示当前节点的后续节点中的线程通过 park 被阻塞了，需要通过unpark解除它的阻塞
        static final int SIGNAL    = -1; 
        // 表示当前节点在 condition 队列中
        static final int CONDITION = -2;  
        // 共享模式的头结点可能处于此状态，表示无条件往下传播,引入此状态是为了优化锁竞争，使队列中线程有序地一个一个唤醒
        static final int PROPAGATE = -3;

        volatile int waitStatus;
        volatile Node prev;
        volatile Node next;
        volatile Thread thread;
        Node nextWaiter;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重要方法&#34;&gt;重要方法&lt;/h3&gt;

&lt;h4 id=&#34;acquire&#34;&gt;acquire&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    public final void acquire(int arg) {
	//去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;addwaiter&#34;&gt;addWaiter&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {  // 尝试快速将该节点加入到队列的尾部
            node.prev = pred;
            if (compareAndSetTail(pred, node)) { // 当tail=pred时，更新tail为node
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

    private Node enq(final Node node) {
        for (;;) {   // 自旋直至成功
            Node t = tail;
            if (t == null) { // Must initialize   等待队列为空
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/04/02/1585839797495-1585839797498.png&#34; alt=&#34;title&#34; /&gt;&lt;/p&gt;

&lt;p&gt;说明：初始CLH队列为空，当调用&lt;code&gt;addWaiter()&lt;/code&gt;时，&lt;code&gt;pred=tail&lt;/code&gt;此时为空，直接调用&lt;code&gt;enq(node)&lt;/code&gt;,在enq方法中，&lt;code&gt;t=tail&lt;/code&gt;此时为空，故通过cas设置head为new Node();设置成功令&lt;code&gt;tail=head&lt;/code&gt;,否则自旋；此时&lt;code&gt;t=tail&lt;/code&gt;不空，设置node的prev指针，cas设置tail，设置t的next指针，然后返回t，addWaiter返回node。
当再次调用&lt;code&gt;addWaiter()&lt;/code&gt;时，&lt;code&gt;pred=tail&lt;/code&gt;此时不为空，将node加入尾部，若失败，则使用&lt;code&gt;enq(node)&lt;/code&gt;添加。&lt;/p&gt;

&lt;h4 id=&#34;acquirequeued&#34;&gt;acquireQueued&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // 当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            //中断标志
            boolean interrupted = false; 
            // 自旋
            for (;;) { 
		// 获取当前节点的 pred 节点
                final Node p = node.predecessor();  
 		//当前线程的前驱节点是头结点，且同步状态成功，head 节点代表当前持有锁的线程，那么如果当前节点的 pred 节点是 head 节点，说明当前节点在真实数据队列的首部，就尝试获取锁（头结点是虚节点）
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
		    // 获取锁成功，头指针移动到当前node
                    setHead(node); 
                    p.next = null; // help GC
                    failed = false;
		    // 不需要挂起，返回 false
                    return interrupted; 
                } 
		// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;  // 获取锁失败，则进入挂起逻辑
                    parkAndCheckInterrupt()) //挂起当前线程，阻塞调用栈，返回当前线程的中断状态。
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/c806dd7f60bc&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.jianshu.com/p/c806dd7f60bc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://objcoding.com/2019/05/05/aqs-exclusive-lock/#aqs-%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://objcoding.com/2019/05/05/aqs-exclusive-lock/#aqs-%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>查看Jdk源码方式</title>
      <link>https://pallcard.github.io/2020/%E6%9F%A5%E7%9C%8Bjdk%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 01 Mar 2020 20:05:45 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2020/%E6%9F%A5%E7%9C%8Bjdk%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F/</guid>
      <description>

&lt;h1 id=&#34;查看jdk源码方法&#34;&gt;查看JDK源码方法&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;到jdk的目录下找到src.zip进行解压
&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/25/1585147300954-1585147300978.png&#34; alt=&#34;title&#34; /&gt;&lt;/li&gt;
&lt;li&gt;在项目中新建一个文件夹，如下我在resources目录下新建了一个jdk文件夹，然后将第二步解压的文件复制到这里。
&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/25/1585147176905-1585147177052.png&#34; alt=&#34;title&#34; /&gt;&lt;/li&gt;
&lt;li&gt;到project struct中，在sdks下，修改sourcepath指向直接添加到项目中的jdk目录。
&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/25/1585147405431-1585147405432.png&#34; alt=&#34;title&#34; /&gt;&lt;/li&gt;
&lt;li&gt;去掉下图中的对勾
&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/25/1585147563641-1585147563645.png&#34; alt=&#34;title&#34; /&gt;&lt;/li&gt;
&lt;li&gt;完成以上步骤就可以编写test类，进行单步调试代码了。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Mysql多表查询</title>
      <link>https://pallcard.github.io/2020/mysql%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 29 Feb 2020 21:03:40 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2020/mysql%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</guid>
      <description>

&lt;h1 id=&#34;mysql多表查询&#34;&gt;Mysql多表查询&lt;/h1&gt;

&lt;h2 id=&#34;举例分析&#34;&gt;举例分析&lt;/h2&gt;

&lt;p&gt;说明:表格仅为举例说明
tb_user_age
|id|age|
|-|-|
|1|10|
|2|11|
|3|12|
|4|13|
tb_user_name
|id|age|
|-|-|
|2|zhang|
|3|li|
|4|zhou|
|5|chen|&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;create table tb_user_age (
    id bigint auto_increment comment &#39;ID&#39; primary key,
    age int null comment &#39;年龄&#39;
)
comment = &#39;用户年龄&#39; engine = innodb charset utf8mb4;

create table tb_user_name (
     id bigint auto_increment comment &#39;ID&#39; primary key,
     name varchar(30) null comment &#39;姓名&#39;
)
comment = &#39;用户姓名&#39; engine = innodb charset utf8mb4;


insert into tb_user_age (age) values (10),(11),(12),(13);
insert into tb_user_name (id,name) values (2,&#39;zhang&#39;),(3,&#39;li&#39;),(4,&#39;zhou&#39;),(5,&#39;chen&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;内连接-join-或-inner-join&#34;&gt;内连接 （join 或 inner join）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select a.*, b.* from tb_user_age a 
inner join tb_user_name b 
on a.id = b.id

# a.id  age    b.id     name
# 2	11	2	zhang
# 3	12	3	li
# 4	13	4	zhou
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/14/Popo%E6%88%AA%E5%9B%BE202031411598-1584158370889.png?token=AHBYBJ6WNC2N4SVHY2JSQPS6NRLOC&#34; alt=&#34;title&#34; /&gt;
这种场景下得到的是满足某一条件的A，B内部的数据；正因为得到的是内部共有数据，所以连接方式称为内连接。&lt;/p&gt;

&lt;h3 id=&#34;外连接&#34;&gt;外连接&lt;/h3&gt;

&lt;h4 id=&#34;左连接-left-join-或left-outer-join&#34;&gt;左连接 （left join 或left outer join)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;右连接 （right join 或right outer join)与左连接类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select a.*, b.* from tb_user_age a 
left join tb_user_name b 
on a.id = b.id
# a.id  age    b.id     name
# 2	11	2	zhang
# 3	12	3	li
# 4	13	4	zhou
# 1	10	&amp;lt;null&amp;gt;	&amp;lt;null&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/pallcard/noteImg/master/noteImg/2020/03/14/Popo%E6%88%AA%E5%9B%BE202031412329-1584158631279.png?token=AHBYBJZEBIELUYE5H4BOQLK6NRL6K&#34; alt=&#34;title&#34; /&gt;
这种场景下得到的是A的所有数据，和满足某一条件的B的数据;&lt;/p&gt;

&lt;h4 id=&#34;全连接-mysql不支持-左连接-union-右连接&#34;&gt;全连接 （mysql不支持，左连接 union 右连接）&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select a.*, b.* from tb_user_age a 
left join tb_user_name b on a.id = b.id
union
select a.*, b.* from tb_user_age a 
right join tb_user_name b on a.id = b.id

# a.id  age    b.id     name
# 2	11	2	zhang
# 3	12	3	li
# 4	13	4	zhou
# 1	10	&amp;lt;null&amp;gt;	&amp;lt;null&amp;gt;
# &amp;lt;null&amp;gt;&amp;lt;null&amp;gt;  5        chen
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;交叉连接-cross-join&#34;&gt;交叉连接（cross join）&lt;/h4&gt;

&lt;p&gt;表格表做笛卡儿积&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select a.*, b.* from tb_user_age a 
cross join tb_user_name b

# a.id  age    b.id     name
# 1	10	2	zhang
# 2	11	2	zhang
# 3	12	2	zhang
# 4	13	2	zhang
# 1	10	3	li
# 2	11	3	li
# 3	12	3	li
# 4	13	3	li
# 1	10	4	zhou
# 2	11	4	zhou
# 3	12	4	zhou
# 4	13	4	zhou
# 1	10	5	chen
# 2	11	5	chen
# 3	12	5	chen
# 4	13	5	chen
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;cross 连接， 后面可以使用on或where，当使用on a.id = b.id 时，则和内连接是一样的结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一般cross join后面加上where条件，但是用cross join+on也是被解释为cross join+where；&lt;/li&gt;
&lt;li&gt;如果连接表格使用的是逗号，会被解释为交叉连接，但后面条件只能使用where；&lt;/li&gt;
&lt;li&gt;其他连接只能使用on&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Mysql之explain</title>
      <link>https://pallcard.github.io/2020/mysql%E4%B9%8Bexplain/</link>
      <pubDate>Fri, 28 Feb 2020 22:01:03 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2020/mysql%E4%B9%8Bexplain/</guid>
      <description>

&lt;h1 id=&#34;mysql之explain&#34;&gt;Mysql之explain&lt;/h1&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;# explain sql语句
explain select * from TB_ORDER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：
|id|select_type|table|partitions|type|posssible_keys|key|key_len|ref|rows|filtered|Extra|
|-|-|-|-|-|-|-|-|-|-|-|-|
|1|SIMPLE|TB_ORDER|&lt;null&gt;|ALL|&lt;null&gt;|&lt;null&gt;|&lt;null&gt;|&lt;null&gt;|1794|100|&lt;null&gt;&lt;/p&gt;

&lt;h2 id=&#34;字段说明&#34;&gt;字段说明&lt;/h2&gt;

&lt;h3 id=&#34;id&#34;&gt;id&lt;/h3&gt;

&lt;p&gt;SQL执行的顺序的标识,SQL从大到小的执行
* id相同时，执行顺序由上至下
* 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
* id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行&lt;/p&gt;

&lt;h3 id=&#34;select-type&#34;&gt;select_type&lt;/h3&gt;

&lt;p&gt;查询中每个select子句的类型&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SIMPLE(简单SELECT,不使用UNION或子查询等)&lt;/li&gt;
&lt;li&gt;PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)&lt;/li&gt;
&lt;li&gt;UNION(UNION中的第二个或后面的SELECT语句)&lt;/li&gt;
&lt;li&gt;DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)&lt;/li&gt;
&lt;li&gt;UNION RESULT(UNION的结果)&lt;/li&gt;
&lt;li&gt;SUBQUERY(子查询中的第一个SELECT)&lt;/li&gt;
&lt;li&gt;DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)&lt;/li&gt;
&lt;li&gt;DERIVED(派生表的SELECT, FROM子句的子查询)&lt;/li&gt;
&lt;li&gt;UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;table&#34;&gt;table&lt;/h3&gt;

&lt;p&gt;显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)&lt;/p&gt;

&lt;h3 id=&#34;type&#34;&gt;type&lt;/h3&gt;

&lt;p&gt;表示MySQL在表中找到所需行的方式，又称“访问类型”。常用的类型有： ALL, index,  range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;index: Full Index Scan，index与ALL区别为index类型只遍历索引树&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;range:只检索给定范围的行，使用一个索引来选择行&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;possible-keys&#34;&gt;possible_keys&lt;/h3&gt;

&lt;p&gt;指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用&lt;/p&gt;

&lt;p&gt;该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。
如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询&lt;/p&gt;

&lt;h3 id=&#34;key&#34;&gt;Key&lt;/h3&gt;

&lt;p&gt;key列显示MySQL实际决定使用的键（索引）&lt;/p&gt;

&lt;p&gt;如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。&lt;/p&gt;

&lt;h3 id=&#34;key-len&#34;&gt;key_len&lt;/h3&gt;

&lt;p&gt;表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）&lt;/p&gt;

&lt;p&gt;不损失精确性的情况下，长度越短越好&lt;/p&gt;

&lt;h3 id=&#34;ref&#34;&gt;ref&lt;/h3&gt;

&lt;p&gt;表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/p&gt;

&lt;h3 id=&#34;rows&#34;&gt;rows&lt;/h3&gt;

&lt;p&gt;表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数&lt;/p&gt;

&lt;h3 id=&#34;extra&#34;&gt;Extra&lt;/h3&gt;

&lt;p&gt;该列包含MySQL解决查询的详细信息,有以下几种情况：&lt;/p&gt;

&lt;p&gt;Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤&lt;/p&gt;

&lt;p&gt;Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询&lt;/p&gt;

&lt;p&gt;Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”&lt;/p&gt;

&lt;p&gt;Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。&lt;/p&gt;

&lt;p&gt;Impossible where：这个值强调了where语句会导致没有符合条件的行。&lt;/p&gt;

&lt;p&gt;Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结：&lt;/h3&gt;

&lt;p&gt;• EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
• EXPLAIN不考虑各种Cache
• EXPLAIN不能显示MySQL在执行查询时所作的优化工作
• 部分统计信息是估算的，并非精确值
• EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.cnblogs.com/xuanzhi201111/p/4175635.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/xuanzhi201111/p/4175635.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RabbitMQ初次使用</title>
      <link>https://pallcard.github.io/2019/rabbitmq%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 17 Aug 2019 19:55:39 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/rabbitmq%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/</guid>
      <description>

&lt;h3 id=&#34;1-添加用户&#34;&gt;1.添加用户&lt;/h3&gt;

&lt;p&gt;访问&lt;a href=&#34;http://localhost:15672后，选择右侧的user栏，在add&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://localhost:15672后，选择右侧的user栏，在add&lt;/a&gt; user中，填好用户名，密码和tags，然后点击AddUser如下：&lt;/p&gt;

&lt;p&gt;​​&lt;img src=&#34;https://pallcard.github.io/images/RabbitMQ003.png&#34; alt=&#34;RabbitMQ添加用户&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-添加virtual-hosts&#34;&gt;2.添加Virtual Hosts&lt;/h3&gt;

&lt;p&gt;（类似于创建数据库）选择右侧的Virtual Hosts栏，在add Virtual Hosts中，填好name，然后点击Add Virtual Hosts,添加后效果如下：&lt;/p&gt;

&lt;p&gt;​​&lt;img src=&#34;https://pallcard.github.io/images/RabbitMQ004.png&#34; alt=&#34;RabbitMQ添加Virtual Hosts&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击红框中vhost，给user权限，如下所示：&lt;/p&gt;

&lt;p&gt;​​&lt;img src=&#34;https://pallcard.github.io/images/RabbitMQ005.png&#34; alt=&#34;RabbitMQ权限&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-创建工程-添加依赖&#34;&gt;3.创建工程，添加依赖&lt;/h3&gt;

&lt;p&gt;使用IDEA创建一个Maven项目，pom添加依赖如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;!--RabbitMQ--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.rabbitmq&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;amqp-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.7.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--日志--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--junit4--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>RabbitMQ安装</title>
      <link>https://pallcard.github.io/2019/rabbitmq%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 17 Aug 2019 12:14:31 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/rabbitmq%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;h2 id=&#34;rabbitmq安装&#34;&gt;RabbitMQ安装&lt;/h2&gt;

&lt;p&gt;官网：&lt;a href=&#34;https://www.rabbitmq.com&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.rabbitmq.com&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;windows上安装&#34;&gt;windows上安装&lt;/h3&gt;

&lt;p&gt;1.在安装RabbitMQ之前，由于RabbitMQ使用Erlang语言编写，故需要按照Erlang.（按照时需要对照RabbitMQ版本，最好按照最新的）&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&#34;https://www.erlang.org/downloads&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.erlang.org/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装方法：下一步，下一步，&amp;hellip;即可（安装目录可自选）&lt;/p&gt;

&lt;p&gt;2.安装RabbitMQ&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&#34;https://www.rabbitmq.com/download.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.rabbitmq.com/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装方法同上，但是第一次安装后，找到软件&lt;/p&gt;

&lt;p&gt;​​&lt;img src=&#34;https://pallcard.github.io/images/RabbitMQ001.png&#34; alt=&#34;RabbitMQ001&#34; /&gt;
然后执行如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rabbitmq-plugins enable rabbitmq_management
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器访问&lt;a href=&#34;http://localhost:15672，但是无法打开页面，需要删除C:UsersAdministratorAppDataRoamingRabbitMQdb目录下所有文件，然后在从新安装一般，并执行以上操作，然后才能访问到。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://localhost:15672，但是无法打开页面，需要删除C:UsersAdministratorAppDataRoamingRabbitMQdb目录下所有文件，然后在从新安装一般，并执行以上操作，然后才能访问到。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;默认用户名，密码都是：guest&lt;/p&gt;

&lt;p&gt;到此，完成了RabbitMQ在windows上的按照。&lt;/p&gt;

&lt;h3 id=&#34;linux上安装-待完成-版本问题&#34;&gt;Linux上安装（待完成，版本问题）&lt;/h3&gt;

&lt;p&gt;1.建立目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local
mkdir rabbitmq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.添加仓库地址CentOS 7&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vi /etc/yum.repos.d/rabbitmq-erlang.repo
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# CentOS 7,其他版本可以在官网上找
[bintray-rabbitmq-server]
name=bintray-rabbitmq-rpm
baseurl=https://dl.bintray.com/rabbitmq/rpm/rabbitmq-server/v3.7.x/el/7/
gpgcheck=0
repo_gpgcheck=0
enabled=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.安装relang&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装
sudo yum install erlang
# 验证
erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.安装rabbitmq&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 先下载rpm并上传到usr/local/rabbitmq目录下

rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc

# this example assumes the CentOS 7 version of the package

yum install rabbitmq-server-3.7.17-1.el7.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据库事务</title>
      <link>https://pallcard.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 08 Aug 2019 21:58:38 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</guid>
      <description>

&lt;h3 id=&#34;事务特性&#34;&gt;事务特性&lt;/h3&gt;

&lt;p&gt;ACID：原子性、一致性、隔离性、持久性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原子性：一个事务要么全部成功，要么全部失败&lt;/li&gt;
&lt;li&gt;一致性：事务提交前后，数据库保持一致性状态&lt;/li&gt;
&lt;li&gt;隔离性：一个事务所做的修改，其他事务不可见&lt;/li&gt;
&lt;li&gt;持久性：事务一旦提交，所做修改永久保存到数据库中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-aidl&#34;&gt;原子性 + 隔离性  ---&amp;gt; 一致性   ---&amp;gt; 结果正确

                     持久性  ----&amp;gt; 应对数据库崩溃

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;并发一致性&#34;&gt;并发一致性&lt;/h3&gt;

&lt;p&gt;当多个事务并发执行时会导致事务不能保证一致性，导致结果出错。&lt;/p&gt;

&lt;p&gt;丢失修改、读脏数据、不可重复读、幻读&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;丢失修改：对于同一数据，T1 修改数据后，T2 又修改数据，T1修改读数据被覆盖&lt;/li&gt;
&lt;li&gt;读脏数据：T1修改数据后，T2读该数据，T1又回滚数据，T2读脏数据&lt;/li&gt;
&lt;li&gt;不可重复读：T1读数据后，T2对该数据进行修改，T1再读该数据，读得的数据值不一致&lt;/li&gt;
&lt;li&gt;幻读：T1读数据（例如count统计表中行数），T2插入一行数据，导致数据不一致&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;三级封锁协议&#34;&gt;三级封锁协议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一级封锁：当更新数据时，立即加X锁，直到事务结束。  ==&amp;gt; 解决了丢失修改&lt;/li&gt;
&lt;li&gt;二级封锁：在1上，当读数据时，立即加S锁，读完立即释放锁。  ==&amp;gt; 解决了读脏数据&lt;/li&gt;
&lt;li&gt;三级封锁：在2上，当读数据时，立即加S锁，直到事务结束。    ==&amp;gt; 解决了不可重复读&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;两段锁协议&#34;&gt;两段锁协议&lt;/h3&gt;

&lt;p&gt;加锁和解锁分成两个阶段。一个阶段加锁，一个阶段解锁。保证可串行性化调度。&lt;/p&gt;

&lt;h3 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;未提交读：事务的修改未提交前，其他事务可见
读：不加锁； 更新 ： 行级共享锁&lt;/li&gt;
&lt;li&gt;提交读： 事务的修改在未提交前，其他事务不可见
读：行级共享锁； 更新： 行级排他锁&lt;/li&gt;
&lt;li&gt;可重复读： 一个事务中的多次读结果一致
读：行级共享锁； 更新：行级排他锁&lt;/li&gt;
&lt;li&gt;可串行化：事务串行执行
读：表级共享锁； 更新：表级排他锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决的问题&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;未提交读&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;提交读&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可串行化&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;mysql事务隔离级别的实现&#34;&gt;mysql事务隔离级别的实现&lt;/h3&gt;

&lt;h4 id=&#34;mvcc-多版本并发控制&#34;&gt;MVCC（多版本并发控制）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;版本号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.系统版本号&lt;/p&gt;

&lt;p&gt;一个递增的数字，每开始一个新事务，系统版本号自动递增&lt;/p&gt;

&lt;p&gt;2.事务版本号&lt;/p&gt;

&lt;p&gt;事务开始的系统版本号&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;隐藏列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MVCC的每行记录后面都保存着两个隐藏的列&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建版本号，创建一个数据行的快照时的版本号&lt;/li&gt;
&lt;li&gt;删除版本号，&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;mvcc具体实现&#34;&gt;MVCC具体实现&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;.select：满足以下两个条件innodb会返回该行数据：&lt;/p&gt;

&lt;p&gt;（1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
　　&lt;/p&gt;

&lt;p&gt;（2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;.insert：将新插入的行的创建版本号设置为当前系统的版本号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;.delete：将要删除的行的删除版本号设置为当前系统的版本号。&lt;/p&gt;

&lt;p&gt;　　
&lt;strong&gt;4&lt;/strong&gt;.update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。&lt;/p&gt;

&lt;h4 id=&#34;例子&#34;&gt;例子&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;以下表格仅为示意图，方便理解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1). insert操作（事务版本为1）：事务1，插入两行数据&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2). delete操作（事务版本为2）：事务2，删除id为1数据&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3). update操作（事务版本为3）：事务3，更新id为2数据，=&amp;gt;(delete+insert)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;4). select操作（事务版本为4）：事务4，查询所有行，返回结果如下，&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;5). 两个事务：事务5（查询id=2），事务6（更新id=2）&lt;/p&gt;

&lt;p&gt;事务5未执行，事务6执行完&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务5执行完，第4行创建版本号6&amp;gt;事务版本号5，第3行创建版本号3&amp;lt;=事务版本号5&amp;lt;=删除版本号,故返回为&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;快照读与当前读&#34;&gt;快照读与当前读&lt;/h5&gt;

&lt;p&gt;通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快照读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select 的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。
读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from table where ? lock in share mode; 
select * from table where ? for update; 
insert; 
update; 
delete;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;next-key-lock&#34;&gt;Next-Key Lock&lt;/h4&gt;

&lt;p&gt;InnoDB有三种行锁的算法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Record Lock：单个行记录上的锁，&lt;strong&gt;锁定记录上的索引&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Gap Lock：间隙锁，&lt;strong&gt;锁定索引之间的间隙，但是不包含索引本身&lt;/strong&gt;。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://juejin.im/post/5cd8283ae51d453a907b4b29&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://juejin.im/post/5cd8283ae51d453a907b4b29&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java并发工具包</title>
      <link>https://pallcard.github.io/2019/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/</link>
      <pubDate>Wed, 07 Aug 2019 23:22:27 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/</guid>
      <description>

&lt;h3 id=&#34;引言&#34;&gt;引言&lt;/h3&gt;

&lt;p&gt;JDK并发包中提供了CountDownLatch、CyclicBarrier、Semaphore工具类来实现并发流程的控制。
Exchanger提供了线程间交换数据的方法。&lt;/p&gt;

&lt;h3 id=&#34;join-方法&#34;&gt;join()方法&lt;/h3&gt;

&lt;p&gt;需求：实现主程序要等待其他线程完成后，在继续执行。很容易想到使用join()方法来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JoinCountDownLatchTest {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行1&amp;quot;);
        });
        Thread thread2 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行2&amp;quot;);
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(&amp;quot;主线程&amp;quot;);
    }
}

/* 输出结果：
执行1
执行2
主线程
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;join()原理是不停的检查join线程是否存活，直到join线程都中止，线程才会this.notifyAll()。&lt;/p&gt;

&lt;h3 id=&#34;countdownlatch类&#34;&gt;CountDownLatch类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CountDownLatchTest {

    public static void main(String[] args) throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(2);
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行1&amp;quot;);
            countDownLatch.countDown();
        });

        Thread thread2 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行2&amp;quot;);
            countDownLatch.countDown();  
        });
        thread1.start();
        thread2.start();

        countDownLatch.await(10, TimeUnit.MILLISECONDS);

        System.out.println(&amp;quot;主线程&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;CountDownLatch类的构造函数需要传入数字N，表示你想等待N个点（N个线程或N个步骤）。上述代码中，
传入的N为2，则表示主线程要等待两个点后，才会继续执行主程序，在此之前程序会一直阻塞在countDownLatch.await()方法这，
（上述程序的await方法带一个指定时间，只会阻塞到指定时间）。其中调用countDown()函数时，N会减1，当N=0时，
结束阻塞。&lt;/p&gt;

&lt;p&gt;若将上述类中的方法该成如下代码，则执行1，执行2会在主线程之前打印，但是等待i不一定会在主线程之前打印，
想要实现，需要将构造中的N改为3，在for循环后面调用countDown()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(2);
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行1&amp;quot;);
            countDownLatch.countDown();
        });

        Thread thread2 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行2&amp;quot;);
            countDownLatch.countDown();
            for(int i = 0; i &amp;lt; 1000; i++) {
                System.out.println(&amp;quot;等待&amp;quot;+ (i+1));
            }
//            countDownLatch.countDown();
        });
        thread1.start();
        thread2.start();

        countDownLatch.await();

        System.out.println(&amp;quot;主线程&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cyclicbarrier类&#34;&gt;CyclicBarrier类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CyclicBarrierTest {
    public static void main(String[] args) throws InterruptedException {

        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        // 若将3改为4，程序会一直等待，没有4个线程到达屏障
//        CyclicBarrier cyclicBarrier = new CyclicBarrier(4);

        // 若将3改为4，程序会一直等待，没有4个线程到达屏障, 优先执行当任务也不会执行
        CyclicBarrier cyclicBarrier2 = new CyclicBarrier(3, new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;优先执行&amp;quot;);
            }
        });

        Thread thread1 = new Thread(() -&amp;gt; {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.println(&amp;quot;到达屏障前&amp;quot;);
            }
            try {
                cyclicBarrier.await();
                cyclicBarrier2.await();
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;执行1&amp;quot;);
        });

        Thread thread2 = new Thread(() -&amp;gt; {
            try {
                cyclicBarrier.await();
                cyclicBarrier2.await();
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;执行2&amp;quot;);
        });

        thread1.start();
        thread2.start();

        try {
            cyclicBarrier.await();
            cyclicBarrier2.await();
        } catch (Exception e) {
            e.printStackTrace();
        }
        Thread.sleep(1000);

        System.out.println(&amp;quot;主线程&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CyclicBarrier让一组线程到达一个屏障时被阻塞，例如，上述代码若将屏障数设置为4，则只会打印到达屏障前，
然后就会3个线程都会被阻塞。在CyclicBarrier的构造函数中也可以添加一个任务，到线程数达到屏障要求时，线程
继续执行，并且构造函数中的会优先执行。&lt;/p&gt;

&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;

&lt;p&gt;计算银行的账单流水，使用多个线程进行计算，然后进行汇总。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BankWaterService implements Runnable{

    // 4个屏障处理完成，执行当前类当run方法
    private CyclicBarrier cyclicBarrier = new CyclicBarrier(4, this);

    private Executor executor = Executors.newFixedThreadPool(4);

    private ConcurrentHashMap&amp;lt;String, Integer&amp;gt; sheetBankWaterCount = new ConcurrentHashMap&amp;lt;&amp;gt;();

    @Override
    public void run() {
        int result = 0;
        for(Map.Entry&amp;lt;String, Integer&amp;gt; sheet : sheetBankWaterCount.entrySet()) {
            result += sheet.getValue();
        }

        sheetBankWaterCount.put(&amp;quot;result&amp;quot;, result);
        System.out.println(result);
    }

    private void count(){
        for (int i = 0; i &amp;lt; 4; i++) {
            executor.execute(()-&amp;gt;{
                sheetBankWaterCount.put(Thread.currentThread().getName(), 1);
                System.out.println(Thread.currentThread().getName() + 1);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }

    }

    public static void main(String[] args) {
        BankWaterService bankWaterService = new BankWaterService();
        bankWaterService.count();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;首先屏障设置为4，优先执行的任务传入this，表示当4个线程到达后会优先执行类中的run()方法。对于4个线程
到计算完自己的流水后到达屏障阻塞，到4个线程都计算完毕后，会优先执行本类中的run()方法，从而完成了对于
流水的统计。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CyclicBarrier的计数器可以使用reset()方法重置，这正好解释了Cyclic循环的意思。&lt;/p&gt;

&lt;h3 id=&#34;semaphore类&#34;&gt;Semaphore类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SemaphoreTest {

    private static final int THREAD_COUNT = 30;

    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);

    private static Semaphore s = new Semaphore(10);

    public static void main(String[] args) {
        for (int i = 0; i &amp;lt; THREAD_COUNT; i++) {
            threadPool.execute(()-&amp;gt;{
                try {
                    s.acquire();
                    System.out.println(&amp;quot;save data&amp;quot;);
                    s.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        threadPool.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Semaphore类可以控制同时访问特定资源的线程数量。例如上述代码有30个线程，但是只能有10个线程来访问数据库（打印save data）。&lt;/p&gt;

&lt;h3 id=&#34;exchanger类&#34;&gt;Exchanger类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ExchangerTest {

    private static final Exchanger&amp;lt;String&amp;gt; exgr = new Exchanger&amp;lt;&amp;gt;();

    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);

    public static void main(String[] args) {

        threadPool.execute(()-&amp;gt;{
            String A = &amp;quot;流水A&amp;quot;;
            try {
                String B = exgr.exchange(A + Thread.currentThread().getName());
                System.out.println(Thread.currentThread().getName()+A.equals(B)+ &amp;quot; A: &amp;quot; + A + &amp;quot; B: &amp;quot; + B);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        threadPool.execute(()-&amp;gt;{
            String B = &amp;quot;流水B&amp;quot;;
            try {
                String A = exgr.exchange(B+ Thread.currentThread().getName());
                System.out.println(Thread.currentThread().getName()+A.equals(B)+ &amp;quot; A: &amp;quot; + A + &amp;quot; B: &amp;quot; + B);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        threadPool.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以控制两个线程交换彼此数据。如果两个线程有一个exchange()方法没有执行，则会一直等待。exchange()方法里也可以设置最大等待时间。&lt;/p&gt;

&lt;p&gt;参考：java并发编程艺术&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Volatile和synchronized</title>
      <link>https://pallcard.github.io/2019/volatile%E5%92%8Csynchronized/</link>
      <pubDate>Wed, 07 Aug 2019 21:20:13 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/volatile%E5%92%8Csynchronized/</guid>
      <description>

&lt;h3 id=&#34;volatile&#34;&gt;volatile&lt;/h3&gt;

&lt;p&gt;volatile是轻量级的synchronized，它可以在并发中保证共享变量的可见性&lt;/p&gt;

&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;

&lt;p&gt;volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行写回到系统内存中。
为了保证缓存一致性，每个处理器会通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己
缓存行对应的内存地址被修改了，就会将当前处理器的缓存行失效，当处理器要对这个数据进行操作时，就会重新从系统内存
中把数据读取到缓存中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Lock前缀指令会引起处理器缓存回写到内存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个处理器到缓存回写到内存回导致其他处理器缓存失效。（处理器使用嗅探技术保证它到内部缓存、系统内存和其他处理器
缓存到数据在总线上保持一致）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;synchronized&#34;&gt;synchronized&lt;/h3&gt;

&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;

&lt;p&gt;synchronized用到锁是存储在对象头里面的，对象头由 MarkWord、类型指针、数组长度（对象为数组时）。&lt;/p&gt;

&lt;p&gt;markword（&lt;strong&gt;表格中空白格子为向左合并&lt;/strong&gt;）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;锁状态&lt;/th&gt;
&lt;th&gt;25bit&lt;/th&gt;
&lt;th&gt;4bit&lt;/th&gt;
&lt;th&gt;1bit&lt;/th&gt;
&lt;th&gt;2bit&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无锁&lt;/td&gt;
&lt;td&gt;对象hashCode&lt;/td&gt;
&lt;td&gt;对象分代年龄&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;轻量级锁&lt;/td&gt;
&lt;td&gt;指向栈中指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;重量级锁&lt;/td&gt;
&lt;td&gt;指向互斥量（重量级锁）指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GC标记&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;偏向锁&lt;/td&gt;
&lt;td&gt;线程ID(23bit) Epoch(2bit)&lt;/td&gt;
&lt;td&gt;对象分代年龄&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Monitor类型对象，重量级锁状态下，MarkWork里指针指向的对象。&lt;/p&gt;

&lt;h4 id=&#34;synchronized-1&#34;&gt;synchronized&lt;/h4&gt;

&lt;p&gt;用来修饰方法（静态方法、实例方法）、代码块
synchronized加锁是指竞争获取对象头MarkWord重量级锁下指向Monitor类型对象，jdk1.6后进行了锁优化&lt;/p&gt;

&lt;h4 id=&#34;原理-1&#34;&gt;原理&lt;/h4&gt;

&lt;p&gt;jdk1.6前，进入synchronized修饰的方法或代码块前要先获取重量级锁（对象头里面指向Monitor类型的对象）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;静态方法 获取类的Class对象对应的Monitor对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实例方法 获取类的实例对象对应的Monitor对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码块 修饰的代码块自己指定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized修饰的代码块，编译阶段回在方法前后生成monitorenter、monitorexit指令&lt;/p&gt;

&lt;p&gt;每个对象都有一个Monitor对象，线程通过执行monitorenter指令获取Monitor对象的拥有权。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果拥有当前Monitor对象的线程数为0，则执行_count++,当前线程称为Monitor对象的拥有者&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果当前线程已经拥有此Monitor对象，则将_count++&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果其他线程有此Monitor对象，则当前线程阻塞直到Monitor计数_count==0,然后重新竞争获取锁&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;获取重量锁&#34;&gt;获取重量锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当线程执行到monitorenter指令，会进入ObjectMonitor对象的_EntryList队列，通过CAS会将_owner指针指向当前线程，同时_count++，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当前线程执行monitorexit指令，会释放持有的Monitor对象，并将_owner置为null同时_count&amp;ndash;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果调用wait()，同上，但是会进入_WaitSet队列,等待被唤醒。(看到没：wait状态的线程在唤醒之后，还得需要获取锁④，然后执行完毕)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁优化：_owner指向当前线程调用的函数涉及到了特权指令Mutex Lock导致用户态线程和内核态线程之间进行切换，切换过程影响效率&lt;/p&gt;

&lt;h4 id=&#34;获取偏向锁&#34;&gt;获取偏向锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因:大部分情况下不会存在线程竞争，而且只会有&lt;strong&gt;同一个线程进入临界区&lt;/strong&gt;，为了减少同一线程获取锁带来的消耗，所以当进入临界区前不会先去获取重量锁，而是先获取偏向锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;膨胀成轻量级锁：偏向锁主要是为了解决同一个线程进入临界区，当有超过一个线程竞争偏向锁，就会膨胀为轻量级锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取偏向锁过程：
先判断是否能开启偏向锁，如果可以 =&amp;gt; 将偏向锁偏向线程ID用CAS(相对于轻量级锁获取和释放都需要CAS操作费时，偏向锁只有这一次)修改为当前线程ID。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;获取轻量锁&#34;&gt;获取轻量锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因:在多个线程都会尝试进入临界区的情况下，&lt;strong&gt;多个线程只会交替进入临界区&lt;/strong&gt;，不会存在锁竞争，为了减少重量级锁系统调用造成的消耗。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;膨胀成重量级锁：当多个线程同一时间都尝试获取锁，则会膨胀为重量级锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取轻量级锁获取过程：
如果当前无锁并且不可偏向，会尝试获取轻量级锁，将MarkWord拷贝到当前线程的栈帧中的LockRecord，然后通过CAS更新MarkWord内容为指向当前线程LockRecord的指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和偏向锁的区别：偏向锁是同一个线程多次获取锁，轻量级锁是多个线程交替获取锁。相同点是假定都不存在锁竞争。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因： 还是大部分情况下，线程持有锁的时间很短，当一个线程获取锁了以后，其他线程尝试获取锁就会进入阻塞状态，挂起-&amp;gt;恢复都需要在用户态和内核态之间进行切换。此时如果让后来的线程进行自旋一段时间(for循环)，在获取锁，可能就会获取，也就避免了转入内核态。
JDK1.6引入了自适应的自旋锁，即根据具体情况结合前面旋转的次数决定此次需要旋转的次数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优点：如果线程占用锁的时间比较短则自旋操作很有效，避免进入内核态&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点:如果线程占用锁的时间比较长则自旋操作白白耗费CPU资源，倒不如挂起。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：java并发编程艺术&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://pallcard.github.io/2019/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 06 Aug 2019 22:10:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h2 id=&#34;装饰者模式&#34;&gt;装饰者模式&lt;/h2&gt;

&lt;p&gt;在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;

&lt;h2 id=&#34;举例说明&#34;&gt;举例说明&lt;/h2&gt;

&lt;p&gt;包含四个部分&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;抽象组件 &amp;mdash;-&amp;gt; IDrink&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体组件 &amp;mdash;-&amp;gt; Coffee&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;抽象装饰 &amp;mdash;-&amp;gt; DrinkDecorator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体装饰 &amp;mdash;-&amp;gt; Milk, Ice&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;抽象主键-idrink&#34;&gt;抽象主键 IDrink&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IDrink {
    double cost();
    String describe();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;具体组件-coffee&#34;&gt;具体组件 Coffee&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Coffee implements IDrink{
    @Override
    public double cost() {
        return 10;
    }

    @Override
    public String describe() {
        return &amp;quot;coffer&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽象装饰-drinkdecorator&#34;&gt;抽象装饰 DrinkDecorator&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class DrinkDecorator implements IDrink {
    protected IDrink drink;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽象装饰-milk&#34;&gt;抽象装饰 Milk&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Milk extends DrinkDecorator{

    public Milk(IDrink drink) {
        this.drink = drink;
    }


    @Override
    public double cost() {
        return 1 + this.drink.cost();
    }

    @Override
    public String describe() {
        return  this.drink.describe() + &amp;quot; with milk&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;主要使用类的组合来实现对于一个类进行动态的增加功能。具体组件和抽象装饰都实现了抽象组件，具体组件又是抽象组件的子类，当调用时，可以要修饰的对象传递给修饰类，这样就可以对抽象对类进行功能对增强。&lt;/p&gt;

&lt;h2 id=&#34;使用动态代理对coffer类进行增强&#34;&gt;使用动态代理对coffer类进行增强&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class CoffeeProxyFactory implements InvocationHandler {

    private Object target;

    public CoffeeProxyFactory(Object target) {
        this.target = target;
    }

    public Object getInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke;

        if (&amp;quot;describe&amp;quot;.equals(method.getName())) {
            invoke = method.invoke(target, args);
            invoke += &amp;quot; with milk&amp;quot;;
            return invoke;
        } else {
            invoke = method.invoke(target, args);
//            invoke = 1 + (Integer) invoke;
            return invoke;
        }

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        IDrink drink = new Coffee();
        drink = new Milk(drink);
        drink = new Ice(drink);
        System.out.println(drink.cost());
        System.out.println(drink.describe());

        System.out.println(&amp;quot;+++++++++++++++&amp;quot;);
        System.out.println(&amp;quot;动态代理&amp;quot;);
        System.out.println(&amp;quot;+++++++++++++++&amp;quot;);
        IDrink iDrink = new Coffee();
        IDrink drinkProxy =  (IDrink) new CoffeeProxyFactory(iDrink).getInstance();
        System.out.println(drinkProxy.cost());
        System.out.println(drinkProxy.describe());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;装饰器模式可以在不增加新的装饰类的情况下对已有的功能进行组合而得到新的功能，但得修改客户端代码才能使用新的功能。动态代理则是增加一个新的类来实现功能，哪怕这个功能是对已有功能的组合，但可以不用修改客户端代码。&lt;strong&gt;a.增不增加新类。b.是否需要更改客户端代码&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理模式主要是控制对某个特定对象访问，而装饰模式主要是为了给对象添加行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot注解</title>
      <link>https://pallcard.github.io/2019/springboot%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2019 20:08:00 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E6%B3%A8%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;spring-web-mvc&#34;&gt;Spring Web MVC&lt;/h2&gt;

&lt;h3 id=&#34;requestmapping&#34;&gt;@RequestMapping&lt;/h3&gt;

&lt;p&gt;主要用途是将web请求与请求处理类中的方法进行映射。&lt;/p&gt;

&lt;p&gt;属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;value:映射的请求URL或者其别名&lt;/li&gt;
&lt;li&gt;method:兼容HTTP的方法名&lt;/li&gt;
&lt;li&gt;params:根据HTTP参数的存在、缺省或值对请求进行过滤&lt;/li&gt;
&lt;li&gt;header:根据HTTP Header的存在、缺省或值对请求进行过滤&lt;/li&gt;
&lt;li&gt;consume:设定在HTTP请求正文中允许使用的媒体类型&lt;/li&gt;
&lt;li&gt;product:在HTTP响应体中允许使用的媒体类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般主要使用前3个属性。改注解也可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(value=&amp;quot;/demo&amp;quot;)
public class Demo {
	@RequestMapping(value=&amp;quot;/test&amp;quot;, method=RequestMethod.GET)
	public String test() {
		return &amp;quot;test&amp;quot;;
	}
}
// 说明：请求路径为 /demo/test时，调用test()方法处理
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestbody&#34;&gt;@RequestBody&lt;/h3&gt;

&lt;p&gt;在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过HttpMessageConverter传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。还可以通过 &lt;strong&gt;@Valid&lt;/strong&gt; 注解对请求主体中的参数进行校验。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/api/v1&amp;quot;)
public class UserController {

	@PostMapping(&amp;quot;/Login&amp;quot;)
    public IJSONResult Login(@RequestBody Users user) throws Exception {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestparam&#34;&gt;@RequestParam&lt;/h3&gt;

&lt;p&gt;用于将方法的参数与Web请求的传递的参数进行绑定。使用@RequestParam可以轻松的访问HTTP请求参数的值。该注解的其他属性配置与@PathVariable的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(/users)
public Role getUserRole(@RequestParam(name=&amp;quot;id&amp;quot;, defaultValue=&amp;quot;0&amp;quot;) long id) {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h3&gt;

&lt;p&gt;将方法中的参数绑定到请求URI中的模板变量上。可以通过@RequestMapping注解来指定URI的模板变量，然后使用@PathVariable注解将方法中的参数绑定到模板变量上。特别地，@PathVariable注解允许我们使用value或name属性来给参数取一个别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(&amp;quot;/users/{id}&amp;quot;)
public Role getUserRole(@PathVariable(name=&amp;quot;id&amp;quot;) long id) {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;responsebody&#34;&gt;@ResponseBody&lt;/h3&gt;

&lt;p&gt;@ResponseBody会自动将控制器中方法的返回值写入到HTTP响应中。特别的，@ResponseBody注解只能用在被@Controller注解标记的类中。如果在被@RestController标记的类中，则方法不需要使用@ResponseBody注解进行标注。@RestController相当于是@Controller和@ResponseBody的组合注解。&lt;/p&gt;

&lt;h3 id=&#34;getmapping&#34;&gt;@GetMapping&lt;/h3&gt;

&lt;p&gt;用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是@RequestMapping(method=RequestMethod.GET)的快捷方式。&lt;strong&gt;@PostMapping @PutMapping @DeleteMapping @PatchMapping&lt;/strong&gt;这几个注解与其类似，用于处理不同的请求。&lt;/p&gt;

&lt;h3 id=&#34;controller&#34;&gt;@Controller&lt;/h3&gt;

&lt;p&gt;@Controller是@Component注解的一个延伸，Spring会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。 &lt;strong&gt;一般直接使用@RestController&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;restcontroller&#34;&gt;@RestController&lt;/h3&gt;

&lt;p&gt;@RestController是在Spring 4.0开始引入的，这是一个特定的控制器注解。此注解相当于@Controller和@ResponseBody的快捷方式。当使用此注解时，不需要再在方法上使用@ResponseBody注解。&lt;/p&gt;

&lt;h3 id=&#34;exceptionhandler&#34;&gt;@ExceptionHandler&lt;/h3&gt;

&lt;p&gt;用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被@ExceptionHandler标注的方法。&lt;/p&gt;

&lt;h3 id=&#34;responsestatus&#34;&gt;@ResponseStatus&lt;/h3&gt;

&lt;p&gt;可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(UserNotFoundExceptin.class)
public RespnseEntity&amp;lt;Object&amp;gt; userNotFoundExceptionHandler(UserNotFoundException ex, WebRequest request) {
	UserErrorDetail detail = new UserErrorDetail(new Date(), ex.getMessage(), request.getDescription(false));

	return new ResponseEntity&amp;lt;&amp;gt;(detail, HttpStatus.NOT_FOUND);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;controlleradvice&#34;&gt;@ControllerAdvice&lt;/h3&gt;

&lt;p&gt;@ControllerAdvice是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。@ControllerAdvice需要和@ExceptionHandler、@InitBinder以及@ModelAttribute注解搭配使用，主要是用来处理控制器所抛出的异常信息。首先，我们需要定义一个被@ControllerAdvice所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。此外，在有必要的时候，可以使用@InitBinder在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用@ControllerAdvice注解，就可以快速的创建统一的，自定义的异常处理类。&lt;/p&gt;

&lt;h3 id=&#34;modelattribute&#34;&gt;@ModelAttribute&lt;/h3&gt;

&lt;p&gt;通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。与@PathVariable和@RequestParam注解一样，如果参数名与模型具有相同的名字，则不必指定索引名称。如果使用@ModelAttribute对方法进行标注，Spring会将方法的返回值绑定到具体的Model上。在Spring调用具体的处理方法之前，被@ModelAttribute注解标注的所有方法都将被执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostMapping(&amp;quot;/users&amp;quot;)
public void createUser(@ModelAttribute User user) {
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;crossorigin&#34;&gt;@CrossOrigin&lt;/h3&gt;

&lt;p&gt;将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CrossOrigin
@PostMapping(&amp;quot;/users&amp;quot;)
public void createUser(@ModelAttribute User user) {
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initbinder&#34;&gt;@InitBinder&lt;/h3&gt;

&lt;p&gt;用于标注初始化WebDataBinider的方法，该方法用于对Http请求传递的表单数据进行处理，如时间格式化、字符串处理等。&lt;/p&gt;

&lt;h2 id=&#34;spring-bean&#34;&gt;Spring Bean&lt;/h2&gt;

&lt;h3 id=&#34;componentscan&#34;&gt;@ComponentScan&lt;/h3&gt;

&lt;p&gt;用于配置Spring需要扫描的被组件注解注释的类所在的包。可以通过配置其basePackages属性或者value属性来配置需要扫描的包路径。value属性是basePackages的别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages=&amp;quot;cn.wishhust.domain&amp;quot;)
public class componnetCofig(){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;component&#34;&gt;@Component&lt;/h3&gt;

&lt;p&gt;用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。&lt;/p&gt;

&lt;h3 id=&#34;service&#34;&gt;@Service&lt;/h3&gt;

&lt;p&gt;是@Component的一个延伸（特例），它用于标注业务逻辑类。与@Component注解一样，被此注解标注的类，会自动被Spring所管理。&lt;/p&gt;

&lt;h3 id=&#34;repository&#34;&gt;@Repository&lt;/h3&gt;

&lt;p&gt;是@Component注解的延伸，与@Component注解一样，被此注解标注的类会被Spring自动管理起来，@Repository注解用于标注DAO层的数据持久化类。&lt;/p&gt;

&lt;h2 id=&#34;spring-di-scope&#34;&gt;Spring DI &amp;amp; Scope&lt;/h2&gt;

&lt;h3 id=&#34;dependson&#34;&gt;@DependsOn&lt;/h3&gt;

&lt;p&gt;可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。&lt;/p&gt;

&lt;h3 id=&#34;bean&#34;&gt;@Bean&lt;/h3&gt;

&lt;p&gt;主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。&lt;/p&gt;

&lt;h3 id=&#34;scope&#34;&gt;@Scope&lt;/h3&gt;

&lt;p&gt;@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：singleton、prototype、request、session、globalSession或者其他的自定义范围。&lt;/p&gt;

&lt;p&gt;当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。在默认情况下，Spring IoC容器所初始化的类实例都为singleton。&lt;/p&gt;

&lt;h2 id=&#34;容器配置注解&#34;&gt;容器配置注解&lt;/h2&gt;

&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;

&lt;p&gt;@Autowired注解用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。&lt;/p&gt;

&lt;h3 id=&#34;primary&#34;&gt;@Primary&lt;/h3&gt;

&lt;p&gt;当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。&lt;/p&gt;

&lt;h3 id=&#34;qualifier&#34;&gt;@Qualifier&lt;/h3&gt;

&lt;p&gt;当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。&lt;/p&gt;

&lt;h2 id=&#34;spring-boot注解&#34;&gt;Spring Boot注解&lt;/h2&gt;

&lt;h3 id=&#34;springbootapplication&#34;&gt;@SpringBootApplication&lt;/h3&gt;

&lt;p&gt;@SpringBootApplication注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于@Configuration、@EnableAutoConfiguration和@ComponentScan的组合。在Spring Boot应用程序的主类中，就使用了此注解。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class Application{
 public static void main(String [] args){
   SpringApplication.run(Application.class,args);
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enableautoconfiguration&#34;&gt;@EnableAutoConfiguration&lt;/h3&gt;

&lt;p&gt;@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。&lt;/p&gt;

&lt;p&gt;@ConditionalOnClass与@ConditionalOnMissingClass&lt;/p&gt;

&lt;p&gt;这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass(DataSource.class)
class MySQLAutoConfiguration {
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonbean与-conditionalonmissingbean&#34;&gt;@ConditionalOnBean与@ConditionalOnMissingBean&lt;/h3&gt;

&lt;p&gt;这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalOnBean(name=&amp;quot;dataSource&amp;quot;)
LocalContainerEntityManagerFactoryBean entityManagerFactory(){
 //...
}
@Bean
@ConditionalOnMissingBean
public MyBean myBean(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonproperty&#34;&gt;@ConditionalOnProperty&lt;/h3&gt;

&lt;p&gt;@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalOnProperty(name=&amp;quot;alipay&amp;quot;,havingValue=&amp;quot;on&amp;quot;)
Alipay alipay(){
 return new Alipay();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonresource&#34;&gt;@ConditionalOnResource&lt;/h3&gt;

&lt;p&gt;此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnResource(resources = &amp;quot;classpath:website.properties&amp;quot;)
Properties addWebsiteProperties(){
 //...
}
@ConditionalOnWebApplication与@ConditionalOnNotWebApplication
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnWebApplication
HealthCheckController healthCheckController(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalexpression&#34;&gt;@ConditionalExpression&lt;/h3&gt;

&lt;p&gt;此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalException(&amp;quot;${localstore} &amp;amp;&amp;amp; ${local == &#39;true&#39;}&amp;quot;)
LocalFileStore store(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditional&#34;&gt;@Conditional&lt;/h3&gt;

&lt;p&gt;@Conditional注解可以控制更为复杂的配置条件。在Spring内置的条件控制注解不满足应用需求的时候，可以使用此注解定义自定义的控制条件，以达到自定义的要求。下面是使用该注解的简单示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Conditioanl(CustomConditioanl.class)
CustomProperties addCustomProperties(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>意向锁</title>
      <link>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</link>
      <pubDate>Sat, 20 Jul 2019 22:31:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</guid>
      <description>

&lt;h3 id=&#34;封锁粒度&#34;&gt;封锁粒度&lt;/h3&gt;

&lt;p&gt;一般有两种封锁粒度：&lt;strong&gt;行级锁以及表级锁&lt;/strong&gt;。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。&lt;/p&gt;

&lt;h3 id=&#34;读写锁&#34;&gt;读写锁&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;排它锁（Exclusive），简写为 X 锁，又称写锁。&lt;/li&gt;
&lt;li&gt;共享锁（Shared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
&lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;意向锁&#34;&gt;意向锁&lt;/h3&gt;

&lt;p&gt;使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。&lt;strong&gt;意向锁是一种不与行级锁冲突表级锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系(特别说明，以下是&lt;strong&gt;表锁&lt;/strong&gt;直接的兼容关系)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;IX&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;IS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意向锁不会与行级的共享 / 排他锁互斥。IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;

&lt;p&gt;用户表user：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;lisi&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;wangwu&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务A，更新id为2的用户名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取user表上的IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取id=2数据行的X锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务B，查询user表&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;检查到user表上用IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务B加锁请求阻塞。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务C，更新id为1的用户名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取user表的IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检测到user表有IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;意向锁不排斥，故事务C获得IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;id=1不存在其他行级锁，获取行级X锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说明：若无意向锁，则对于事务B，将要查询表中的行来确定是否存在其他行级锁。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 06 Jul 2019 23:15:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</guid>
      <description>

&lt;h3 id=&#34;一-定义&#34;&gt;一、定义&lt;/h3&gt;

&lt;p&gt;反射（reflection）是java的特征之一，它允许允许中的Java程序获取自身的信息，并且可以操作累或对象的内部属性。&lt;/p&gt;

&lt;h3 id=&#34;二-基本运用&#34;&gt;二、基本运用&lt;/h3&gt;

&lt;p&gt;反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。反射相关的类一般都在 java.lang.relfect 包里。&lt;/p&gt;

&lt;h4 id=&#34;1-获取class对象&#34;&gt;1. 获取Class对象&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo01 {
    public static void main(String[] args) throws Exception{
        String str = new String();
        // 1.通过对象的getClass方法获得
        Class strClass = str.getClass();
        System.out.println(strClass.getName());

        // 2.通过class属性获得
        // 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
        Class strClass2 = String.class;
        System.out.println(strClass2.getName());
        System.out.println(strClass2 == strClass);

        // 3.使用Class类的forName静态方法
        // 注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
        try{
            Class strClass3 = Class.forName(&amp;quot;java.lang.String&amp;quot;);
            System.out.println(strClass3 == strClass2);
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));

        System.out.println(strClass instanceof Object);

    }

}

// 结果：
java.lang.String
java.lang.String
true
true
true
true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;获取Class对象的三种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用某个对象的getClass方法；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接获取某个类型的class属性：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Class类的forName静态方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：在运行期间，一个类，只有一个Class对象产生。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-判断是否为某个类的实例&#34;&gt;2. 判断是否为某个类的实例&lt;/h4&gt;

&lt;p&gt;一般使用instanceof关键字判断是否为某个类的实例，也可以使用反射中Class对象的isInstance()方法（native方法）判断是否为某个类的实例，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));
System.out.println(strClass instanceof Object);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-创建实例&#34;&gt;3. 创建实例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建实例
// 1. newInstance()
String string = (String) strClass.newInstance();
System.out.println(string);

// 2. 先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。
// 这种方法可以指定构造器的实例。
Constructor constructor = strClass.getConstructor(String.class);
String string2 = (String) constructor.newInstance(&amp;quot;23333&amp;quot;);
System.out.println(string2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Class对象的newInstance()方法来创建Class对象对应类的实例。&lt;/li&gt;
&lt;li&gt;先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-获取方法&#34;&gt;4. 获取方法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo02 {

    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; clazz = MethodClass.class;

        // 创建类实例
        Object obj = clazz.newInstance();


        // 获取所有共有方法, 包括继承
        Method[] methods = clazz.getMethods();
        for (Method m : methods) {
            System.out.println(m);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取所有私有方法，不包括继承
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for (Method dm : declaredMethods) {
            System.out.println(dm);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法
        Method add = clazz.getMethod(&amp;quot;add&amp;quot;, int.class, int.class);
        // 调用方法 （要先创建实例对象）
        Object r = add.invoke(obj, 1, 1);
        System.out.println(r);
        System.out.println(add);

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法(私有)
        Method sub = clazz.getDeclaredMethod(&amp;quot;sub&amp;quot;, int.class, int.class);
        sub.setAccessible(true);
        Object result = sub.invoke(obj,12, 2);
        System.out.println(result);

    }


}

class MethodClass {
    public int add(int a, int b) {
        return a + b;
    }
    private int sub(int a, int b){
        return a - b;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getDeclaredMethod()方法可以获取特定的私有方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethod()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>算法016</title>
      <link>https://pallcard.github.io/2019/algorithm016/</link>
      <pubDate>Sat, 06 Jul 2019 17:35:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm016/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;正则表达式匹配问题&lt;/p&gt;

&lt;p&gt;请实现一个函数用来匹配包括 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式。模式中的字符 &amp;lsquo;.&amp;rsquo; 表示任意一个字符，而 &amp;lsquo;*&amp;rsquo; 表示它前面的字符可以出现任意次（包含 0 次）。&lt;/p&gt;

&lt;p&gt;. 一个任意字符&lt;/p&gt;

&lt;p&gt;* 表示*前字符出现（0-？）字符&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;aaa 以下两模式串均可匹配

ab*ac*a  a.a
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;采用两个下标，分别记录目标串与模式串。
循环模式串，若为.，则下标加1；
若为模式串与目标串字符相同，则下标加1，否则看模式串下一个字符算法为*；&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo016 {
    public static void main(String[] args) {
        String string = &amp;quot;aaa&amp;quot;;
        String pattern = &amp;quot;ab*a&amp;quot;;

        int index = 0;
        int i = 0;
        boolean result = true;

        for (i = 0; i &amp;lt; pattern.length(); i++) {
            if (index &amp;gt;= string.length()) {
                result = false;
                break;
            }
            if (pattern.charAt(i) == &#39;.&#39;) {
                index++;
                continue;
            }
            if(pattern.charAt(i) == string.charAt(index)) {
                index++;
            } else if(pattern.charAt(i+1) != &#39;*&#39;) {
                result = false;
                break;
            } else if (pattern.charAt(i+1) == &#39;*&#39;) {
                i++;
            }
        }
        if(index != string.length() || i != pattern.length()) {
            result = false;
        }
        System.out.println(result);
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
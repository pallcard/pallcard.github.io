<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刘科个人博客 on 刘科个人博客</title>
    <link>https://pallcard.github.io/</link>
    <description>Recent content in 刘科个人博客 on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Thu, 08 Aug 2019 21:58:38 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数据库事务</title>
      <link>https://pallcard.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 08 Aug 2019 21:58:38 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</guid>
      <description>

&lt;h3 id=&#34;事务特性&#34;&gt;事务特性&lt;/h3&gt;

&lt;p&gt;ACID：原子性、一致性、隔离性、持久性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原子性：一个事务要么全部成功，要么全部失败&lt;/li&gt;
&lt;li&gt;一致性：事务提交前后，数据库保持一致性状态&lt;/li&gt;
&lt;li&gt;隔离性：一个事务所做的修改，其他事务不可见&lt;/li&gt;
&lt;li&gt;持久性：事务一旦提交，所做修改永久保存到数据库中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关系：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-aidl&#34;&gt;原子性 + 隔离性  ---&amp;gt; 一致性   ---&amp;gt; 结果正确

                     持久性  ----&amp;gt; 应对数据库崩溃

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;并发一致性&#34;&gt;并发一致性&lt;/h3&gt;

&lt;p&gt;当多个事务并发执行时会导致事务不能保证一致性，导致结果出错。&lt;/p&gt;

&lt;p&gt;丢失修改、读脏数据、不可重复读、幻读&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;丢失修改：对于同一数据，T1 修改数据后，T2 又修改数据，T1修改读数据被覆盖&lt;/li&gt;
&lt;li&gt;读脏数据：T1修改数据后，T2读该数据，T1又回滚数据，T2读脏数据&lt;/li&gt;
&lt;li&gt;不可重复读：T1读数据后，T2对该数据进行修改，T1再读该数据，读得的数据值不一致&lt;/li&gt;
&lt;li&gt;幻读：T1读数据（例如count统计表中行数），T2插入一行数据，导致数据不一致&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;三级封锁协议&#34;&gt;三级封锁协议&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一级封锁：当更新数据时，立即加X锁，直到事务结束。  ==&amp;gt; 解决了丢失修改&lt;/li&gt;
&lt;li&gt;二级封锁：在1上，当读数据时，立即加S锁，读完立即释放锁。  ==&amp;gt; 解决了读脏数据&lt;/li&gt;
&lt;li&gt;三级封锁：在2上，当读数据时，立即加S锁，直到事务结束。    ==&amp;gt; 解决了不可重复读&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;两段锁协议&#34;&gt;两段锁协议&lt;/h3&gt;

&lt;p&gt;加锁和解锁分成两个阶段。一个阶段加锁，一个阶段解锁。保证可串行性化调度。&lt;/p&gt;

&lt;h3 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;未提交读：事务的修改未提交前，其他事务可见
读：不加锁； 更新 ： 行级共享锁&lt;/li&gt;
&lt;li&gt;提交读： 事务的修改在未提交前，其他事务不可见
读：行级共享锁； 更新： 行级排他锁&lt;/li&gt;
&lt;li&gt;可重复读： 一个事务中的多次读结果一致
读：行级共享锁； 更新：行级排他锁&lt;/li&gt;
&lt;li&gt;可串行化：事务串行执行
读：表级共享锁； 更新：表级排他锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决的问题&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;未提交读&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;提交读&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;可串行化&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;mysql事务隔离级别的实现&#34;&gt;mysql事务隔离级别的实现&lt;/h3&gt;

&lt;h4 id=&#34;mvcc-多版本并发控制&#34;&gt;MVCC（多版本并发控制）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;版本号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.系统版本号&lt;/p&gt;

&lt;p&gt;一个递增的数字，每开始一个新事务，系统版本号自动递增&lt;/p&gt;

&lt;p&gt;2.事务版本号&lt;/p&gt;

&lt;p&gt;事务开始的系统版本号&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;隐藏列&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MVCC的每行记录后面都保存着两个隐藏的列&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建版本号，创建一个数据行的快照时的版本号&lt;/li&gt;
&lt;li&gt;删除版本号，&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;mvcc具体实现&#34;&gt;MVCC具体实现&lt;/h4&gt;

&lt;p&gt;1.select：满足以下两个条件innodb会返回该行数据：&lt;/p&gt;

&lt;p&gt;（1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。
　　&lt;/p&gt;

&lt;p&gt;（2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。&lt;/p&gt;

&lt;p&gt;　　
2.insert：将新插入的行的创建版本号设置为当前系统的版本号。&lt;/p&gt;

&lt;p&gt;3.delete：将要删除的行的删除版本号设置为当前系统的版本号。&lt;/p&gt;

&lt;p&gt;　　
4.update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。&lt;/p&gt;

&lt;h4 id=&#34;例子&#34;&gt;例子&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;以下表格仅为示意图，方便理解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1). insert操作（事务版本为1）：事务1，插入两行数据&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2). delete操作（事务版本为2）：事务2，删除id为1数据&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3). update操作（事务版本为3）：事务3，更新id为2数据，=&amp;gt;(delete+insert)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;4). select操作（事务版本为4）：事务4，查询所有行，返回结果如下，&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;5). 两个事务：事务5（查询id=2），事务6（更新id=2）&lt;/p&gt;

&lt;p&gt;事务5未执行，事务6执行完&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;事务1.1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务1.2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务6&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务5执行完，第4行创建版本号6&amp;gt;事务版本号5，第3行创建版本号3&amp;lt;=事务版本号5&amp;lt;=删除版本号,故返回为&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;data&lt;/th&gt;
&lt;th&gt;创建版本号&lt;/th&gt;
&lt;th&gt;删除版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;事务3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&#34;快照读与当前读&#34;&gt;快照读与当前读&lt;/h5&gt;

&lt;p&gt;通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快照读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select 的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当前读&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。
读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * from table where ? lock in share mode; 
select * from table where ? for update; 
insert; 
update; 
delete;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;next-key-lock&#34;&gt;Next-Key Lock&lt;/h4&gt;

&lt;p&gt;InnoDB有三种行锁的算法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Record Lock：单个行记录上的锁，&lt;strong&gt;锁定记录上的索引&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Gap Lock：间隙锁，&lt;strong&gt;锁定索引之间的间隙，但是不包含索引本身&lt;/strong&gt;。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://juejin.im/post/5cd8283ae51d453a907b4b29&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://juejin.im/post/5cd8283ae51d453a907b4b29&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java并发工具包</title>
      <link>https://pallcard.github.io/2019/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/</link>
      <pubDate>Wed, 07 Aug 2019 23:22:27 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85/</guid>
      <description>

&lt;h3 id=&#34;引言&#34;&gt;引言&lt;/h3&gt;

&lt;p&gt;JDK并发包中提供了CountDownLatch、CyclicBarrier、Semaphore工具类来实现并发流程的控制。
Exchanger提供了线程间交换数据的方法。&lt;/p&gt;

&lt;h3 id=&#34;join-方法&#34;&gt;join()方法&lt;/h3&gt;

&lt;p&gt;需求：实现主程序要等待其他线程完成后，在继续执行。很容易想到使用join()方法来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JoinCountDownLatchTest {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行1&amp;quot;);
        });
        Thread thread2 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行2&amp;quot;);
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(&amp;quot;主线程&amp;quot;);
    }
}

/* 输出结果：
执行1
执行2
主线程
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;join()原理是不停的检查join线程是否存活，直到join线程都中止，线程才会this.notifyAll()。&lt;/p&gt;

&lt;h3 id=&#34;countdownlatch类&#34;&gt;CountDownLatch类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CountDownLatchTest {

    public static void main(String[] args) throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(2);
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行1&amp;quot;);
            countDownLatch.countDown();
        });

        Thread thread2 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行2&amp;quot;);
            countDownLatch.countDown();  
        });
        thread1.start();
        thread2.start();

        countDownLatch.await(10, TimeUnit.MILLISECONDS);

        System.out.println(&amp;quot;主线程&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;CountDownLatch类的构造函数需要传入数字N，表示你想等待N个点（N个线程或N个步骤）。上述代码中，
传入的N为2，则表示主线程要等待两个点后，才会继续执行主程序，在此之前程序会一直阻塞在countDownLatch.await()方法这，
（上述程序的await方法带一个指定时间，只会阻塞到指定时间）。其中调用countDown()函数时，N会减1，当N=0时，
结束阻塞。&lt;/p&gt;

&lt;p&gt;若将上述类中的方法该成如下代码，则执行1，执行2会在主线程之前打印，但是等待i不一定会在主线程之前打印，
想要实现，需要将构造中的N改为3，在for循环后面调用countDown()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(2);
        Thread thread1 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行1&amp;quot;);
            countDownLatch.countDown();
        });

        Thread thread2 = new Thread(() -&amp;gt; {
            System.out.println(&amp;quot;执行2&amp;quot;);
            countDownLatch.countDown();
            for(int i = 0; i &amp;lt; 1000; i++) {
                System.out.println(&amp;quot;等待&amp;quot;+ (i+1));
            }
//            countDownLatch.countDown();
        });
        thread1.start();
        thread2.start();

        countDownLatch.await();

        System.out.println(&amp;quot;主线程&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cyclicbarrier类&#34;&gt;CyclicBarrier类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CyclicBarrierTest {
    public static void main(String[] args) throws InterruptedException {

        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        // 若将3改为4，程序会一直等待，没有4个线程到达屏障
//        CyclicBarrier cyclicBarrier = new CyclicBarrier(4);

        // 若将3改为4，程序会一直等待，没有4个线程到达屏障, 优先执行当任务也不会执行
        CyclicBarrier cyclicBarrier2 = new CyclicBarrier(3, new Runnable() {
            @Override
            public void run() {
                System.out.println(&amp;quot;优先执行&amp;quot;);
            }
        });

        Thread thread1 = new Thread(() -&amp;gt; {
            for (int i = 0; i &amp;lt; 10; i++) {
                System.out.println(&amp;quot;到达屏障前&amp;quot;);
            }
            try {
                cyclicBarrier.await();
                cyclicBarrier2.await();
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;执行1&amp;quot;);
        });

        Thread thread2 = new Thread(() -&amp;gt; {
            try {
                cyclicBarrier.await();
                cyclicBarrier2.await();
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(&amp;quot;执行2&amp;quot;);
        });

        thread1.start();
        thread2.start();

        try {
            cyclicBarrier.await();
            cyclicBarrier2.await();
        } catch (Exception e) {
            e.printStackTrace();
        }
        Thread.sleep(1000);

        System.out.println(&amp;quot;主线程&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CyclicBarrier让一组线程到达一个屏障时被阻塞，例如，上述代码若将屏障数设置为4，则只会打印到达屏障前，
然后就会3个线程都会被阻塞。在CyclicBarrier的构造函数中也可以添加一个任务，到线程数达到屏障要求时，线程
继续执行，并且构造函数中的会优先执行。&lt;/p&gt;

&lt;h4 id=&#34;实例&#34;&gt;实例&lt;/h4&gt;

&lt;p&gt;计算银行的账单流水，使用多个线程进行计算，然后进行汇总。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BankWaterService implements Runnable{

    // 4个屏障处理完成，执行当前类当run方法
    private CyclicBarrier cyclicBarrier = new CyclicBarrier(4, this);

    private Executor executor = Executors.newFixedThreadPool(4);

    private ConcurrentHashMap&amp;lt;String, Integer&amp;gt; sheetBankWaterCount = new ConcurrentHashMap&amp;lt;&amp;gt;();

    @Override
    public void run() {
        int result = 0;
        for(Map.Entry&amp;lt;String, Integer&amp;gt; sheet : sheetBankWaterCount.entrySet()) {
            result += sheet.getValue();
        }

        sheetBankWaterCount.put(&amp;quot;result&amp;quot;, result);
        System.out.println(result);
    }

    private void count(){
        for (int i = 0; i &amp;lt; 4; i++) {
            executor.execute(()-&amp;gt;{
                sheetBankWaterCount.put(Thread.currentThread().getName(), 1);
                System.out.println(Thread.currentThread().getName() + 1);
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }

    }

    public static void main(String[] args) {
        BankWaterService bankWaterService = new BankWaterService();
        bankWaterService.count();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;首先屏障设置为4，优先执行的任务传入this，表示当4个线程到达后会优先执行类中的run()方法。对于4个线程
到计算完自己的流水后到达屏障阻塞，到4个线程都计算完毕后，会优先执行本类中的run()方法，从而完成了对于
流水的统计。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CyclicBarrier的计数器可以使用reset()方法重置，这正好解释了Cyclic循环的意思。&lt;/p&gt;

&lt;h3 id=&#34;semaphore类&#34;&gt;Semaphore类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SemaphoreTest {

    private static final int THREAD_COUNT = 30;

    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);

    private static Semaphore s = new Semaphore(10);

    public static void main(String[] args) {
        for (int i = 0; i &amp;lt; THREAD_COUNT; i++) {
            threadPool.execute(()-&amp;gt;{
                try {
                    s.acquire();
                    System.out.println(&amp;quot;save data&amp;quot;);
                    s.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        threadPool.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Semaphore类可以控制同时访问特定资源的线程数量。例如上述代码有30个线程，但是只能有10个线程来访问数据库（打印save data）。&lt;/p&gt;

&lt;h3 id=&#34;exchanger类&#34;&gt;Exchanger类&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ExchangerTest {

    private static final Exchanger&amp;lt;String&amp;gt; exgr = new Exchanger&amp;lt;&amp;gt;();

    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);

    public static void main(String[] args) {

        threadPool.execute(()-&amp;gt;{
            String A = &amp;quot;流水A&amp;quot;;
            try {
                String B = exgr.exchange(A + Thread.currentThread().getName());
                System.out.println(Thread.currentThread().getName()+A.equals(B)+ &amp;quot; A: &amp;quot; + A + &amp;quot; B: &amp;quot; + B);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        threadPool.execute(()-&amp;gt;{
            String B = &amp;quot;流水B&amp;quot;;
            try {
                String A = exgr.exchange(B+ Thread.currentThread().getName());
                System.out.println(Thread.currentThread().getName()+A.equals(B)+ &amp;quot; A: &amp;quot; + A + &amp;quot; B: &amp;quot; + B);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        threadPool.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以控制两个线程交换彼此数据。如果两个线程有一个exchange()方法没有执行，则会一直等待。exchange()方法里也可以设置最大等待时间。&lt;/p&gt;

&lt;p&gt;参考：java并发编程艺术&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Volatile和synchronized</title>
      <link>https://pallcard.github.io/2019/volatile%E5%92%8Csynchronized/</link>
      <pubDate>Wed, 07 Aug 2019 21:20:13 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/volatile%E5%92%8Csynchronized/</guid>
      <description>

&lt;h3 id=&#34;volatile&#34;&gt;volatile&lt;/h3&gt;

&lt;p&gt;volatile是轻量级的synchronized，它可以在并发中保证共享变量的可见性&lt;/p&gt;

&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;

&lt;p&gt;volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行写回到系统内存中。
为了保证缓存一致性，每个处理器会通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己
缓存行对应的内存地址被修改了，就会将当前处理器的缓存行失效，当处理器要对这个数据进行操作时，就会重新从系统内存
中把数据读取到缓存中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Lock前缀指令会引起处理器缓存回写到内存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个处理器到缓存回写到内存回导致其他处理器缓存失效。（处理器使用嗅探技术保证它到内部缓存、系统内存和其他处理器
缓存到数据在总线上保持一致）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;synchronized&#34;&gt;synchronized&lt;/h3&gt;

&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;

&lt;p&gt;synchronized用到锁是存储在对象头里面的，对象头由 MarkWord、类型指针、数组长度（对象为数组时）。&lt;/p&gt;

&lt;p&gt;markword（&lt;strong&gt;表格中空白格子为向左合并&lt;/strong&gt;）&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;锁状态&lt;/th&gt;
&lt;th&gt;25bit&lt;/th&gt;
&lt;th&gt;4bit&lt;/th&gt;
&lt;th&gt;1bit&lt;/th&gt;
&lt;th&gt;2bit&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;无锁&lt;/td&gt;
&lt;td&gt;对象hashCode&lt;/td&gt;
&lt;td&gt;对象分代年龄&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;轻量级锁&lt;/td&gt;
&lt;td&gt;指向栈中指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;重量级锁&lt;/td&gt;
&lt;td&gt;指向互斥量（重量级锁）指针&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GC标记&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;偏向锁&lt;/td&gt;
&lt;td&gt;线程ID(23bit) Epoch(2bit)&lt;/td&gt;
&lt;td&gt;对象分代年龄&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Monitor类型对象，重量级锁状态下，MarkWork里指针指向的对象。&lt;/p&gt;

&lt;h4 id=&#34;synchronized-1&#34;&gt;synchronized&lt;/h4&gt;

&lt;p&gt;用来修饰方法（静态方法、实例方法）、代码块
synchronized加锁是指竞争获取对象头MarkWord重量级锁下指向Monitor类型对象，jdk1.6后进行了锁优化&lt;/p&gt;

&lt;h4 id=&#34;原理-1&#34;&gt;原理&lt;/h4&gt;

&lt;p&gt;jdk1.6前，进入synchronized修饰的方法或代码块前要先获取重量级锁（对象头里面指向Monitor类型的对象）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;静态方法 获取类的Class对象对应的Monitor对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实例方法 获取类的实例对象对应的Monitor对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码块 修饰的代码块自己指定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized修饰的代码块，编译阶段回在方法前后生成monitorenter、monitorexit指令&lt;/p&gt;

&lt;p&gt;每个对象都有一个Monitor对象，线程通过执行monitorenter指令获取Monitor对象的拥有权。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果拥有当前Monitor对象的线程数为0，则执行_count++,当前线程称为Monitor对象的拥有者&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果当前线程已经拥有此Monitor对象，则将_count++&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果其他线程有此Monitor对象，则当前线程阻塞直到Monitor计数_count==0,然后重新竞争获取锁&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;获取重量锁&#34;&gt;获取重量锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当线程执行到monitorenter指令，会进入ObjectMonitor对象的_EntryList队列，通过CAS会将_owner指针指向当前线程，同时_count++，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当前线程执行monitorexit指令，会释放持有的Monitor对象，并将_owner置为null同时_count&amp;ndash;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果调用wait()，同上，但是会进入_WaitSet队列,等待被唤醒。(看到没：wait状态的线程在唤醒之后，还得需要获取锁④，然后执行完毕)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁优化：_owner指向当前线程调用的函数涉及到了特权指令Mutex Lock导致用户态线程和内核态线程之间进行切换，切换过程影响效率&lt;/p&gt;

&lt;h4 id=&#34;获取偏向锁&#34;&gt;获取偏向锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因:大部分情况下不会存在线程竞争，而且只会有&lt;strong&gt;同一个线程进入临界区&lt;/strong&gt;，为了减少同一线程获取锁带来的消耗，所以当进入临界区前不会先去获取重量锁，而是先获取偏向锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;膨胀成轻量级锁：偏向锁主要是为了解决同一个线程进入临界区，当有超过一个线程竞争偏向锁，就会膨胀为轻量级锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取偏向锁过程：
先判断是否能开启偏向锁，如果可以 =&amp;gt; 将偏向锁偏向线程ID用CAS(相对于轻量级锁获取和释放都需要CAS操作费时，偏向锁只有这一次)修改为当前线程ID。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;获取轻量锁&#34;&gt;获取轻量锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因:在多个线程都会尝试进入临界区的情况下，&lt;strong&gt;多个线程只会交替进入临界区&lt;/strong&gt;，不会存在锁竞争，为了减少重量级锁系统调用造成的消耗。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;膨胀成重量级锁：当多个线程同一时间都尝试获取锁，则会膨胀为重量级锁。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取轻量级锁获取过程：
如果当前无锁并且不可偏向，会尝试获取轻量级锁，将MarkWord拷贝到当前线程的栈帧中的LockRecord，然后通过CAS更新MarkWord内容为指向当前线程LockRecord的指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和偏向锁的区别：偏向锁是同一个线程多次获取锁，轻量级锁是多个线程交替获取锁。相同点是假定都不存在锁竞争。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因： 还是大部分情况下，线程持有锁的时间很短，当一个线程获取锁了以后，其他线程尝试获取锁就会进入阻塞状态，挂起-&amp;gt;恢复都需要在用户态和内核态之间进行切换。此时如果让后来的线程进行自旋一段时间(for循环)，在获取锁，可能就会获取，也就避免了转入内核态。
JDK1.6引入了自适应的自旋锁，即根据具体情况结合前面旋转的次数决定此次需要旋转的次数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优点：如果线程占用锁的时间比较短则自旋操作很有效，避免进入内核态&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点:如果线程占用锁的时间比较长则自旋操作白白耗费CPU资源，倒不如挂起。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：java并发编程艺术&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://pallcard.github.io/2019/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 06 Aug 2019 22:10:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>

&lt;h2 id=&#34;装饰者模式&#34;&gt;装饰者模式&lt;/h2&gt;

&lt;p&gt;在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;

&lt;h2 id=&#34;举例说明&#34;&gt;举例说明&lt;/h2&gt;

&lt;p&gt;包含四个部分&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;抽象组件 &amp;mdash;-&amp;gt; IDrink&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体组件 &amp;mdash;-&amp;gt; Coffee&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;抽象装饰 &amp;mdash;-&amp;gt; DrinkDecorator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具体装饰 &amp;mdash;-&amp;gt; Milk, Ice&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;抽象主键-idrink&#34;&gt;抽象主键 IDrink&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IDrink {
    double cost();
    String describe();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;具体组件-coffee&#34;&gt;具体组件 Coffee&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Coffee implements IDrink{
    @Override
    public double cost() {
        return 10;
    }

    @Override
    public String describe() {
        return &amp;quot;coffer&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽象装饰-drinkdecorator&#34;&gt;抽象装饰 DrinkDecorator&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class DrinkDecorator implements IDrink {
    protected IDrink drink;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;抽象装饰-milk&#34;&gt;抽象装饰 Milk&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Milk extends DrinkDecorator{

    public Milk(IDrink drink) {
        this.drink = drink;
    }


    @Override
    public double cost() {
        return 1 + this.drink.cost();
    }

    @Override
    public String describe() {
        return  this.drink.describe() + &amp;quot; with milk&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;主要使用类的组合来实现对于一个类进行动态的增加功能。具体组件和抽象装饰都实现了抽象组件，具体组件又是抽象组件的子类，当调用时，可以要修饰的对象传递给修饰类，这样就可以对抽象对类进行功能对增强。&lt;/p&gt;

&lt;h2 id=&#34;使用动态代理对coffer类进行增强&#34;&gt;使用动态代理对coffer类进行增强&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class CoffeeProxyFactory implements InvocationHandler {

    private Object target;

    public CoffeeProxyFactory(Object target) {
        this.target = target;
    }

    public Object getInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke;

        if (&amp;quot;describe&amp;quot;.equals(method.getName())) {
            invoke = method.invoke(target, args);
            invoke += &amp;quot; with milk&amp;quot;;
            return invoke;
        } else {
            invoke = method.invoke(target, args);
//            invoke = 1 + (Integer) invoke;
            return invoke;
        }

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        IDrink drink = new Coffee();
        drink = new Milk(drink);
        drink = new Ice(drink);
        System.out.println(drink.cost());
        System.out.println(drink.describe());

        System.out.println(&amp;quot;+++++++++++++++&amp;quot;);
        System.out.println(&amp;quot;动态代理&amp;quot;);
        System.out.println(&amp;quot;+++++++++++++++&amp;quot;);
        IDrink iDrink = new Coffee();
        IDrink drinkProxy =  (IDrink) new CoffeeProxyFactory(iDrink).getInstance();
        System.out.println(drinkProxy.cost());
        System.out.println(drinkProxy.describe());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;装饰器模式可以在不增加新的装饰类的情况下对已有的功能进行组合而得到新的功能，但得修改客户端代码才能使用新的功能。动态代理则是增加一个新的类来实现功能，哪怕这个功能是对已有功能的组合，但可以不用修改客户端代码。&lt;strong&gt;a.增不增加新类。b.是否需要更改客户端代码&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理模式主要是控制对某个特定对象访问，而装饰模式主要是为了给对象添加行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>SpringBoot注解</title>
      <link>https://pallcard.github.io/2019/springboot%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2019 20:08:00 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E6%B3%A8%E8%A7%A3/</guid>
      <description>

&lt;h2 id=&#34;spring-web-mvc&#34;&gt;Spring Web MVC&lt;/h2&gt;

&lt;h3 id=&#34;requestmapping&#34;&gt;@RequestMapping&lt;/h3&gt;

&lt;p&gt;主要用途是将web请求与请求处理类中的方法进行映射。&lt;/p&gt;

&lt;p&gt;属性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;value:映射的请求URL或者其别名&lt;/li&gt;
&lt;li&gt;method:兼容HTTP的方法名&lt;/li&gt;
&lt;li&gt;params:根据HTTP参数的存在、缺省或值对请求进行过滤&lt;/li&gt;
&lt;li&gt;header:根据HTTP Header的存在、缺省或值对请求进行过滤&lt;/li&gt;
&lt;li&gt;consume:设定在HTTP请求正文中允许使用的媒体类型&lt;/li&gt;
&lt;li&gt;product:在HTTP响应体中允许使用的媒体类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一般主要使用前3个属性。改注解也可以对类进行标记，这样类中的处理方法在映射请求路径时，会自动将类上@RequestMapping设置的value拼接到方法中映射路径之前。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
@RequestMapping(value=&amp;quot;/demo&amp;quot;)
public class Demo {
	@RequestMapping(value=&amp;quot;/test&amp;quot;, method=RequestMethod.GET)
	public String test() {
		return &amp;quot;test&amp;quot;;
	}
}
// 说明：请求路径为 /demo/test时，调用test()方法处理
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestbody&#34;&gt;@RequestBody&lt;/h3&gt;

&lt;p&gt;在处理请求方法的参数列表中使用，它可以将请求主体中的参数绑定到一个对象中，请求主体参数是通过HttpMessageConverter传递的，根据请求主体中的参数名与对象的属性名进行匹配并绑定值。还可以通过 &lt;strong&gt;@Valid&lt;/strong&gt; 注解对请求主体中的参数进行校验。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RestController
@RequestMapping(&amp;quot;/api/v1&amp;quot;)
public class UserController {

	@PostMapping(&amp;quot;/Login&amp;quot;)
    public IJSONResult Login(@RequestBody Users user) throws Exception {
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;requestparam&#34;&gt;@RequestParam&lt;/h3&gt;

&lt;p&gt;用于将方法的参数与Web请求的传递的参数进行绑定。使用@RequestParam可以轻松的访问HTTP请求参数的值。该注解的其他属性配置与@PathVariable的配置相同，特别的，如果传递的参数为空，还可以通过defaultValue设置一个默认值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(/users)
public Role getUserRole(@RequestParam(name=&amp;quot;id&amp;quot;, defaultValue=&amp;quot;0&amp;quot;) long id) {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pathvariable&#34;&gt;@PathVariable&lt;/h3&gt;

&lt;p&gt;将方法中的参数绑定到请求URI中的模板变量上。可以通过@RequestMapping注解来指定URI的模板变量，然后使用@PathVariable注解将方法中的参数绑定到模板变量上。特别地，@PathVariable注解允许我们使用value或name属性来给参数取一个别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@GetMapping(&amp;quot;/users/{id}&amp;quot;)
public Role getUserRole(@PathVariable(name=&amp;quot;id&amp;quot;) long id) {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;responsebody&#34;&gt;@ResponseBody&lt;/h3&gt;

&lt;p&gt;@ResponseBody会自动将控制器中方法的返回值写入到HTTP响应中。特别的，@ResponseBody注解只能用在被@Controller注解标记的类中。如果在被@RestController标记的类中，则方法不需要使用@ResponseBody注解进行标注。@RestController相当于是@Controller和@ResponseBody的组合注解。&lt;/p&gt;

&lt;h3 id=&#34;getmapping&#34;&gt;@GetMapping&lt;/h3&gt;

&lt;p&gt;用于处理HTTP GET请求，并将请求映射到具体的处理方法中。具体来说，@GetMapping是一个组合注解，它相当于是@RequestMapping(method=RequestMethod.GET)的快捷方式。&lt;strong&gt;@PostMapping @PutMapping @DeleteMapping @PatchMapping&lt;/strong&gt;这几个注解与其类似，用于处理不同的请求。&lt;/p&gt;

&lt;h3 id=&#34;controller&#34;&gt;@Controller&lt;/h3&gt;

&lt;p&gt;@Controller是@Component注解的一个延伸，Spring会自动扫描并配置被该注解标注的类。此注解用于标注Spring MVC的控制器。 &lt;strong&gt;一般直接使用@RestController&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;restcontroller&#34;&gt;@RestController&lt;/h3&gt;

&lt;p&gt;@RestController是在Spring 4.0开始引入的，这是一个特定的控制器注解。此注解相当于@Controller和@ResponseBody的快捷方式。当使用此注解时，不需要再在方法上使用@ResponseBody注解。&lt;/p&gt;

&lt;h3 id=&#34;exceptionhandler&#34;&gt;@ExceptionHandler&lt;/h3&gt;

&lt;p&gt;用于标注处理特定类型异常类所抛出异常的方法。当控制器中的方法抛出异常时，Spring会自动捕获异常，并将捕获的异常信息传递给被@ExceptionHandler标注的方法。&lt;/p&gt;

&lt;h3 id=&#34;responsestatus&#34;&gt;@ResponseStatus&lt;/h3&gt;

&lt;p&gt;可以标注请求处理方法。使用此注解，可以指定响应所需要的HTTP STATUS。特别地，我们可以使用HttpStauts类对该注解的value属性进行赋值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ResponseStatus(HttpStatus.BAD_REQUEST)
@ExceptionHandler(UserNotFoundExceptin.class)
public RespnseEntity&amp;lt;Object&amp;gt; userNotFoundExceptionHandler(UserNotFoundException ex, WebRequest request) {
	UserErrorDetail detail = new UserErrorDetail(new Date(), ex.getMessage(), request.getDescription(false));

	return new ResponseEntity&amp;lt;&amp;gt;(detail, HttpStatus.NOT_FOUND);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;controlleradvice&#34;&gt;@ControllerAdvice&lt;/h3&gt;

&lt;p&gt;@ControllerAdvice是@Component注解的一个延伸注解，Spring会自动扫描并检测被@ControllerAdvice所标注的类。@ControllerAdvice需要和@ExceptionHandler、@InitBinder以及@ModelAttribute注解搭配使用，主要是用来处理控制器所抛出的异常信息。首先，我们需要定义一个被@ControllerAdvice所标注的类，在该类中，定义一个用于处理具体异常的方法，并使用@ExceptionHandler注解进行标记。此外，在有必要的时候，可以使用@InitBinder在类中进行全局的配置，还可以使用@ModelAttribute配置与视图相关的参数。使用@ControllerAdvice注解，就可以快速的创建统一的，自定义的异常处理类。&lt;/p&gt;

&lt;h3 id=&#34;modelattribute&#34;&gt;@ModelAttribute&lt;/h3&gt;

&lt;p&gt;通过此注解，可以通过模型索引名称来访问已经存在于控制器中的model。与@PathVariable和@RequestParam注解一样，如果参数名与模型具有相同的名字，则不必指定索引名称。如果使用@ModelAttribute对方法进行标注，Spring会将方法的返回值绑定到具体的Model上。在Spring调用具体的处理方法之前，被@ModelAttribute注解标注的所有方法都将被执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@PostMapping(&amp;quot;/users&amp;quot;)
public void createUser(@ModelAttribute User user) {
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;crossorigin&#34;&gt;@CrossOrigin&lt;/h3&gt;

&lt;p&gt;将为请求处理类或请求处理方法提供跨域调用支持。如果我们将此注解标注类，那么类中的所有方法都将获得支持跨域的能力。使用此注解的好处是可以微调跨域行为。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@CrossOrigin
@PostMapping(&amp;quot;/users&amp;quot;)
public void createUser(@ModelAttribute User user) {
	...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initbinder&#34;&gt;@InitBinder&lt;/h3&gt;

&lt;p&gt;用于标注初始化WebDataBinider的方法，该方法用于对Http请求传递的表单数据进行处理，如时间格式化、字符串处理等。&lt;/p&gt;

&lt;h2 id=&#34;spring-bean&#34;&gt;Spring Bean&lt;/h2&gt;

&lt;h3 id=&#34;componentscan&#34;&gt;@ComponentScan&lt;/h3&gt;

&lt;p&gt;用于配置Spring需要扫描的被组件注解注释的类所在的包。可以通过配置其basePackages属性或者value属性来配置需要扫描的包路径。value属性是basePackages的别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages=&amp;quot;cn.wishhust.domain&amp;quot;)
public class componnetCofig(){
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;component&#34;&gt;@Component&lt;/h3&gt;

&lt;p&gt;用于标注一个普通的组件类，它没有明确的业务范围，只是通知Spring被此注解的类需要被纳入到Spring Bean容器中并进行管理。&lt;/p&gt;

&lt;h3 id=&#34;service&#34;&gt;@Service&lt;/h3&gt;

&lt;p&gt;是@Component的一个延伸（特例），它用于标注业务逻辑类。与@Component注解一样，被此注解标注的类，会自动被Spring所管理。&lt;/p&gt;

&lt;h3 id=&#34;repository&#34;&gt;@Repository&lt;/h3&gt;

&lt;p&gt;是@Component注解的延伸，与@Component注解一样，被此注解标注的类会被Spring自动管理起来，@Repository注解用于标注DAO层的数据持久化类。&lt;/p&gt;

&lt;h2 id=&#34;spring-di-scope&#34;&gt;Spring DI &amp;amp; Scope&lt;/h2&gt;

&lt;h3 id=&#34;dependson&#34;&gt;@DependsOn&lt;/h3&gt;

&lt;p&gt;可以配置Spring IoC容器在初始化一个Bean之前，先初始化其他的Bean对象。&lt;/p&gt;

&lt;h3 id=&#34;bean&#34;&gt;@Bean&lt;/h3&gt;

&lt;p&gt;主要的作用是告知Spring，被此注解所标注的类将需要纳入到Bean管理工厂中。&lt;/p&gt;

&lt;h3 id=&#34;scope&#34;&gt;@Scope&lt;/h3&gt;

&lt;p&gt;@Scope注解可以用来定义@Component标注的类的作用范围以及@Bean所标记的类的作用范围。@Scope所限定的作用范围有：singleton、prototype、request、session、globalSession或者其他的自定义范围。&lt;/p&gt;

&lt;p&gt;当@Scope的作用范围设置成Singleton时，被此注解所标注的类只会被Spring IoC容器初始化一次。在默认情况下，Spring IoC容器所初始化的类实例都为singleton。&lt;/p&gt;

&lt;h2 id=&#34;容器配置注解&#34;&gt;容器配置注解&lt;/h2&gt;

&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;

&lt;p&gt;@Autowired注解用于标记Spring将要解析和注入的依赖项。此注解可以作用在构造函数、字段和setter方法上。&lt;/p&gt;

&lt;h3 id=&#34;primary&#34;&gt;@Primary&lt;/h3&gt;

&lt;p&gt;当系统中需要配置多个具有相同类型的bean时，@Primary可以定义这些Bean的优先级。&lt;/p&gt;

&lt;h3 id=&#34;qualifier&#34;&gt;@Qualifier&lt;/h3&gt;

&lt;p&gt;当系统中存在同一类型的多个Bean时，@Autowired在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier注解来微调，帮助@Autowired选择正确的依赖项。&lt;/p&gt;

&lt;h2 id=&#34;spring-boot注解&#34;&gt;Spring Boot注解&lt;/h2&gt;

&lt;h3 id=&#34;springbootapplication&#34;&gt;@SpringBootApplication&lt;/h3&gt;

&lt;p&gt;@SpringBootApplication注解是一个快捷的配置注解，在被它标注的类中，可以定义一个或多个Bean，并自动触发自动配置Bean和自动扫描组件。此注解相当于@Configuration、@EnableAutoConfiguration和@ComponentScan的组合。在Spring Boot应用程序的主类中，就使用了此注解。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
public class Application{
 public static void main(String [] args){
   SpringApplication.run(Application.class,args);
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enableautoconfiguration&#34;&gt;@EnableAutoConfiguration&lt;/h3&gt;

&lt;p&gt;@EnableAutoConfiguration注解用于通知Spring，根据当前类路径下引入的依赖包，自动配置与这些依赖包相关的配置项。&lt;/p&gt;

&lt;p&gt;@ConditionalOnClass与@ConditionalOnMissingClass&lt;/p&gt;

&lt;p&gt;这两个注解属于类条件注解，它们根据是否存在某个类作为判断依据来决定是否要执行某些配置。下面是一个简单的示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ConditionalOnClass(DataSource.class)
class MySQLAutoConfiguration {
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonbean与-conditionalonmissingbean&#34;&gt;@ConditionalOnBean与@ConditionalOnMissingBean&lt;/h3&gt;

&lt;p&gt;这两个注解属于对象条件注解，根据是否存在某个对象作为依据来决定是否要执行某些配置方法。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalOnBean(name=&amp;quot;dataSource&amp;quot;)
LocalContainerEntityManagerFactoryBean entityManagerFactory(){
 //...
}
@Bean
@ConditionalOnMissingBean
public MyBean myBean(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonproperty&#34;&gt;@ConditionalOnProperty&lt;/h3&gt;

&lt;p&gt;@ConditionalOnProperty注解会根据Spring配置文件中的配置项是否满足配置要求，从而决定是否要执行被其标注的方法。示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalOnProperty(name=&amp;quot;alipay&amp;quot;,havingValue=&amp;quot;on&amp;quot;)
Alipay alipay(){
 return new Alipay();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalonresource&#34;&gt;@ConditionalOnResource&lt;/h3&gt;

&lt;p&gt;此注解用于检测当某个配置文件存在使，则触发被其标注的方法，下面是使用此注解的代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnResource(resources = &amp;quot;classpath:website.properties&amp;quot;)
Properties addWebsiteProperties(){
 //...
}
@ConditionalOnWebApplication与@ConditionalOnNotWebApplication
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个注解用于判断当前的应用程序是否是Web应用程序。如果当前应用是Web应用程序，则使用Spring WebApplicationContext,并定义其会话的生命周期。下面是一个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ConditionalOnWebApplication
HealthCheckController healthCheckController(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditionalexpression&#34;&gt;@ConditionalExpression&lt;/h3&gt;

&lt;p&gt;此注解可以让我们控制更细粒度的基于表达式的配置条件限制。当表达式满足某个条件或者表达式为真的时候，将会执行被此注解标注的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@ConditionalException(&amp;quot;${localstore} &amp;amp;&amp;amp; ${local == &#39;true&#39;}&amp;quot;)
LocalFileStore store(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conditional&#34;&gt;@Conditional&lt;/h3&gt;

&lt;p&gt;@Conditional注解可以控制更为复杂的配置条件。在Spring内置的条件控制注解不满足应用需求的时候，可以使用此注解定义自定义的控制条件，以达到自定义的要求。下面是使用该注解的简单示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Conditioanl(CustomConditioanl.class)
CustomProperties addCustomProperties(){
 //...
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>意向锁</title>
      <link>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</link>
      <pubDate>Sat, 20 Jul 2019 22:31:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%84%8F%E5%90%91%E9%94%81/</guid>
      <description>

&lt;h3 id=&#34;封锁粒度&#34;&gt;封锁粒度&lt;/h3&gt;

&lt;p&gt;一般有两种封锁粒度：&lt;strong&gt;行级锁以及表级锁&lt;/strong&gt;。应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。&lt;/p&gt;

&lt;h3 id=&#34;读写锁&#34;&gt;读写锁&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;排它锁（Exclusive），简写为 X 锁，又称写锁。&lt;/li&gt;
&lt;li&gt;共享锁（Shared），简写为 S 锁，又称读锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。&lt;/li&gt;
&lt;li&gt;一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;意向锁&#34;&gt;意向锁&lt;/h3&gt;

&lt;p&gt;使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。&lt;strong&gt;意向锁是一种不与行级锁冲突表级锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;规定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；&lt;/li&gt;
&lt;li&gt;一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容关系(特别说明，以下是&lt;strong&gt;表锁&lt;/strong&gt;直接的兼容关系)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;X&lt;/th&gt;
&lt;th&gt;IX&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;th&gt;IS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IX&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;IS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意向锁不会与行级的共享 / 排他锁互斥。IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;

&lt;p&gt;用户表user：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;zhangsan&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;lisi&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;wangwu&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;事务A，更新id为2的用户名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取user表上的IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取id=2数据行的X锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务B，查询user表&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;检查到user表上用IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;事务B加锁请求阻塞。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事务C，更新id为1的用户名&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取user表的IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检测到user表有IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;意向锁不排斥，故事务C获得IX锁；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;id=1不存在其他行级锁，获取行级X锁。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说明：若无意向锁，则对于事务B，将要查询表中的行来确定是否存在其他行级锁。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>反射</title>
      <link>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 06 Jul 2019 23:15:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</guid>
      <description>

&lt;h3 id=&#34;一-定义&#34;&gt;一、定义&lt;/h3&gt;

&lt;p&gt;反射（reflection）是java的特征之一，它允许允许中的Java程序获取自身的信息，并且可以操作累或对象的内部属性。&lt;/p&gt;

&lt;h3 id=&#34;二-基本运用&#34;&gt;二、基本运用&lt;/h3&gt;

&lt;p&gt;反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。反射相关的类一般都在 java.lang.relfect 包里。&lt;/p&gt;

&lt;h4 id=&#34;1-获取class对象&#34;&gt;1. 获取Class对象&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo01 {
    public static void main(String[] args) throws Exception{
        String str = new String();
        // 1.通过对象的getClass方法获得
        Class strClass = str.getClass();
        System.out.println(strClass.getName());

        // 2.通过class属性获得
        // 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
        Class strClass2 = String.class;
        System.out.println(strClass2.getName());
        System.out.println(strClass2 == strClass);

        // 3.使用Class类的forName静态方法
        // 注意此字符串必须是真实路径，就是带包名的类路径，包名.类名
        try{
            Class strClass3 = Class.forName(&amp;quot;java.lang.String&amp;quot;);
            System.out.println(strClass3 == strClass2);
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));

        System.out.println(strClass instanceof Object);

    }

}

// 结果：
java.lang.String
java.lang.String
true
true
true
true

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;获取Class对象的三种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调用某个对象的getClass方法；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接获取某个类型的class属性：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Class类的forName静态方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：在运行期间，一个类，只有一个Class对象产生。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-判断是否为某个类的实例&#34;&gt;2. 判断是否为某个类的实例&lt;/h4&gt;

&lt;p&gt;一般使用instanceof关键字判断是否为某个类的实例，也可以使用反射中Class对象的isInstance()方法（native方法）判断是否为某个类的实例，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;));
System.out.println(strClass instanceof Object);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-创建实例&#34;&gt;3. 创建实例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建实例
// 1. newInstance()
String string = (String) strClass.newInstance();
System.out.println(string);

// 2. 先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。
// 这种方法可以指定构造器的实例。
Constructor constructor = strClass.getConstructor(String.class);
String string2 = (String) constructor.newInstance(&amp;quot;23333&amp;quot;);
System.out.println(string2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用Class对象的newInstance()方法来创建Class对象对应类的实例。&lt;/li&gt;
&lt;li&gt;先通过Class对象获取指定Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-获取方法&#34;&gt;4. 获取方法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo02 {

    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; clazz = MethodClass.class;

        // 创建类实例
        Object obj = clazz.newInstance();


        // 获取所有共有方法, 包括继承
        Method[] methods = clazz.getMethods();
        for (Method m : methods) {
            System.out.println(m);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取所有私有方法，不包括继承
        Method[] declaredMethods = clazz.getDeclaredMethods();
        for (Method dm : declaredMethods) {
            System.out.println(dm);
        }

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法
        Method add = clazz.getMethod(&amp;quot;add&amp;quot;, int.class, int.class);
        // 调用方法 （要先创建实例对象）
        Object r = add.invoke(obj, 1, 1);
        System.out.println(r);
        System.out.println(add);

        System.out.println(&amp;quot;----------&amp;quot;);
        // 获取指定方法(私有)
        Method sub = clazz.getDeclaredMethod(&amp;quot;sub&amp;quot;, int.class, int.class);
        sub.setAccessible(true);
        Object result = sub.invoke(obj,12, 2);
        System.out.println(result);

    }


}

class MethodClass {
    public int add(int a, int b) {
        return a + b;
    }
    private int sub(int a, int b){
        return a - b;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;getDeclaredMethods()方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getDeclaredMethod()方法可以获取特定的私有方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethods()方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getMethod()方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>算法016</title>
      <link>https://pallcard.github.io/2019/algorithm016/</link>
      <pubDate>Sat, 06 Jul 2019 17:35:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm016/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;正则表达式匹配问题&lt;/p&gt;

&lt;p&gt;请实现一个函数用来匹配包括 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;*&amp;rsquo; 的正则表达式。模式中的字符 &amp;lsquo;.&amp;rsquo; 表示任意一个字符，而 &amp;lsquo;*&amp;rsquo; 表示它前面的字符可以出现任意次（包含 0 次）。&lt;/p&gt;

&lt;p&gt;. 一个任意字符&lt;/p&gt;

&lt;p&gt;* 表示*前字符出现（0-？）字符&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;aaa 以下两模式串均可匹配

ab*ac*a  a.a
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;采用两个下标，分别记录目标串与模式串。
循环模式串，若为.，则下标加1；
若为模式串与目标串字符相同，则下标加1，否则看模式串下一个字符算法为*；&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo016 {
    public static void main(String[] args) {
        String string = &amp;quot;aaa&amp;quot;;
        String pattern = &amp;quot;ab*a&amp;quot;;

        int index = 0;
        int i = 0;
        boolean result = true;

        for (i = 0; i &amp;lt; pattern.length(); i++) {
            if (index &amp;gt;= string.length()) {
                result = false;
                break;
            }
            if (pattern.charAt(i) == &#39;.&#39;) {
                index++;
                continue;
            }
            if(pattern.charAt(i) == string.charAt(index)) {
                index++;
            } else if(pattern.charAt(i+1) != &#39;*&#39;) {
                result = false;
                break;
            } else if (pattern.charAt(i+1) == &#39;*&#39;) {
                i++;
            }
        }
        if(index != string.length() || i != pattern.length()) {
            result = false;
        }
        System.out.println(result);
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法015</title>
      <link>https://pallcard.github.io/2019/algorithm015/</link>
      <pubDate>Sat, 06 Jul 2019 17:32:45 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm015/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;二进制中1的个数&lt;/p&gt;

&lt;p&gt;输入一个整数，输出该数二进制表示中1的个数&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;n&amp;amp;(n-1)会去除掉n的位级表示中的最低的一位&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo015 {

    public static int numberOf1(int n) {
        int count = 0;

        if (n == 0) {
            return 0;
        }

        while (n != 0) {
            count++;
            n &amp;amp;= (n-1);
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(numberOf1(10));
        System.out.println(Integer.bitCount(10));
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法014</title>
      <link>https://pallcard.github.io/2019/algorithm014/</link>
      <pubDate>Sat, 06 Jul 2019 17:24:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm014/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;剪绳子&lt;/p&gt;

&lt;p&gt;把一根绳子剪成多段（&amp;gt;1），并使得所得到每段绳子的长度之积最大。&lt;/p&gt;

&lt;h5 id=&#34;例子&#34;&gt;例子&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	n(绳长)
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;方法一：
&lt;strong&gt;贪婪算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使得所得到的绳子中&lt;strong&gt;3&lt;/strong&gt;的数量最多，1的数量最少（没有）&lt;/p&gt;

&lt;p&gt;方法二：
&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定义 f(n) : 最大乘积，f(n) = max{f(i)*f(n-i)}&lt;/p&gt;

&lt;h5 id=&#34;代码&#34;&gt;代码&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo014 {

    // 贪婪算法
    public static int maxLength(int n) {
        if (n &amp;lt; 2) {
            return 0;
        } else if (n == 2) {
            return 1;
        } else if (n == 3) {
            return 2;
        } else {
            if (n%3==1){
                return (int) Math.pow(3, n/3-1)*4;
            } else if(n%3==0) {
                return (int) Math.pow(3, n/3);
            } else {
                return (int) Math.pow(3, n/3)*2;
            }
        }
    }

    // 动态规划
    // 定义 f(n) : 最大乘积
    // f(n) = max{f(i)*f(n-i)}
    public static int dp(int n) {
        if (n &amp;lt; 2) {
            return 0;
        } else if (n == 2) {
            return 1;
        } else if (n == 3) {
            return 2;
        } else {
            int [] dp = new int [n+1];
            // 分割绳子长度1，2，3，具体动态规划从4开始计算
            // dp[i]数组,绳子长度为i时，乘积最大值
            dp[1] = 1;
            dp[2] = 2;
            dp[3] = 3;
            int max = 0;
            // 存放中间值
            int temp = 0;
            for (int i = 4; i &amp;lt;= n; i++) {
                max = 0;
                // i/2 对于绳子i的切分，j*(i-j) 与 (i-j)*j结果一样
                for (int j = 1; j &amp;lt;= i / 2; j++) {
                    temp = dp[j] * dp[i-j];
                    if (temp &amp;gt; max) {
                        max = temp;
                    }
                }
                dp[i] = max;
            }
            return dp[n];
        }
    }

    public static void main(String[] args) {
        System.out.println(maxLength(11));
        System.out.println(dp(11));
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 06 Jul 2019 09:10:02 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>

&lt;h3 id=&#34;一-简介&#34;&gt;一、简介&lt;/h3&gt;

&lt;p&gt;正则表达式用于文本内容的查找和替换。在线工具&lt;a href=&#34;https://regexr.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://regexr.com/&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;回退&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;换页符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;换行符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;回车符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;制表符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;垂直制表符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\d&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数字字符，等价于 [0-9]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\w&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;\s&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;任何一个空白字符，等价于 [\f\n\r\t\v]&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\l&lt;/td&gt;
&lt;td&gt;把下个字符转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\u&lt;/td&gt;
&lt;td&gt;把下个字符转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\L&lt;/td&gt;
&lt;td&gt;把\L 和\E 之间的字符全部转换为小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\U&lt;/td&gt;
&lt;td&gt;把\U 和\E 之间的字符全部转换为大写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\E&lt;/td&gt;
&lt;td&gt;结束\L 或者\U&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说明:
\D,\W,\S是对上述3个的取非；&lt;/p&gt;

&lt;h3 id=&#34;二-匹配单个字符&#34;&gt;二、匹配单个字符&lt;/h3&gt;

&lt;p&gt;.可以用来&lt;strong&gt;匹配任意单个字符&lt;/strong&gt;，但是在绝大多数实现里面，不能匹配换行符；&lt;/p&gt;

&lt;p&gt;. 是&lt;strong&gt;元字符&lt;/strong&gt;，表示它有特殊的含义，而不是字符本身的含义。若要匹配.使用\.&lt;/p&gt;

&lt;h3 id=&#34;三-匹配一组字符&#34;&gt;三、匹配一组字符&lt;/h3&gt;

&lt;p&gt;[]定义&lt;strong&gt;一个字符集合&lt;/strong&gt;；
0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。&lt;/p&gt;

&lt;p&gt;- 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；&lt;/p&gt;

&lt;p&gt;^ 在 [ ] 中是取非操作。&lt;/p&gt;

&lt;h3 id=&#34;四-重复匹配&#34;&gt;四、重复匹配&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;+ 匹配 1 个或者多个字符&lt;/li&gt;
&lt;li&gt;* 匹配 0 个或者多个&lt;/li&gt;
&lt;li&gt;? 匹配 0 个或者 1 个&lt;/li&gt;
&lt;li&gt;{n} 匹配 n 个字符&lt;/li&gt;
&lt;li&gt;{m, n} 匹配 m~n 个字符&lt;/li&gt;
&lt;li&gt;{m,} 至少匹配 m 个字符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
(1)    a.+c
(2)    a.+?c
target:
    abcabcabccc
第一个正则会匹配到abcabcabccc，有1个匹配
第二个正则会匹配到abc abc abc，有3个匹配
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;五-位置匹配&#34;&gt;五、位置匹配&lt;/h3&gt;

&lt;h4 id=&#34;单词边界&#34;&gt;单词边界&lt;/h4&gt;

&lt;p&gt;\b 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；\B 匹配一个不是单词边界的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    \Babc\b
target:
    aabc
    aabc1
第一个目标串可以匹配到abc
第一个目标串不能匹配
说明abc前面要有字母、数字或下划线，abc后面不能有字母、数字或下划线
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;字符串边界&#34;&gt;字符串边界&lt;/h4&gt;

&lt;p&gt;^ 匹配整个字符串的开头，$ 匹配结尾。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分行匹配模式（multiline）下，换行被当做字符串的边界。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    ^\s*\/\/.*$
target:
    // 注释
    
说明匹配代码中以 // 开始的注释行
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;六-子表达式&#34;&gt;六、子表达式&lt;/h3&gt;

&lt;p&gt;使用 ( ) 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。可以嵌套。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    (ab){2,}
target:
    ababab
说明:匹配2个以上ab组成的字符串

regexr:
    (19|20)/d{2}
target:
    1900
说明：匹配19或20后面两个数的字字符串

例子：匹配IP地址
IP地址每部分都是0-255，
将其划分为一下5个部分
0-9
10-99
100-199
200-249
250-255
故0-255的正则是 ((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))

regexr:
    (((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d)|([1-9]\d)|(1\d{2})|(2[0-4]\d)|(25[0-5]))
target:
    1.1.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;七-回溯引用&#34;&gt;七、回溯引用&lt;/h3&gt;

&lt;p&gt;回溯引用使用 &lt;strong&gt;\n&lt;/strong&gt; (n为数字) 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    &amp;lt;(h[1-6])&amp;gt;\w*?&amp;lt;\/\1&amp;gt;
target:
    &amp;lt;h1&amp;gt;x&amp;lt;/h1&amp;gt;
说明：匹配html中标题元素
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;八-前后查找&#34;&gt;八、前后查找&lt;/h3&gt;

&lt;p&gt;向前查找用 ?= 来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;regexr:
    \w+(?=@)
target:
    abc@qq.com
说明：查找出邮件地址 @ 字符前面的部分。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;九-在java中使用&#34;&gt;九、在Java中使用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        String str = &amp;quot;&amp;lt;h1&amp;gt;test&amp;lt;/h1&amp;gt;&amp;quot;;
        boolean result = str.matches(&amp;quot;&amp;lt;(h[1-6])&amp;gt;\\w*?&amp;lt;\\/\\1&amp;gt;&amp;quot;);
        System.out.println(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法013</title>
      <link>https://pallcard.github.io/2019/algorithm013/</link>
      <pubDate>Fri, 05 Jul 2019 08:22:30 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm013/</guid>
      <description>

&lt;h5 id=&#34;描述&#34;&gt;描述&lt;/h5&gt;

&lt;p&gt;机器人的运动范围&lt;/p&gt;

&lt;p&gt;地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。&lt;/p&gt;

&lt;p&gt;例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	m(行数) n(列数) k(阀值)
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;先将数组中的值计算按位出来存入数组，使用深度优先遍历，将经过的格子中的值置k+1，使用count记录所有走过的格子。&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo013 {

    // 左 上 右 下
    public static int [][] direct = new int [][]
            {{0,-1},{-1,0},{0,1},{1,0}};

    public static int count = 0;
    public static int m = 11;
    public static int n = 11;
    public static int k = 10;


    public static void main(String[] args) {
        int [][] array = new int[m][n];
        for (int i = 0; i &amp;lt; m; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                int i_temp = i;
                int j_temp = j;
                // 处理数位
                int i_sum = i_temp%10;
                int j_sum = j_temp%10;

                i_temp /= 10;
                j_temp /= 10;
                while (i_temp &amp;gt; 0){
                    i_sum += i_temp%10;
                    i_temp /= 10;
                }
                while (j_temp &amp;gt; 0) {
                    j_sum += j_temp%10;
                    j_temp /= 10;
                }
                array[i][j] = i_sum+j_sum;
            }
        }
        count++;
        array[0][0] = k + 1;
        DPsearch(array,0,0);
        System.out.println(count);
    }

    public static void DPsearch(int [][] array, int x, int y) {
        for (int i = 0; i &amp;lt; 4; i++) {
            if (x + direct[i][0] &amp;gt;= 0
                    &amp;amp;&amp;amp; x + direct[i][0] &amp;lt; m
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;gt;= 0
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;lt; n) {
                x += direct[i][0];
                y += direct[i][1];

                if(array[x][y] &amp;lt;= k) {
                    // 走过的格子失效
                    array[x][y] = k + 1;
                    count++;
                    DPsearch(array,x,y);
                }

                // x,y 坐标还原
                x -= direct[i][0];
                y -= direct[i][1];
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法012</title>
      <link>https://pallcard.github.io/2019/algorithm012/</link>
      <pubDate>Thu, 04 Jul 2019 22:28:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm012/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;矩阵中的路径
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;先将所给一维数组转化为二维数组，找到目标字符串首个字符所在位置。然后进行深度递归匹配目标字符串。&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo012 {

    public static void main(String[] args) {
        char[] matrix = new char[]{&#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;s&#39;, &#39;f&#39;, &#39;c&#39;, &#39;s&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;e&#39;};
        int rows = 3;
        int cols = 4;
        char [] target = new char[]{&#39;b&#39;,&#39;f&#39;,&#39;c&#39;,&#39;e&#39;};

        char[][] array = new char[3][4];
        int index = 0;
        int x = 0, y = 0;
        for (int i = 0; i &amp;lt; rows; i++) {
            for (int j = 0; j &amp;lt; cols; j++) {
                array[i][j] = matrix[index++];

            }
        }

        boolean result = false;
        for (int i = 0; i &amp;lt; rows; i++) {
            for (int j = 0; j &amp;lt; cols; j++) {
                if (array[i][j] == target[0]) {
                    result = search(array,i,j,target,1);
                    if (result) {
                        System.out.println(result);
                        return;
                    }
                }
            }
        }

        System.out.println(result);

    }
    // 左 上 右 下
    public static int [][] direct = new int [][]
            {{0,-1},{-1,0},{0,1},{1,0}};

    public static boolean search(char[][] array, int x, int y, char [] target, int index) {
        for (int i = 0; i &amp;lt; 4; i++) {
            if (x + direct[i][0] &amp;gt;= 0
                    &amp;amp;&amp;amp; x + direct[i][0] &amp;lt; 3
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;gt;= 0
                    &amp;amp;&amp;amp; y + direct[i][1] &amp;lt; 4) {
                x += direct[i][0];
                y += direct[i][1];
                if (array[x][y] == target[index] &amp;amp;&amp;amp; target.length == index+1) {
                    return true;
                } else if (array[x][y] == target[index]) {
                    return search(array,x,y,target,++index);
                }
                // x,y 坐标还原
                x -= direct[i][0];
                y -= direct[i][1];
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法011</title>
      <link>https://pallcard.github.io/2019/algorithm011/</link>
      <pubDate>Thu, 04 Jul 2019 21:12:50 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm011/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;旋转数组(非递减)的最小数&lt;/p&gt;

&lt;p&gt;把一个数组最开始的若干位搬到数组的末尾，称为旋转数组。&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;采用二分的方式来处理，&lt;/p&gt;

&lt;p&gt;正常情况&lt;/p&gt;

&lt;p&gt;4 5 6 7 1 2，分成两部分4 5 6，7 1 2；可知4 5 6为非递减数列，7 1 2为旋转数组，故结果在循环数组中，可以去掉另外一半数组；&lt;/p&gt;

&lt;p&gt;两种特殊情况：&lt;/p&gt;

&lt;p&gt;（1）1 1 1 1 0 1，num[left] == num[mid] == num[right],此时无法分区，故只能遍历&lt;/p&gt;

&lt;p&gt;（2）4 5 6 1 2 3，分区后两个部分均为非递减数组，则返回num[left]和num[mid+1]中较小的数即可。&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo011 {
    public static void main(String[] args) {
        int [] arr = new int[] {1,1,1,0,1};
        System.out.println(searchMin(arr,arr.length));
    }

    public static int searchMin(int [] array, int length) {
        int left = 0, right = length - 1;
        int mid = (left + right) / 2;
        while(left &amp;lt; right) {
            // 分区间后刚好左右都为非递减数组
            if(array[left] &amp;lt; array[mid] &amp;amp;&amp;amp; array[mid+1] &amp;lt; array[right]) {
                if (array[left] &amp;gt; array[mid+1]) {
                    left = mid+1;
                }
                break;
            }
            // 无法分区间情况
            if (array[left] == array[mid] &amp;amp;&amp;amp; array[mid] == array[right]) {
                int minIndex = left;
                for (int i = left; i &amp;lt;= right; i++) {
                    if (array[minIndex] &amp;gt; array[i]) {
                        minIndex = i;
                    }
                }
                left = minIndex;
                break;
            }
            // 正常分区间
            if (array[left] &amp;lt; array[mid]) {
                // 左侧为非递减数组，右侧为旋转数组==&amp;gt;取右侧
                left = mid+1;
            } else {
                // 取左侧
                right = mid - 1;
            }
        }
        return array[left];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>算法010</title>
      <link>https://pallcard.github.io/2019/algorithm010/</link>
      <pubDate>Thu, 04 Jul 2019 21:08:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm010/</guid>
      <description>

&lt;h3 id=&#34;描述&#34;&gt;描述&lt;/h3&gt;

&lt;p&gt;变态跳青蛙&lt;/p&gt;

&lt;p&gt;青蛙可以跳1，2，3，，，n阶。问跳到n有多少种不同方法。&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Input:
	
Output:
	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;f(n) = f(n-1) + f(n-2) + ,,, + f(0)

f(n-1) = f(n-2) + f(n-3) + ,,, + f(0)

==&amp;gt;  f(n) = 2 * f(n-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Demo010 {

    public static void main(String[] args) {
        System.out.println(jumpFloor(3));
        System.out.println(jumpFloor2(3));
    }

//    f(0) = 1
//    f(1) = 1
//    f(2) = 2
//    f(3) = 4
    public static int jumpFloor(int target) {
        int [] dp = new int[target];
        Arrays.fill(dp,1);  // 数组所有元素置1（相当于所有元素+f(0)）
        for (int i = 1; i &amp;lt; target; i++) {
            for (int j = 0; j &amp;lt; i; j++) {
                dp[i] += dp[j];
            }
        }
        return dp[target-1];
    }

    public static int jumpFloor2(int target) {
        return (int) Math.pow(2, target-1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
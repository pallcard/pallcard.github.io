<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 刘科个人博客</title>
    <link>https://pallcard.github.io/posts/</link>
    <description>Recent content in Posts on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sat, 06 Jul 2019 23:15:44 +0800</lastBuildDate>
    
	<atom:link href="https://pallcard.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>反射</title>
      <link>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 06 Jul 2019 23:15:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8F%8D%E5%B0%84/</guid>
      <description>一、定义 反射（reflection）是java的特征之一，它允许允许中的Java程序获取自身的信息，并且可以操作累或对象的内部属性。
二、基本运用 反射可以用于判断任意对象所属的类，获得 Class 对象，构造任意一个对象以及调用一个对象。反射相关的类一般都在 java.lang.relfect 包里。
1. 获取Class对象 public class Demo01 { public static void main(String[] args) throws Exception{ String str = new String(); // 1.通过对象的getClass方法获得 Class strClass = str.getClass(); System.out.println(strClass.getName()); // 2.通过class属性获得 // 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 Class strClass2 = String.class; System.out.println(strClass2.getName()); System.out.println(strClass2 == strClass); // 3.使用Class类的forName静态方法 // 注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 try{ Class strClass3 = Class.forName(&amp;quot;java.lang.String&amp;quot;); System.out.println(strClass3 == strClass2); } catch (Exception e) { e.printStackTrace(); } System.out.println(strClass.isInstance(&amp;quot;test&amp;quot;)); System.out.println(strClass instanceof Object); } } // 结果： java.</description>
    </item>
    
    <item>
      <title>算法016</title>
      <link>https://pallcard.github.io/2019/algorithm016/</link>
      <pubDate>Sat, 06 Jul 2019 17:35:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm016/</guid>
      <description>描述 正则表达式匹配问题
请实现一个函数用来匹配包括 &amp;lsquo;.&amp;rsquo; 和 &amp;lsquo;&amp;rsquo; 的正则表达式。模式中的字符 &amp;lsquo;.&amp;rsquo; 表示任意一个字符，而 &amp;lsquo;&amp;rsquo; 表示它前面的字符可以出现任意次（包含 0 次）。
. 一个任意字符
* 表示*前字符出现（0-？）字符
aaa ab*ac*a a.a
例子 Input: Output:  思路 采用两个下标，分别记录目标串与模式串。 循环模式串，若为.，则下标加1； 若为模式串与目标串字符相同，则下标加1，否则看模式串下一个字符算法为*；
代码 public class Demo016 { public static void main(String[] args) { String string = &amp;quot;aaa&amp;quot;; String pattern = &amp;quot;ab*a&amp;quot;; int index = 0; int i = 0; boolean result = true; for (i = 0; i &amp;lt; pattern.length(); i++) { if (index &amp;gt;= string.</description>
    </item>
    
    <item>
      <title>算法015</title>
      <link>https://pallcard.github.io/2019/algorithm015/</link>
      <pubDate>Sat, 06 Jul 2019 17:32:45 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm015/</guid>
      <description> 描述 二进制中1的个数
输入一个整数，输出该数二进制表示中1的个数
例子 Input: Output:  思路 n&amp;amp;(n-1)会去除掉n的位级表示中的最低的一位
代码 public class Demo015 { public static int numberOf1(int n) { int count = 0; if (n == 0) { return 0; } while (n != 0) { count++; n &amp;amp;= (n-1); } return count; } public static void main(String[] args) { System.out.println(numberOf1(10)); System.out.println(Integer.bitCount(10)); } }  </description>
    </item>
    
    <item>
      <title>算法014</title>
      <link>https://pallcard.github.io/2019/algorithm014/</link>
      <pubDate>Sat, 06 Jul 2019 17:24:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm014/</guid>
      <description>描述 剪绳子
把一根绳子剪成多段（&amp;gt;1），并使得所得到每段绳子的长度之积最大。
例子 Input: n(绳长) Output:  思路 方法一： 贪婪算法
使得所得到的绳子中3的数量最多，1的数量最少（没有）
方法二： 动态规划
定义 f(n) : 最大乘积，f(n) = max{f(i)*f(n-i)}
代码 public class Demo014 { // 贪婪算法 public static int maxLength(int n) { if (n &amp;lt; 2) { return 0; } else if (n == 2) { return 1; } else if (n == 3) { return 2; } else { if (n%3==1){ return (int) Math.pow(3, n/3-1)*4; } else if(n%3==0) { return (int) Math.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 06 Jul 2019 09:10:02 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>一、简介 正则表达式用于文本内容的查找和替换。在线工具https://regexr.com/
   元字符 说明     \b 回退   \f 换页符   \n 换行符   \r 回车符   \t 制表符   \v 垂直制表符   \d 数字字符，等价于 [0-9]   \w 大小写字母，下划线和数字，等价于 [a-zA-Z0-9_]   \s 任何一个空白字符，等价于 [\f\n\r\t\v]   \l 把下个字符转换为小写   \u 把下个字符转换为大写   \L 把\L 和\E 之间的字符全部转换为小写   \U 把\U 和\E 之间的字符全部转换为大写   \E 结束\L 或者\U    说明: \D,\W,\S是对上述3个的取非；</description>
    </item>
    
    <item>
      <title>算法013</title>
      <link>https://pallcard.github.io/2019/algorithm013/</link>
      <pubDate>Fri, 05 Jul 2019 08:22:30 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm013/</guid>
      <description>描述 机器人的运动范围
地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。
例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？
例子 Input: m(行数) n(列数) k(阀值) Output:  思路 先将数组中的值计算按位出来存入数组，使用深度优先遍历，将经过的格子中的值置k+1，使用count记录所有走过的格子。
代码 public class Demo013 { // 左 上 右 下 public static int [][] direct = new int [][] {{0,-1},{-1,0},{0,1},{1,0}}; public static int count = 0; public static int m = 11; public static int n = 11; public static int k = 10; public static void main(String[] args) { int [][] array = new int[m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { int i_temp = i; int j_temp = j; // 处理数位 int i_sum = i_temp%10; int j_sum = j_temp%10; i_temp /= 10; j_temp /= 10; while (i_temp &amp;gt; 0){ i_sum += i_temp%10; i_temp /= 10; } while (j_temp &amp;gt; 0) { j_sum += j_temp%10; j_temp /= 10; } array[i][j] = i_sum+j_sum; } } count++; array[0][0] = k + 1; DPsearch(array,0,0); System.</description>
    </item>
    
    <item>
      <title>算法012</title>
      <link>https://pallcard.github.io/2019/algorithm012/</link>
      <pubDate>Thu, 04 Jul 2019 22:28:14 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm012/</guid>
      <description>描述 矩阵中的路径 判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。
例子 Input: Output:  思路 先将所给一维数组转化为二维数组，找到目标字符串首个字符所在位置。然后进行深度递归匹配目标字符串。
代码 public class Demo012 { public static void main(String[] args) { char[] matrix = new char[]{&#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;s&#39;, &#39;f&#39;, &#39;c&#39;, &#39;s&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;e&#39;}; int rows = 3; int cols = 4; char [] target = new char[]{&#39;b&#39;,&#39;f&#39;,&#39;c&#39;,&#39;e&#39;}; char[][] array = new char[3][4]; int index = 0; int x = 0, y = 0; for (int i = 0; i &amp;lt; rows; i++) { for (int j = 0; j &amp;lt; cols; j++) { array[i][j] = matrix[index++]; } } boolean result = false; for (int i = 0; i &amp;lt; rows; i++) { for (int j = 0; j &amp;lt; cols; j++) { if (array[i][j] == target[0]) { result = search(array,i,j,target,1); if (result) { System.</description>
    </item>
    
    <item>
      <title>算法011</title>
      <link>https://pallcard.github.io/2019/algorithm011/</link>
      <pubDate>Thu, 04 Jul 2019 21:12:50 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm011/</guid>
      <description> 描述 旋转数组(非递减)的最小数
把一个数组最开始的若干位搬到数组的末尾，称为旋转数组。
例子 Input: Output:  思路 采用二分的方式来处理，
正常情况
4 5 6 7 1 2，分成两部分4 5 6，7 1 2；可知4 5 6为非递减数列，7 1 2为旋转数组，故结果在循环数组中，可以去掉另外一半数组；
两种特殊情况：
（1）1 1 1 1 0 1，num[left] == num[mid] == num[right],此时无法分区，故只能遍历
（2）4 5 6 1 2 3，分区后两个部分均为非递减数组，则返回num[left]和num[mid+1]中较小的数即可。
代码 public class Demo011 { public static void main(String[] args) { int [] arr = new int[] {1,1,1,0,1}; System.out.println(searchMin(arr,arr.length)); } public static int searchMin(int [] array, int length) { int left = 0, right = length - 1; int mid = (left + right) / 2; while(left &amp;lt; right) { // 分区间后刚好左右都为非递减数组 if(array[left] &amp;lt; array[mid] &amp;amp;&amp;amp; array[mid+1] &amp;lt; array[right]) { if (array[left] &amp;gt; array[mid+1]) { left = mid+1; } break; } // 无法分区间情况 if (array[left] == array[mid] &amp;amp;&amp;amp; array[mid] == array[right]) { int minIndex = left; for (int i = left; i &amp;lt;= right; i++) { if (array[minIndex] &amp;gt; array[i]) { minIndex = i; } } left = minIndex; break; } // 正常分区间 if (array[left] &amp;lt; array[mid]) { // 左侧为非递减数组，右侧为旋转数组==&amp;gt;取右侧 left = mid+1; } else { // 取左侧 right = mid - 1; } } return array[left]; } }  </description>
    </item>
    
    <item>
      <title>算法010</title>
      <link>https://pallcard.github.io/2019/algorithm010/</link>
      <pubDate>Thu, 04 Jul 2019 21:08:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm010/</guid>
      <description>描述 变态跳青蛙
青蛙可以跳1，2，3，，，n阶。问跳到n有多少种不同方法。
例子 Input: Output:  思路 f(n) = f(n-1) + f(n-2) + ,,, + f(0) f(n-1) = f(n-2) + f(n-3) + ,,, + f(0) ==&amp;gt; f(n) = 2 * f(n-1)  代码 public class Demo010 { public static void main(String[] args) { System.out.println(jumpFloor(3)); System.out.println(jumpFloor2(3)); } // f(0) = 1 // f(1) = 1 // f(2) = 2 // f(3) = 4 public static int jumpFloor(int target) { int [] dp = new int[target]; Arrays.</description>
    </item>
    
    <item>
      <title>算法009</title>
      <link>https://pallcard.github.io/2019/algorithm009/</link>
      <pubDate>Thu, 04 Jul 2019 21:01:25 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm009/</guid>
      <description> 描述 斐波那契数列， * 应用1：矩形覆盖,n个2*1小矩形覆盖2*n的大矩形，有多少种方法 * 应用2：跳台阶,可以跳1列或者2列，跳n阶有多少种方法
例子 Input: Output:  思路 f(n) = n; n = 0,1 f(n) = f(n-1) + f(n-2); n &amp;gt; 1  方法一：递归实现
方法二：使用一个数组存放所用的数据
方法三：发现第n项只与相邻的前两项有关，故只用存储前两项数据即可。
代码 public class Demo009 { public static void main(String[] args) { System.out.println(fibonacci(10)); System.out.println(fibonacci2(10)); System.out.println(fibonacci3(10)); } public static int fibonacci(int n) { if (n == 0) { return 0; } else if (n == 1) { return 1; } else return fibonacci(n-1) + fibonacci(n-2); } // 0 1 2 3 4 5 6 7 8 9 10 // 0 1 1 2 3 5 8 13 21 34 55 public static int fibonacci2(int n) { if (n &amp;lt;= 1) { return n; } int [] fib = new int[n+1]; fib[0] = 0; fib[1] = 1; for (int i = 2; i &amp;lt;= n; i++) { fib[i] = fib[i-1] + fib[i-2]; } return fib[n]; } public static int fibonacci3(int n) { if (n &amp;lt;= 1) { return n; } int temp1 = 0, temp2 = 1; int result = 0; for (int i = 2; i &amp;lt;= n; i++) { result = temp1 + temp2; temp1 = temp2; temp2 = result; } return result; } }  </description>
    </item>
    
    <item>
      <title>JMM例子</title>
      <link>https://pallcard.github.io/2019/jmm%E4%BE%8B%E5%AD%90/</link>
      <pubDate>Mon, 01 Jul 2019 22:26:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm%E4%BE%8B%E5%AD%90/</guid>
      <description>例子1，代码如下：
public class demo001 { private static boolean initFlag = false; // private static volatile boolean initFlag = false; public static void main(String[] args) throws InterruptedException { // 线程1 new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;quot;等待数据准备&amp;quot;); while (!initFlag) {} System.out.println(&amp;quot;数据准备完毕，执行程序逻辑&amp;quot;); } }).start(); Thread.sleep(2000); // 线程2 new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;quot;数据准备中。。。&amp;quot;); initFlag = true; System.out.println(&amp;quot;数据准备完成&amp;quot;); } }).start(); } }  说明
initFlag无volatile关键字修饰时，线程1将initFlag从主内存读入到工作内存，线程1一直循环，线程2将initFlag从主内存读入到工作内存，并通过线程执行引擎对initFlag进行修改，然后写回到主内存中，但是线程1中的initFlag仍然是工作内存中的值，线程1无法感知到其他内存对该共享变量的修改，故会一直循环下去。缓存一致性问题
缓存一致性问题</description>
    </item>
    
    <item>
      <title>Mybaits</title>
      <link>https://pallcard.github.io/2019/mybaits/</link>
      <pubDate>Thu, 20 Jun 2019 19:00:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mybaits/</guid>
      <description>前言 整个实验使用Maven 来管理项目，编译器IDEA，github仓库 https://github.com/pallcard/mybatis
JDBC连接数据库 1.引入依赖（pom.xml）
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.32&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;	 说明：（pom.xml） Maven 项目默认编译项目为JDK 1.5，通过引入以下依赖来指定Maven 编译版本
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;  2.JDBC测试类JDBCTest.java
public class JDBCTest { public static void main(String[] args) throws Exception { Connection connection = null; PreparedStatement prepareStatement = null; ResultSet rs = null; try { // 加载驱动(每次加载驱动，驱动名硬编码) Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;); // 获取连接(每次获取连接，连接信息硬编码) String url = &amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo&amp;quot;; String user = &amp;quot;root&amp;quot;; String password = &amp;quot;&amp;quot;; connection = DriverManager.</description>
    </item>
    
    <item>
      <title>Nginx问题</title>
      <link>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 19 Jun 2019 19:12:01 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</guid>
      <description>常用命令
/usr/local/webserver/nginx/sbin/nginx -s reload # 重新载入配置文件 /usr/local/webserver/nginx/sbin/nginx -s reopen # 重启 Nginx /usr/local/webserver/nginx/sbin/nginx -s stop # 停止 Nginx  错误信息1
后期添加配置文件后，重新运行报错，（云服务器为centos，最初按照时直接用的默认安装）
错误信息：./configure: error: SSL modules require the OpenSSL library.
解决办法：
# 安装 yum -y install openssl openssl-devel yum -y install openssl openssl-devel ./configure --prefix=/usr/local/nginx --with-http_ssl_module  错误信息2
# 防火墙问题（也可能是安全组设置的问题） # 关闭防火墙命令： systemctl stop firewalld.service # 开启防火墙： systemctl start firewalld.service # 关闭开机自启动： systemctl disable firewalld.service # 开启开机启动： systemctl enable firewalld.service # 开放80 firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） # 开放1000-2000 firewall-cmd --zone=public --add-port=1000-2000/tcp --permanent # 查看指定端口被哪个进程占用的情况 netstat -tunlp|grep 端口号  错误信息3</description>
    </item>
    
    <item>
      <title>FastDFS</title>
      <link>https://pallcard.github.io/2019/fastdfs/</link>
      <pubDate>Sat, 15 Jun 2019 19:43:24 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/fastdfs/</guid>
      <description>1. FastDFS 理论 FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。 FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。
tracker server 跟踪服务器，主要做调度工作，起负载均衡的作用。负责管理所有的storage server和group，每个storage在启动后会连接tracker，告诉tracker自己所属的group，并保持周期性心跳，tracker根据storage的心跳信息，建立映射表，tracke管理的元数据很少（tracker上的元数据都是由storage汇报产生），并且直接存在内存中，本身不需要持久化任何数据。tracker之间是对等的，因此扩展tracker是很容易的，直接增加tracker服务，同时修改storage的配置，增加新增的tarcker服务的地址和端口，重启即可。所有的tracker都会接受storage的心跳信息，以生成元数据信息。
storage server 存储服务器（又称：存储节点或数据服务器），顾名思义是用来保存文件的和文件属性的。以group为单位，每个group内可以包含多台storage server，数据互为备份，存储容量空间以group中storage server容量最小的为准。以group为单位组织存储能够方便的进行应用隔离、负责均衡和副本数定制；确定是group的容量受单机容量的限制。group内机器故障，需要依赖group内其他机器重新同步数据来恢复数据（更换坏盘，重启fdfs_storaged即可）。storage存储依赖本地文件系统，storage课配置多个数据存储目录，磁盘不做raid，直接分别挂在到多个目录，将这些目录配置为storage的数据目录即可。
storage接收写请求的时候，会根据配置好的规则，选择其中一个存储目录来存储文件；为了避免单个目录下的文件过多，storage第一次启动的时候，会在每个数据存储目录创建2级子目录，每级256，总共65536个目录，新写的文件会以hash的方式路由到其中一个子目录下，然后将文件数据直接作为一个本地文件存储。
client 客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。 文件上传 生成file id 选择存储目录之后，storage会生成一个file_id，采用base64编码，包含有：storage server ip，文件创建时间，文件大小，文件CRC32校验码和随机数。每个存储目录下有两个256*256个子目录，storage会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为名字存储。 文件路径如下： group0/M00/00/00/rBAAAl0EkICAIiBOAAABowgL3Pk888.png * 组名：group0 * 磁盘： M00 * 目录：00/00 * 文件名：rBAAAl0EkICAIiBOAAABowgL3Pk888.png
文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。
 组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存。 虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应。 数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。  文件下载 2.安装FastDFS环境 下载安装 libfastcommon yum -y install libevent # 下载libfastcommon wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz # 解压 tar -zxvf V1.0.7.tar.gz # 编译、安装 cd libfastcommon-1.</description>
    </item>
    
    <item>
      <title>初试部署项目到腾讯云（环境的安装）</title>
      <link>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 15 Jun 2019 19:32:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>linux常用命令  ls：查看该目录下文件 pwd：查看文件目录 rm -f 文件名：删除文件 /usr/local/mysql/bin/mysql -u root -p 登录mysql  第一步：jdk的安装 下载jdk后，解压报错（原因是选择接受协议的问题），输入如下命令：
wget --no-check-certificate --no-cookies --header &amp;quot;Cookie: oraclelicense=accept-securebackup-cookie&amp;quot; https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz  解压jdk压缩包，使用命令 tar -zxvf 文件名
然后配置环境变量，主要编辑以下两个文件
vi /etc/environment vi /etc/profile  最后使用java -version查看版本信息
第二步：mysql的安装 1.下载mysql ，以5.7为例
sudo wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz # 解压 tar -zxvf mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz  2.移动 文件到 /usr/local/
重命名 mv 文件名 mysql
3.新建data目录 mkdir data
4.新建mysql用户、mysql用户组
mysql用户组
groupadd mysql  mysql用户
useradd mysql -g mysql  5.将/usr/local/mysql的所有者及所属组改为mysql</description>
    </item>
    
    <item>
      <title>SpringBoot之配置文件</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 08 Jun 2019 20:21:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>1.配置文件基本使用 使用.yml配置文件，在resources目录下新建application.yml文件
server: port: 8081 #修改端口号 servlet: context-path: /lk #端口号后需额外添加字符 #以上等同于application.properties的以下写法 #server.port=8081 #server.servlet.context-path=/zed swagger: title: SpringBoot学习 description: SpringBoot学习 version: 1.0.0 name: lk url: https://pallcard.github.io email: 1250585541@qq.com  注
 其中空格有严格的要求  2.切换配置文件 在resources目录下新建application-dev.yml文件，application-prod.yml文件
//文件目录 resources|- application.yml application-dev.yml application-prod.yml  其中application.yml来切换配置文件
spring: profiles: active: dev  激活文件选择
 使用上述application.yml来设置
 使用java -jar ***.jar &amp;ndash;spring.profiles.active=dev;
 IDEA中可以如下设置
  3.配置文件使用  单值注入 （.yml中值若用双引号，转义字符会转义）  //.yml中 person: name: zhangsan \n lisi name2: &#39;zhangsan \n lisi&#39; name3: &amp;quot;zhangsan \n lisi&amp;quot; age: 18 boss: false //使用 @Value(&amp;quot;${person.</description>
    </item>
    
    <item>
      <title>SpringBoot之Swagger</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</link>
      <pubDate>Sat, 08 Jun 2019 17:49:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</guid>
      <description>Swagger框架 描述和测试API接口,自动生成API接口文档。
1.添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.8&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  2.Swagger配置 在resources目录下新建application.yml文件，添加如下配置
swagger: title: SpringBoot学习 description: SpringBoot学习 version: 1.0.0 name: lk url: https://pallcard.github.io email: 1250585541@qq.com  新建SwaggerConfig文件
@Configuration @EnableWebMvc @EnableSwagger2 @ConfigurationProperties(prefix = &amp;quot;swagger&amp;quot;) @Data //lombok @ComponentScan(basePackages = {&amp;quot;cn.wishhust.demo.controller&amp;quot;}) public class SwaggerConfig { private String title; private String description; private String version; private String name; private String url; private String email; @Bean public Docket customDocket() { return new Docket(DocumentationType.</description>
    </item>
    
    <item>
      <title>SpringBoot传递参数</title>
      <link>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 08 Jun 2019 17:08:34 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</guid>
      <description>url传参 1.get方式 // 访问：http://localhost:8080/test/get/xxx @GetMapping(&amp;quot;/get/{name}&amp;quot;) public String get(@PathVariable(&amp;quot;name&amp;quot;) String name2){ System.out.println(&amp;quot;name: &amp;quot;+ name2); return &amp;quot;Hi &amp;quot;+ name2; } // 访问：http://localhost:8080/test/get2?name=yyy @GetMapping(&amp;quot;/get2&amp;quot;) // 请求参数名字与方法中的形参一致，可以省略@RequestParam // public String get2(String name2) { public String get2(@RequestParam(&amp;quot;name&amp;quot;) String name2) { System.out.println(&amp;quot;name: &amp;quot;+ name2); return &amp;quot;Hi &amp;quot;+ name2; } @GetMapping(&amp;quot;/get3&amp;quot;) //给一个默认值或者required = false public String get3(@RequestParam(value = &amp;quot;name&amp;quot;, defaultValue = &amp;quot;admin&amp;quot;) String name) { System.out.println(&amp;quot;name: &amp;quot;+ name); return &amp;quot;Hi &amp;quot;+ name; }  2.post方式 @PostMapping(&amp;quot;/post&amp;quot;) //@RequestParam同get public String post(@RequestParam(&amp;quot;username&amp;quot;) String name, Integer age){ log.</description>
    </item>
    
    <item>
      <title>SpringBoot启动类</title>
      <link>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jun 2019 10:53:04 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</guid>
      <description>1.POM文件 整个项目的pom文件中（pom.xml）,可以看到该项目的parent，通过点击标签，可
&amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt;  2.启动器 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  注： spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件； SpringBoot启动器文档：https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter
3.主程序类 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }   @SpringBootApplication：用来标注这个类为SpringBoot的主配置类，该注解是一个组合注解。 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。  @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.</description>
    </item>
    
    <item>
      <title>SpringBoot入门</title>
      <link>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 08 Jun 2019 10:18:29 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</guid>
      <description>创建工程 使用IDEA，按照提示创建即可。
修改Banner 在resources目录下创建banner.txt文件，改文件用于指定banner，文字生成banner的网址：http://patorjk.com/software/taag。
${AnsiColor.BLUE} .____ ____ __. | | | |/ _| | | | &amp;lt; | |___| | \ |_______ \____|__ \ \/ \/ -----版本号-----${spring-boot.version}  说明： ${AnsiColor.BLUE} 表示Banner文字的颜色 ${spring-boot.version} 当前使用的SpringBoot版本
创建Controller类 @Controller public class HelloWorld { @RequestMapping(value = &amp;quot;/hello&amp;quot;,method = RequestMethod.GET) @ResponseBody public String hello(){ return &amp;quot;Hello Spring Boot&amp;quot;; } }  访问：http://localhost:8080/hello，即可以看到Hello Spring Boot 另外一种注解方式
@RestController public class HelloWorld { @GetMapping(&amp;quot;/hello&amp;quot;) public String hello(){ return &amp;quot;Hello Spring Boot&amp;quot;; } }  说明 * @RestController：处理http请求：等同于@Controller+@ResponseBody * @GetMapping：@RequestMapping以get请求的简写</description>
    </item>
    
    <item>
      <title>算法008</title>
      <link>https://pallcard.github.io/2019/algorithm008/</link>
      <pubDate>Wed, 05 Jun 2019 20:40:17 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm008/</guid>
      <description>描述 回旋数组
例子 Input: 3 3 Output: 1 2 3 8 9 4 7 6 5  思路 用count来计数， x,y当前坐标（行，列） last_t上次所走方向，右1 下2 左3 上4
代码 public class Question008 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int [][] array = new int [m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { array[i][j] = -1; } } int x = 0, y = 0; int count = 1; // 右1 下2 左3 上4 int last_t = 1; while (count &amp;lt;= m*n) { array[x][y] = count++; if(last_t == 1) { if (y+1&amp;lt;n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0){ y++; } else { last_t = 2; if (x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) { x++; }else { break; } } //下 } else if (last_t == 2) { if(x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) { x++; } else { last_t = 3; if (y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) { y--; } else { break; } } //左 } else if (last_t == 3) { if(y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) { y--; } else { last_t = 4; if (x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) { x--; } else { break; } } } //上 else { if(x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) { x--; } else { last_t = 1; if (y+1 &amp;lt; n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0) { y++; } else { break; } } } } for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { System.</description>
    </item>
    
    <item>
      <title>算法007</title>
      <link>https://pallcard.github.io/2019/algorithm007/</link>
      <pubDate>Wed, 05 Jun 2019 15:40:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm007/</guid>
      <description> 描述 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。
例子 Input: Output:  思路 一个栈负责入队，另一个栈负责出队。 * 队列push操作，直接进第一个栈 * 队列pop操作，判断第二个栈是否为空，若空将第一个栈所有元素进栈到第二个栈中，若不为空，则第二个栈直接出栈
代码 public class Question007 { private static Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;&amp;gt;(); private static Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;&amp;gt;(); public void push(Integer item){ stack1.push(item); } public Integer pop() throws Exception { if(stack2.isEmpty()) { while (!stack1.isEmpty()){ stack2.push(stack1.peek()); } } if(stack2.isEmpty()) { throw new Exception(&amp;quot;队列为空&amp;quot;); } return stack2.peek(); } }  </description>
    </item>
    
    <item>
      <title>算法006</title>
      <link>https://pallcard.github.io/2019/algorithm006/</link>
      <pubDate>Wed, 05 Jun 2019 14:50:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm006/</guid>
      <description>描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
例子 Input: 二叉树 Output: 中序遍历顺序的下一个结点  思路 中序遍历顺序的下一个结点，中序遍历是左根右， 判断该结点是否有右孩子， 1.若有，则下一个结点的最左子结点 2.若无，则下一个结点为第一个左链指向该结点的祖先结点的结点
代码 public class Question006 { class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } public TreeLinkNode GetNext(TreeLinkNode pNode) { TreeLinkNode resultNode = null; if(null != pNode.right) { resultNode = pNode.right; while (null != resultNode.left) { resultNode = resultNode.next; } } else { TreeLinkNode temp = pNode; resultNode = pNode.</description>
    </item>
    
    <item>
      <title>算法005</title>
      <link>https://pallcard.github.io/2019/algorithm005/</link>
      <pubDate>Wed, 05 Jun 2019 10:22:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm005/</guid>
      <description>描述 根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例子 Input: preorder：{3,9,20,15,7} inorder：{9,3,15,20,7} Output: 该二叉树  思路 根据先序遍历确定根，再通过中序遍历将数组划分为两部分，分别是左子树、右子树。 故可以通过一个HashMap存储中序遍历的数组值与下标，key为值，value为下标。
代码 class TreeNode { private TreeNode leftChild; private TreeNode rightChild; private int value; public TreeNode(int value) { this.value = value; } public TreeNode getLeftChild() { return leftChild; } public void setLeftChild(TreeNode leftChild) { this.leftChild = leftChild; } public TreeNode getRightChild() { return rightChild; } public void setRightChild(TreeNode rightChild) { this.rightChild = rightChild; } public int getValue() { return value; } public void setValue(int value) { this.</description>
    </item>
    
    <item>
      <title>算法004</title>
      <link>https://pallcard.github.io/2019/algorithm004/</link>
      <pubDate>Tue, 04 Jun 2019 19:45:58 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm004/</guid>
      <description>描述 从尾到头反过来打印出每个结点的值。
例子 Input: 1 -&amp;gt; 2 -&amp;gt; 3 Output: 3 2 1  思路 方法一：递归调用 方法二：使用栈
代码 class Node { private Node next; private int val; public Node(Node next, int val) { this.next = next; this.val = val; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } public int getVal() { return val; } public void setVal(int val) { this.val = val; } } public class Question004 { public static void main(String[] args) { Node node3 = new Node(null, 3); Node node2 = new Node(node3, 2); Node node1 = new Node(node2, 1); Node node = node1; //使用栈 Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); while (node !</description>
    </item>
    
    <item>
      <title>算法003</title>
      <link>https://pallcard.github.io/2019/algorithm003/</link>
      <pubDate>Tue, 04 Jun 2019 19:24:08 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm003/</guid>
      <description>描述 将一个字符串中的空格替换成 &amp;ldquo;%20&amp;rdquo;。
例子 Input: &amp;quot;A B&amp;quot; Output: &amp;quot;A%20B&amp;quot;  思路 由于要将字符串中所用空格替换为%20，故若字符串含有一个空格，则字符串的总长度会增长2，故可以先遍历一遍字符串，若将字符串的总长度变为相应的长度，需要两个指针，分别指向原字符串长度的最后一个票p1，和新字符串的最后一个p2，若原字符串为字符，则直接赋值给p2；若原字符串为空格，则赋值%20。
代码 public class Question003 { public static void main(String[] args) { StringBuilder sb = new StringBuilder(&amp;quot;A B&amp;quot;); int p1 = sb.length()-1;//指向原字符串最后一个 for (int i = 0; i &amp;lt;= p1; i++) { if(sb.charAt(i) == &#39; &#39;) { sb.append(&amp;quot; &amp;quot;); } } int p2 = sb.length()-1;//指向新字符串最后一个 while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p1 &amp;lt; p2) { if(sb.charAt(p1) != &#39; &#39;) { sb.</description>
    </item>
    
    <item>
      <title>算法002</title>
      <link>https://pallcard.github.io/2019/algorithm002/</link>
      <pubDate>Tue, 04 Jun 2019 16:55:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm002/</guid>
      <description>描述 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。 给定一个数，判断这个数是否在该二维数组中。
例子 Input: 数组： { {1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, {18, 21, 23, 26, 30}, }; 目标值：24 Output: 2  思路 由于每一行从左到右递增排序，从上到下也是递增排序，故可以从右上角开始遍历，若大于目标值，列减1；若小于目标值，行加1；若等于则成功找到。
代码 public class Question002 { public static void main(String[] args) { int target = 24; int [][] array = new int [][]{ {1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, {18, 21, 23, 26, 30}, }; int row = 0, col = array.</description>
    </item>
    
    <item>
      <title>算法001</title>
      <link>https://pallcard.github.io/2019/algorithm001/</link>
      <pubDate>Tue, 04 Jun 2019 16:37:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm001/</guid>
      <description> 描述 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
例子 Input: {2, 3, 1, 0, 2, 5} Output: 2  思路 由于数组中的值大小 为0 到 n-1，可以通过交换就数组中的元素放到与其下标对应的位置，若有两个数要出现在同一个位置，则找到了这个数。
代码 public class Question001 { public static void main(String[] args) { int[] array = new int[] {2,3,1,0,2,5}; for (int i = 0; i &amp;lt; array.length; i++) { while(i != array[i]) { if(array[i] == array[array[i]]) { System.out.println(array[i]); return; } else { swap(array,i,array[i]); } } } } public static void swap(int[] array, int left, int right) { int temp = array[left]; array[left] = array[right]; array[right] = temp; } }  </description>
    </item>
    
    <item>
      <title>JMM</title>
      <link>https://pallcard.github.io/2019/jmm/</link>
      <pubDate>Sun, 02 Jun 2019 10:28:33 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm/</guid>
      <description>JMM &amp;nbsp; &amp;nbsp; &amp;nbsp;Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。
JMM模型下的线程间通信 线程和主内存之间的抽象关系图：
线程间通信必须要经过主内存。
如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：
1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2）线程B到主内存中去读取线程A之前已更新过的共享变量。
注： 当线程操作某个对象时，执行顺序如下： (1) 从主存复制变量到当前工作内存 (read and load) (2) 执行代码，改变共享变量值 (use and assign) (3) 用工作内存数据刷新主存相关内容 (store and write)
说明： 关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：
 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。  JMM解决的问题 &amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：
原子性 ：一个操作不能被打断，要么全部执行完毕，要么不执行。 基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。
可见性 ：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;无论是 普通变量 还是 volatile变量 都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新 ，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。 除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 synchronized 关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 01 Jun 2019 20:42:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</guid>
      <description>题目描述 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素出现两次。找出只出现一次的元素。
示例 输入: [2,2,3] 输出: 3
思想 使用按位异或。异或：如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。
public static void main(String[] args) { int a [] = new int []{2,2,3}; int temp = 0; for (int i = 0; i &amp;lt; a.length; i++) { temp ^= a[i]; } System.out.println(temp); }  加强 上述数组中有两个数出现一次，求这两个数。
示例 输入: [2, 2, 6, 4, 5, 5] 输出: 4, 6
思想 先将所有数按位异或，得到temp，找到temp中二进制位为1的下标，通过这个下标将所用数分为两个数组，分别异或可以得到两个值。 若有两个数都只出现了一次，若将所有数进行按位异或后，所得到的数中，若按照上述划分，必然可以将这两个数分到不同的数组中
public static void main(String[] args) { int a [] = new int []{2, 2, 6, 4, 5, 5}; int temp = 0; int max = 0; for (int i = 0; i &amp;lt; a.</description>
    </item>
    
    <item>
      <title>Mysql题</title>
      <link>https://pallcard.github.io/2019/mysql%E9%A2%98/</link>
      <pubDate>Sat, 01 Jun 2019 18:52:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E9%A2%98/</guid>
      <description>1.左连接、右连接、内连接 左连接 以左表为基础，根据on后面的条件进行连接，若右表中无对应数据，则右表数据为NULL。
右连接 以右表为基础，根据on后面的条件进行连接，若左表中无对应数据，则左表数据为NULL。
内连接 两个表做笛卡尔积后根据on后面的条件进行筛选。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://pallcard.github.io/2019/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 31 May 2019 17:15:52 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。
1.懒汉式 public class Singleton1 { private static Singleton1 singleton1 = null; private Singleton1(){} public static Singleton1 newInstance() { if (singleton1 == null){ singleton1 = new Singleton1(); } return singleton1; } }  2.饿汉式 public class Singleton2 { private static Singleton2 singleton2 = new Singleton2(); private Singleton2(){} public static Singleton2 newSingleton(){ return singleton2; } }  3.懒汉式改 //序列化 public class Singleton3 implements Serializable { // volatile保证变量一致性 private volatile static Singleton3 singleton3 = null; private Singleton3(){ //防止反射调用私有方法 if(singleton3 !</description>
    </item>
    
    <item>
      <title>Hugo搭建blog</title>
      <link>https://pallcard.github.io/2019/hugo%E6%90%AD%E5%BB%BAblog/</link>
      <pubDate>Fri, 31 May 2019 16:21:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/hugo%E6%90%AD%E5%BB%BAblog/</guid>
      <description>在windows下使用hugo搭建blog
官方网站 https://www.gohugo.org/
1.安装hugo 在https://github.com/gohugoio/hugo/releases找到相应版本的hugo镜像，下载后解压，如下： 配置环境变量：将解压后压缩包放在E盘，则添加如下环境变量 输入如下命令判断是否按照成功
hugo version  2.建立站点 使用如下命令（blog为路径名）
hugo new site blog cd blog  生成目录如下 3.增加文章 输入以下命令后会在content里创建一个文件
hugo new about.md  打开文件，
--- title: &amp;quot;About&amp;quot; date: 2019-05-31T15:47:28+08:00 draft: true ---  4.安装主题 主题选择的是LeaveIt，安装后会在themes中生成对应文件
cd themes git clone https://github.com/liuzc/LeaveIt.git  并在config.toml中配置如下
theme = &amp;quot;LeaveIt&amp;quot;  4.运行hugo hugo server -D  5.配置 在content中新建文件夹posts，并在config.toml中加入配置如下：
# 菜单的配置 [menu] [[menu.main]] name = &amp;quot;博客&amp;quot; url = &amp;quot;/posts/&amp;quot; weight = 1 [[menu.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://pallcard.github.io/2019/java-proxy/</link>
      <pubDate>Wed, 29 May 2019 20:06:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/java-proxy/</guid>
      <description>代理模式 代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。 静态代理 静态代理目录结构 主题接口 IUserDao
public interface IUserDao { void saveUser(); }  主题接口实现类（被代理类） UserDao
public class UserDao implements IUserDao{ @Override public void saveUser() { System.out.println(&amp;quot;保存用户数据&amp;quot;); } }  代理类 UserDaoProxy
public class UserDaoProxy implements IUserDao { //目标对象 private IUserDao targer; public UserDaoProxy(IUserDao iUserDao){ this.targer = iUserDao; } @Override public void saveUser() { System.out.println(&amp;quot;开启事务&amp;quot;); targer.saveUser(); System.out.println(&amp;quot;提交事务&amp;quot;); } }  测试类 ProxyTest
public class ProxyTest { @Test void testStaticProxy(){ //目标对象 IUserDao target = new UserDao(); //代理对象 UserDaoProxy proxy = new UserDaoProxy(target); proxy.</description>
    </item>
    
    <item>
      <title>Mysql基础</title>
      <link>https://pallcard.github.io/2019/mysql%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 27 May 2019 18:56:26 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E5%9F%BA%E7%A1%80/</guid>
      <description>DBMS分类  基于共享文件系统的DBMS，例如：Microsoft Access 基于客户机—服务器的DBMS，例如：MySql，Oracle，SQL Server  连接mysql 格式：
mysql -h 主机地址 -u 用户名 -p 用户密码 例如：/usr/local/mysql/bin/mysql -u root -p  选择数据库 最初连接mysql时，没有任何数据库可供使用，需要使用use来选择一个数据库
use 数据库名称 例如：USE mysql  显示数据库一些信息 SHOW DATABASES; //显示所有数据库 SHOW TABLES; //显示当前数据库中所有表 SHOW COLUMNS FROM xxx; //显示xxx表中的列 DESCRIBE xxx；//同上 SHOW STATUS; //用于显示广泛的服务器状态信息 SHOW GRANTS; //显示授权用户权限 SHOW ERRORS和SHOW WARNINGS；//用来显示服务器错误或警告消息  检索数据 许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有 列和表名使用小写，这样做使代码更易于阅读和调试。
select SELECT DISTINCT yyy FROM xxx LIMIT 5; //检索xxx表中yyy列(DISTINCT去重，不多于5) SELECT * FROM xxx LIMIT 5, 5; //从第5行开始5行，下标0  注 DITINCT会作用于所有的列，不会部分使用</description>
    </item>
    
  </channel>
</rss>
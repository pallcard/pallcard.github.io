<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 刘科个人博客</title>
    <link>https://pallcard.github.io/posts/</link>
    <description>Recent content in Posts on 刘科个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Thu, 20 Jun 2019 19:00:36 +0800</lastBuildDate>
    
	<atom:link href="https://pallcard.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mybaits</title>
      <link>https://pallcard.github.io/2019/mybaits/</link>
      <pubDate>Thu, 20 Jun 2019 19:00:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mybaits/</guid>
      <description>前言 整个实验使用Maven 来管理项目，编译器IDEA，github仓库 https://github.com/pallcard/mybatis
JDBC连接数据库 1.引入依赖（pom.xml）
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.32&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;	 说明：（pom.xml） Maven 项目默认编译项目为JDK 1.5，通过引入以下依赖来指定Maven 编译版本
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;  2.JDBC测试类JDBCTest.java
public class JDBCTest { public static void main(String[] args) throws Exception { Connection connection = null; PreparedStatement prepareStatement = null; ResultSet rs = null; try { // 加载驱动(每次加载驱动，驱动名硬编码) Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;); // 获取连接(每次获取连接，连接信息硬编码) String url = &amp;quot;jdbc:mysql://127.0.0.1:3306/mybatis_demo&amp;quot;; String user = &amp;quot;root&amp;quot;; String password = &amp;quot;&amp;quot;; connection = DriverManager.</description>
    </item>
    
    <item>
      <title>Nginx问题</title>
      <link>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 19 Jun 2019 19:12:01 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/nginx%E9%97%AE%E9%A2%98/</guid>
      <description>常用命令
/usr/local/webserver/nginx/sbin/nginx -s reload # 重新载入配置文件 /usr/local/webserver/nginx/sbin/nginx -s reopen # 重启 Nginx /usr/local/webserver/nginx/sbin/nginx -s stop # 停止 Nginx  错误信息1
后期添加配置文件后，重新运行报错，（云服务器为centos，最初按照时直接用的默认安装）
错误信息：./configure: error: SSL modules require the OpenSSL library.
解决办法：
# 安装 yum -y install openssl openssl-devel yum -y install openssl openssl-devel ./configure --prefix=/usr/local/nginx --with-http_ssl_module  错误信息2
# 防火墙问题（也可能是安全组设置的问题） # 关闭防火墙命令： systemctl stop firewalld.service # 开启防火墙： systemctl start firewalld.service # 关闭开机自启动： systemctl disable firewalld.service # 开启开机启动： systemctl enable firewalld.service # 开放80 firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效） # 开放1000-2000 firewall-cmd --zone=public --add-port=1000-2000/tcp --permanent # 查看指定端口被哪个进程占用的情况 netstat -tunlp|grep 端口号  错误信息3</description>
    </item>
    
    <item>
      <title>FastDFS</title>
      <link>https://pallcard.github.io/2019/fastdfs/</link>
      <pubDate>Sat, 15 Jun 2019 19:43:24 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/fastdfs/</guid>
      <description>1. FastDFS 理论 FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。 FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。
tracker server 跟踪服务器，主要做调度工作，起负载均衡的作用。负责管理所有的storage server和group，每个storage在启动后会连接tracker，告诉tracker自己所属的group，并保持周期性心跳，tracker根据storage的心跳信息，建立映射表，tracke管理的元数据很少（tracker上的元数据都是由storage汇报产生），并且直接存在内存中，本身不需要持久化任何数据。tracker之间是对等的，因此扩展tracker是很容易的，直接增加tracker服务，同时修改storage的配置，增加新增的tarcker服务的地址和端口，重启即可。所有的tracker都会接受storage的心跳信息，以生成元数据信息。
storage server 存储服务器（又称：存储节点或数据服务器），顾名思义是用来保存文件的和文件属性的。以group为单位，每个group内可以包含多台storage server，数据互为备份，存储容量空间以group中storage server容量最小的为准。以group为单位组织存储能够方便的进行应用隔离、负责均衡和副本数定制；确定是group的容量受单机容量的限制。group内机器故障，需要依赖group内其他机器重新同步数据来恢复数据（更换坏盘，重启fdfs_storaged即可）。storage存储依赖本地文件系统，storage课配置多个数据存储目录，磁盘不做raid，直接分别挂在到多个目录，将这些目录配置为storage的数据目录即可。
storage接收写请求的时候，会根据配置好的规则，选择其中一个存储目录来存储文件；为了避免单个目录下的文件过多，storage第一次启动的时候，会在每个数据存储目录创建2级子目录，每级256，总共65536个目录，新写的文件会以hash的方式路由到其中一个子目录下，然后将文件数据直接作为一个本地文件存储。
client 客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。 文件上传 生成file id 选择存储目录之后，storage会生成一个file_id，采用base64编码，包含有：storage server ip，文件创建时间，文件大小，文件CRC32校验码和随机数。每个存储目录下有两个256*256个子目录，storage会按文件file_id进行两次hash，路由到其中一个子目录，然后将文件以file_id为名字存储。 文件路径如下： group0/M00/00/00/rBAAAl0EkICAIiBOAAABowgL3Pk888.png * 组名：group0 * 磁盘： M00 * 目录：00/00 * 文件名：rBAAAl0EkICAIiBOAAABowgL3Pk888.png
文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。
 组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存。 虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应。 数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。  文件下载 2.安装FastDFS环境 下载安装 libfastcommon yum -y install libevent # 下载libfastcommon wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz # 解压 tar -zxvf V1.0.7.tar.gz # 编译、安装 cd libfastcommon-1.</description>
    </item>
    
    <item>
      <title>初试部署项目到腾讯云（环境的安装）</title>
      <link>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 15 Jun 2019 19:32:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%88%9D%E8%AF%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/</guid>
      <description>linux常用命令  ls：查看该目录下文件 pwd：查看文件目录 rm -f 文件名：删除文件 /usr/local/mysql/bin/mysql -u root -p 登录mysql  第一步：jdk的安装 下载jdk后，解压报错（原因是选择接受协议的问题），输入如下命令：
wget --no-check-certificate --no-cookies --header &amp;quot;Cookie: oraclelicense=accept-securebackup-cookie&amp;quot; https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz  解压jdk压缩包，使用命令 tar -zxvf 文件名
然后配置环境变量，主要编辑以下两个文件
vi /etc/environment vi /etc/profile  最后使用java -version查看版本信息
第二步：mysql的安装 1.下载mysql ，以5.7为例
sudo wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz # 解压 tar -zxvf mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz  2.移动 文件到 /usr/local/
重命名 mv 文件名 mysql
3.新建data目录 mkdir data
4.新建mysql用户、mysql用户组
mysql用户组
groupadd mysql  mysql用户
useradd mysql -g mysql  5.将/usr/local/mysql的所有者及所属组改为mysql</description>
    </item>
    
    <item>
      <title>SpringBoot之配置文件</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 08 Jun 2019 20:21:05 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>1.配置文件基本使用 使用.yml配置文件，在resources目录下新建application.yml文件
server: port: 8081 #修改端口号 servlet: context-path: /lk #端口号后需额外添加字符 #以上等同于application.properties的以下写法 #server.port=8081 #server.servlet.context-path=/zed swagger: title: SpringBoot学习 description: SpringBoot学习 version: 1.0.0 name: lk url: https://pallcard.github.io email: 1250585541@qq.com  注 * 其中空格有严格的要求
2.切换配置文件 在resources目录下新建application-dev.yml文件，application-prod.yml文件
//文件目录 resources|- application.yml application-dev.yml application-prod.yml  其中application.yml来切换配置文件
spring: profiles: active: dev  激活文件选择 * 使用上述application.yml来设置 * 使用java -jar ***.jar &amp;ndash;spring.profiles.active=dev; * IDEA中可以如下设置 3.配置文件使用  单值注入 （.yml中值若用双引号，转义字符会转义） ```java //.yml中 person: name: zhangsan \n lisi name2: &amp;lsquo;zhangsan \n lisi&amp;rsquo; name3: &amp;ldquo;zhangsan \n lisi&amp;rdquo; age: 18 boss: false  //使用 @Value(&amp;ldquo;${person.</description>
    </item>
    
    <item>
      <title>SpringBoot之Swagger</title>
      <link>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</link>
      <pubDate>Sat, 08 Jun 2019 17:49:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%B9%8Bswagger/</guid>
      <description>Swagger框架 描述和测试API接口,自动生成API接口文档。
1.添加依赖 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--lombok依赖--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.18.8&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt;  2.Swagger配置 在resources目录下新建application.yml文件，添加如下配置
swagger: title: SpringBoot学习 description: SpringBoot学习 version: 1.0.0 name: lk url: https://pallcard.github.io email: 1250585541@qq.com  新建SwaggerConfig文件
@Configuration @EnableWebMvc @EnableSwagger2 @ConfigurationProperties(prefix = &amp;quot;swagger&amp;quot;) @Data //lombok @ComponentScan(basePackages = {&amp;quot;cn.wishhust.demo.controller&amp;quot;}) public class SwaggerConfig { private String title; private String description; private String version; private String name; private String url; private String email; @Bean public Docket customDocket() { return new Docket(DocumentationType.</description>
    </item>
    
    <item>
      <title>SpringBoot传递参数</title>
      <link>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 08 Jun 2019 17:08:34 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</guid>
      <description>url传参 1.get方式 // 访问：http://localhost:8080/test/get/xxx @GetMapping(&amp;quot;/get/{name}&amp;quot;) public String get(@PathVariable(&amp;quot;name&amp;quot;) String name2){ System.out.println(&amp;quot;name: &amp;quot;+ name2); return &amp;quot;Hi &amp;quot;+ name2; } // 访问：http://localhost:8080/test/get2?name=yyy @GetMapping(&amp;quot;/get2&amp;quot;) // 请求参数名字与方法中的形参一致，可以省略@RequestParam // public String get2(String name2) { public String get2(@RequestParam(&amp;quot;name&amp;quot;) String name2) { System.out.println(&amp;quot;name: &amp;quot;+ name2); return &amp;quot;Hi &amp;quot;+ name2; } @GetMapping(&amp;quot;/get3&amp;quot;) //给一个默认值或者required = false public String get3(@RequestParam(value = &amp;quot;name&amp;quot;, defaultValue = &amp;quot;admin&amp;quot;) String name) { System.out.println(&amp;quot;name: &amp;quot;+ name); return &amp;quot;Hi &amp;quot;+ name; }  2.post方式 @PostMapping(&amp;quot;/post&amp;quot;) //@RequestParam同get public String post(@RequestParam(&amp;quot;username&amp;quot;) String name, Integer age){ log.</description>
    </item>
    
    <item>
      <title>SpringBoot启动类</title>
      <link>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</link>
      <pubDate>Sat, 08 Jun 2019 10:53:04 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%90%AF%E5%8A%A8%E7%B1%BB/</guid>
      <description>1.POM文件 整个项目的pom文件中（pom.xml）,可以看到该项目的parent，通过点击标签，可以进入parent中，这样可以看到项目的最终的parent。
&amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt;  2.启动器 &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  注： spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件； SpringBoot启动器文档：https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#using-boot-starter
3.主程序类 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }   @SpringBootApplication：用来标注这个类为SpringBoot的主配置类，该注解是一个组合注解。 将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器； Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作； java @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.</description>
    </item>
    
    <item>
      <title>SpringBoot入门</title>
      <link>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 08 Jun 2019 10:18:29 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/springboot%E5%85%A5%E9%97%A8/</guid>
      <description>创建工程 使用IDEA，按照提示创建即可。
修改Banner 在resources目录下创建banner.txt文件，改文件用于指定banner，文字生成banner的网址：http://patorjk.com/software/taag。
${AnsiColor.BLUE} .____ ____ __. | | | |/ _| | | | &amp;lt; | |___| | \ |_______ \____|__ \ \/ \/ -----版本号-----${spring-boot.version}  说明： ${AnsiColor.BLUE} 表示Banner文字的颜色 ${spring-boot.version} 当前使用的SpringBoot版本
创建Controller类 @Controller public class HelloWorld { @RequestMapping(value = &amp;quot;/hello&amp;quot;,method = RequestMethod.GET) @ResponseBody public String hello(){ return &amp;quot;Hello Spring Boot&amp;quot;; } }  访问：http://localhost:8080/hello，即可以看到Hello Spring Boot 另外一种注解方式
@RestController public class HelloWorld { @GetMapping(&amp;quot;/hello&amp;quot;) public String hello(){ return &amp;quot;Hello Spring Boot&amp;quot;; } }  说明 * @RestController：处理http请求：等同于@Controller+@ResponseBody * @GetMapping：@RequestMapping以get请求的简写</description>
    </item>
    
    <item>
      <title>算法008</title>
      <link>https://pallcard.github.io/2019/algorithm008/</link>
      <pubDate>Wed, 05 Jun 2019 20:40:17 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm008/</guid>
      <description>public class Question008 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt();
 int [][] array = new int [m][n]; for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { array[i][j] = -1; } } int x = 0, y = 0; int count = 1; // 右1 下2 左3 上4 int last_t = 1; while (count &amp;lt;= m*n) { array[x][y] = count++; if(last_t == 1) { if (y+1&amp;lt;n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0){ y++; } else { last_t = 2; if (x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) { x++; }else { break; } } //下 } else if (last_t == 2) { if(x+1 &amp;lt; m &amp;amp;&amp;amp; array[x+1][y] &amp;lt; 0) { x++; } else { last_t = 3; if (y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) { y--; } else { break; } } //左 } else if (last_t == 3) { if(y-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x][y-1] &amp;lt; 0) { y--; } else { last_t = 4; if (x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) { x--; } else { break; } } } //上 else { if(x-1 &amp;gt;= 0 &amp;amp;&amp;amp; array[x-1][y] &amp;lt; 0) { x--; } else { last_t = 1; if (y+1 &amp;lt; n &amp;amp;&amp;amp; array[x][y+1] &amp;lt; 0) { y++; } else { break; } } } } for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { System.</description>
    </item>
    
    <item>
      <title>算法007</title>
      <link>https://pallcard.github.io/2019/algorithm007/</link>
      <pubDate>Wed, 05 Jun 2019 15:40:44 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm007/</guid>
      <description> 描述 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。
例子 Input: Output:  思路 一个栈负责入队，另一个栈负责出队。 * 队列push操作，直接进第一个栈 * 队列pop操作，判断第二个栈是否为空，若空将第一个栈所有元素进栈到第二个栈中，若不为空，则第二个栈直接出栈
代码 public class Question007 { private static Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;&amp;gt;(); private static Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;&amp;gt;(); public void push(Integer item){ stack1.push(item); } public Integer pop() throws Exception { if(stack2.isEmpty()) { while (!stack1.isEmpty()){ stack2.push(stack1.peek()); } } if(stack2.isEmpty()) { throw new Exception(&amp;quot;队列为空&amp;quot;); } return stack2.peek(); } }  </description>
    </item>
    
    <item>
      <title>算法006</title>
      <link>https://pallcard.github.io/2019/algorithm006/</link>
      <pubDate>Wed, 05 Jun 2019 14:50:36 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm006/</guid>
      <description>描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。 注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
例子 Input: 二叉树 Output: 中序遍历顺序的下一个结点  思路 中序遍历顺序的下一个结点，中序遍历是左根右， 判断该结点是否有右孩子， 1.若有，则下一个结点的最左子结点 2.若无，则下一个结点为第一个左链指向该结点的祖先结点的结点
代码 public class Question006 { class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } public TreeLinkNode GetNext(TreeLinkNode pNode) { TreeLinkNode resultNode = null; if(null != pNode.right) { resultNode = pNode.right; while (null != resultNode.left) { resultNode = resultNode.next; } } else { TreeLinkNode temp = pNode; resultNode = pNode.</description>
    </item>
    
    <item>
      <title>算法005</title>
      <link>https://pallcard.github.io/2019/algorithm005/</link>
      <pubDate>Wed, 05 Jun 2019 10:22:59 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm005/</guid>
      <description>描述 根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例子 Input: preorder：{3,9,20,15,7} inorder：{9,3,15,20,7} Output: 该二叉树  思路 根据先序遍历确定根，再通过中序遍历将数组划分为两部分，分别是左子树、右子树。 故可以通过一个HashMap存储中序遍历的数组值与下标，key为值，value为下标。
代码 class TreeNode { private TreeNode leftChild; private TreeNode rightChild; private int value; public TreeNode(int value) { this.value = value; } public TreeNode getLeftChild() { return leftChild; } public void setLeftChild(TreeNode leftChild) { this.leftChild = leftChild; } public TreeNode getRightChild() { return rightChild; } public void setRightChild(TreeNode rightChild) { this.rightChild = rightChild; } public int getValue() { return value; } public void setValue(int value) { this.</description>
    </item>
    
    <item>
      <title>算法004</title>
      <link>https://pallcard.github.io/2019/algorithm004/</link>
      <pubDate>Tue, 04 Jun 2019 19:45:58 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm004/</guid>
      <description>描述 从尾到头反过来打印出每个结点的值。
例子 Input: 1 -&amp;gt; 2 -&amp;gt; 3 Output: 3 2 1  思路 方法一：递归调用 方法二：使用栈
代码 class Node { private Node next; private int val; public Node(Node next, int val) { this.next = next; this.val = val; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; } public int getVal() { return val; } public void setVal(int val) { this.val = val; } } public class Question004 { public static void main(String[] args) { Node node3 = new Node(null, 3); Node node2 = new Node(node3, 2); Node node1 = new Node(node2, 1); Node node = node1; //使用栈 Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); while (node !</description>
    </item>
    
    <item>
      <title>算法003</title>
      <link>https://pallcard.github.io/2019/algorithm003/</link>
      <pubDate>Tue, 04 Jun 2019 19:24:08 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm003/</guid>
      <description>描述 将一个字符串中的空格替换成 &amp;ldquo;%20&amp;rdquo;。
例子 Input: &amp;quot;A B&amp;quot; Output: &amp;quot;A%20B&amp;quot;  思路 由于要将字符串中所用空格替换为%20，故若字符串含有一个空格，则字符串的总长度会增长2，故可以先遍历一遍字符串，若将字符串的总长度变为相应的长度，需要两个指针，分别指向原字符串长度的最后一个票p1，和新字符串的最后一个p2，若原字符串为字符，则直接赋值给p2；若原字符串为空格，则赋值%20。
代码 public class Question003 { public static void main(String[] args) { StringBuilder sb = new StringBuilder(&amp;quot;A B&amp;quot;); int p1 = sb.length()-1;//指向原字符串最后一个 for (int i = 0; i &amp;lt;= p1; i++) { if(sb.charAt(i) == &#39; &#39;) { sb.append(&amp;quot; &amp;quot;); } } int p2 = sb.length()-1;//指向新字符串最后一个 while (p1 &amp;gt;= 0 &amp;amp;&amp;amp; p1 &amp;lt; p2) { if(sb.charAt(p1) != &#39; &#39;) { sb.</description>
    </item>
    
    <item>
      <title>算法002</title>
      <link>https://pallcard.github.io/2019/algorithm002/</link>
      <pubDate>Tue, 04 Jun 2019 16:55:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm002/</guid>
      <description>描述 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。 给定一个数，判断这个数是否在该二维数组中。
例子 Input: 数组： { {1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, {18, 21, 23, 26, 30}, }; 目标值：24 Output: 2  思路 由于每一行从左到右递增排序，从上到下也是递增排序，故可以从右上角开始遍历，若大于目标值，列减1；若小于目标值，行加1；若等于则成功找到。
代码 public class Question002 { public static void main(String[] args) { int target = 24; int [][] array = new int [][]{ {1, 4, 7, 11, 15}, {2, 5, 8, 12, 19}, {3, 6, 9, 16, 22}, {10, 13, 14, 17, 24}, {18, 21, 23, 26, 30}, }; int row = 0, col = array.</description>
    </item>
    
    <item>
      <title>算法001</title>
      <link>https://pallcard.github.io/2019/algorithm001/</link>
      <pubDate>Tue, 04 Jun 2019 16:37:28 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/algorithm001/</guid>
      <description> 描述 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
例子 Input: {2, 3, 1, 0, 2, 5} Output: 2  思路 由于数组中的值大小 为0 到 n-1，可以通过交换就数组中的元素放到与其下标对应的位置，若有两个数要出现在同一个位置，则找到了这个数。
代码 public class Question001 { public static void main(String[] args) { int[] array = new int[] {2,3,1,0,2,5}; for (int i = 0; i &amp;lt; array.length; i++) { while(i != array[i]) { if(array[i] == array[array[i]]) { System.out.println(array[i]); return; } else { swap(array,i,array[i]); } } } } public static void swap(int[] array, int left, int right) { int temp = array[left]; array[left] = array[right]; array[right] = temp; } }  </description>
    </item>
    
    <item>
      <title>JMM</title>
      <link>https://pallcard.github.io/2019/jmm/</link>
      <pubDate>Sun, 02 Jun 2019 10:28:33 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/jmm/</guid>
      <description>JMM &amp;nbsp; &amp;nbsp; &amp;nbsp;Java虚拟机规范中定义了Java内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果，JMM规范了Java虚拟机与计算机内存是如何协同工作的。
JMM模型下的线程间通信 线程和主内存之间的抽象关系图： 线程间通信必须要经过主内存。
如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：
1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。
2）线程B到主内存中去读取线程A之前已更新过的共享变量。 注： 当线程操作某个对象时，执行顺序如下： (1) 从主存复制变量到当前工作内存 (read and load) (2) 执行代码，改变共享变量值 (use and assign) (3) 用工作内存数据刷新主存相关内容 (store and write)
JMM解决的问题 &amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是围绕着并发编程中原子性、可见性、有序性这三个特征来建立的，那我们依次看一下这三个特征：
原子性 ：一个操作不能被打断，要么全部执行完毕，要么不执行。 基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。
可见性 ：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;无论是 普通变量 还是 volatile变量 都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新 ，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。 除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。
&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 synchronized 关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;使用 Lock接口 的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。
&amp;nbsp; &amp;nbsp; &amp;nbsp;final关键字 的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去，那么其他线程就可以看到final变量的值。</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 01 Jun 2019 20:42:19 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E7%AE%97%E6%B3%95/</guid>
      <description>题目描述 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素出现两次。找出只出现一次的元素。
示例 输入: [2,2,3] 输出: 3
思想 使用按位异或。异或：如果a、b两个值不相同，则异或结果为1。 如果a、b两个值相同，异或结果为0。
public static void main(String[] args) { int a [] = new int []{2,2,3}; int temp = 0; for (int i = 0; i &amp;lt; a.length; i++) { temp ^= a[i]; } System.out.println(temp); }  加强 上述数组中有两个数出现一次，求这两个数。
示例 输入: [2, 2, 6, 4, 5, 5] 输出: 4, 6
思想 先将所有数按位异或，得到temp，找到temp中二进制位为1的下标，通过这个下标将所用数分为两个数组，分别异或可以得到两个值。 若有两个数都只出现了一次，若将所有数进行按位异或后，所得到的数中，若按照上述划分，必然可以将这两个数分到不同的数组中
public static void main(String[] args) { int a [] = new int []{2, 2, 6, 4, 5, 5}; int temp = 0; int max = 0; for (int i = 0; i &amp;lt; a.</description>
    </item>
    
    <item>
      <title>Mysql题</title>
      <link>https://pallcard.github.io/2019/mysql%E9%A2%98/</link>
      <pubDate>Sat, 01 Jun 2019 18:52:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E9%A2%98/</guid>
      <description>1.左连接、右连接、内连接 左连接 以左表为基础，根据on后面的条件进行连接，若右表中无对应数据，则右表数据为NULL。
右连接 以右表为基础，根据on后面的条件进行连接，若左表中无对应数据，则左表数据为NULL。
内连接 两个表做笛卡尔积后根据on后面的条件进行筛选。</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://pallcard.github.io/2019/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 31 May 2019 17:15:52 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。
1.懒汉式 public class Singleton1 { private static Singleton1 singleton1 = null; private Singleton1(){} public static Singleton1 newInstance() { if (singleton1 == null){ singleton1 = new Singleton1(); } return singleton1; } }  2.饿汉式 public class Singleton2 { private static Singleton2 singleton2 = new Singleton2(); private Singleton2(){} public static Singleton2 newSingleton(){ return singleton2; } }  3.懒汉式改 //序列化 public class Singleton3 implements Serializable { // volatile保证变量一致性 private volatile static Singleton3 singleton3 = null; private Singleton3(){ //防止反射调用私有方法 if(singleton3 !</description>
    </item>
    
    <item>
      <title>Hugo搭建blog</title>
      <link>https://pallcard.github.io/2019/hugo%E6%90%AD%E5%BB%BAblog/</link>
      <pubDate>Fri, 31 May 2019 16:21:56 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/hugo%E6%90%AD%E5%BB%BAblog/</guid>
      <description>在windows下使用hugo搭建blog
官方网站 https://www.gohugo.org/
1.安装hugo 在https://github.com/gohugoio/hugo/releases找到相应版本的hugo镜像，下载后解压，如下： 配置环境变量：将解压后压缩包放在E盘，则添加如下环境变量 输入如下命令判断是否按照成功
hugo version  2.建立站点 使用如下命令（blog为路径名）
hugo new site blog cd blog  生成目录如下 3.增加文章 输入以下命令后会在content里创建一个文件
hugo new about.md  打开文件，
--- title: &amp;quot;About&amp;quot; date: 2019-05-31T15:47:28+08:00 draft: true ---  4.安装主题 主题选择的是LeaveIt，安装后会在themes中生成对应文件
cd themes git clone https://github.com/liuzc/LeaveIt.git  并在config.toml中配置如下
theme = &amp;quot;LeaveIt&amp;quot;  4.运行hugo hugo server -D  5.配置 在content中新建文件夹posts，并在config.toml中加入配置如下：
# 菜单的配置 [menu] [[menu.main]] name = &amp;quot;博客&amp;quot; url = &amp;quot;/posts/&amp;quot; weight = 1 [[menu.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://pallcard.github.io/2019/java-proxy/</link>
      <pubDate>Wed, 29 May 2019 20:06:16 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/java-proxy/</guid>
      <description>代理模式 代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。 静态代理 静态代理目录结构 主题接口 IUserDao
public interface IUserDao { void saveUser(); }  主题接口实现类（被代理类） UserDao
public class UserDao implements IUserDao{ @Override public void saveUser() { System.out.println(&amp;quot;保存用户数据&amp;quot;); } }  代理类 UserDaoProxy
public class UserDaoProxy implements IUserDao { //目标对象 private IUserDao targer; public UserDaoProxy(IUserDao iUserDao){ this.targer = iUserDao; } @Override public void saveUser() { System.out.println(&amp;quot;开启事务&amp;quot;); targer.saveUser(); System.out.println(&amp;quot;提交事务&amp;quot;); } }  测试类 ProxyTest
public class ProxyTest { @Test void testStaticProxy(){ //目标对象 IUserDao target = new UserDao(); //代理对象 UserDaoProxy proxy = new UserDaoProxy(target); proxy.</description>
    </item>
    
    <item>
      <title>Mysql基础</title>
      <link>https://pallcard.github.io/2019/mysql%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 27 May 2019 18:56:26 +0800</pubDate>
      
      <guid>https://pallcard.github.io/2019/mysql%E5%9F%BA%E7%A1%80/</guid>
      <description>DBMS分类  基于共享文件系统的DBMS，例如：Microsoft Access 基于客户机—服务器的DBMS，例如：MySql，Oracle，SQL Server  连接mysql 格式：
mysql -h 主机地址 -u 用户名 -p 用户密码 例如：/usr/local/mysql/bin/mysql -u root -p  选择数据库 最初连接mysql时，没有任何数据库可供使用，需要使用use来选择一个数据库
use 数据库名称 例如：USE mysql  显示数据库一些信息 SHOW DATABASES; //显示所有数据库 SHOW TABLES; //显示当前数据库中所有表 SHOW COLUMNS FROM xxx; //显示xxx表中的列 DESCRIBE xxx；//同上 SHOW STATUS; //用于显示广泛的服务器状态信息 SHOW GRANTS; //显示授权用户权限 SHOW ERRORS和SHOW WARNINGS；//用来显示服务器错误或警告消息  检索数据 许多SQL开发人员喜欢对所有SQL关键字使用大写，而对所有 列和表名使用小写，这样做使代码更易于阅读和调试。
select SELECT DISTINCT yyy FROM xxx LIMIT 5; //检索xxx表中yyy列(DISTINCT去重，不多于5) SELECT * FROM xxx LIMIT 5, 5; //从第5行开始5行，下标0  注 DITINCT会作用于所有的列，不会部分使用</description>
    </item>
    
  </channel>
</rss>